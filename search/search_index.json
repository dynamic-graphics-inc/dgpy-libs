{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#dgpy-libs","title":"dgpy-libs","text":"<p>Docs: dynamic-graphics-inc.github.io/dgpy-libs</p> <p>Repo: github.com/dynamic-graphics-inc/dgpy-libs</p> <p>Dynamic Graphics python libraries, home of:</p> <ul> <li>Callable modules/packages</li> <li>Recursive list/generator comprehensions</li> <li>Many decorators</li> <li>Secret agent JSON-Bourne</li> </ul>"},{"location":"#libs","title":"Libs","text":"<pre><code>libs\n\u251c\u2500\u2500 aiopen      - async file-io\n\u251c\u2500\u2500 asyncify    - async/await utilities\n\u251c\u2500\u2500 dgpylibs    - dgpy-libs mega package\n\u251c\u2500\u2500 dgpytest    - pytest plugin (WIP)\n\u251c\u2500\u2500 fmts        - string formatting tools\n\u251c\u2500\u2500 funkify     - callable modules\n\u251c\u2500\u2500 h5          - hdf5 tools\n\u251c\u2500\u2500 jsonbourne  - JSON tools/wrappers\n\u251c\u2500\u2500 lager       - logging library built on loguru\n\u251c\u2500\u2500 listless    - generator tools\n\u251c\u2500\u2500 requires    - dynamic import(s)\n\u251c\u2500\u2500 shellfish   - shell and filesystem tools\n\u2514\u2500\u2500 xtyping     - types\n</code></pre> <p>Install:</p> <pre><code># pip\npip install aiopen asyncify fmts funkify h5 jsonbourne lager listless requires shellfish xtyping\n# uv\nuv add aiopen asyncify fmts funkify h5 jsonbourne lager listless requires shellfish xtyping\n</code></pre> Package Install Version Python Versions aiopen <code>pip install aiopen</code> asyncify <code>pip install asyncify</code> fmts <code>pip install fmts</code> funkify <code>pip install funkify</code> h5 <code>pip install h5</code> jsonbourne <code>pip install jsonbourne</code> lager <code>pip install lager</code> listless <code>pip install listless</code> requires <code>pip install requires</code> shellfish <code>pip install shellfish</code> xtyping <code>pip install xtyping</code>"},{"location":"#about","title":"About","text":"<p>This repo (dgpy-libs) are the polished gems formed under intense geological pressure below the offices of Dynamic Graphics Inc. These python libraries are all published on pip under the listed names.</p>"},{"location":"#design-philosopy","title":"Design PhilosoPY","text":"<ul> <li>dgpy-libs must have excellent names and be published on pip</li> <li>Embrace <code>async/await</code></li> <li>Python 3.9+ 'n up, baby!</li> <li>Use type annotations everywhere</li> <li>No dead or commented out code</li> <li>Use optional compiled-3rd-party-libs as optional dependencies to sneakily   speed things up if present</li> <li>Optional dependencies are good! Missing optional deps should trigger an error   msg that is helpful to installing the relevant dependency ONLY IF THE   DEPENDENCY IS NEEDED.</li> <li>Test coverage is usually a dumb metric and 100% test coverage <code>!=</code> bug-free   code (tests of dgpy-libs are slowly being migrated from internal/private repos   to this repo)</li> </ul>"},{"location":"#third-party-friends","title":"Third party friends","text":"<ul> <li>uv: the greatest thing since sliced bread</li> <li>ruff: python linter and formatter</li> <li>pydantic: no need for explanation</li> <li>loguru: very nice python logging library</li> <li>httpx: http client library</li> <li>attrs; class decorators library</li> <li>orjson; fastest python json library (optional   dep of jsonbourne)</li> <li>rapidjson/python-rapidjson;   best mostly drop-in replacement for python's json module</li> <li>h5py; base of h5</li> <li>rich; best python console formatting   library</li> <li>nox; truly a work of art</li> </ul>"},{"location":"#notebooks","title":"Notebooks","text":"<pre><code>notebooks/\n\u251c\u2500\u2500 cache_money.ipynb\n\u251c\u2500\u2500 filter_none.ipynb\n\u251c\u2500\u2500 json_parsing.ipynb\n\u2514\u2500\u2500 string_fmt.ipynb\n</code></pre> <ul> <li>Filtering None and False-y values</li> <li>cache money! <code>functools.lru_cache</code></li> <li>String formatting funks</li> <li>JSON parsing vs plain-jane dictionaries</li> </ul>"},{"location":"#contributors","title":"Contributor(s)","text":"<ul> <li>Jesse Rubin ~ <code>jesse@dgi.com</code> /   <code>jessekrubin@gmail.com</code></li> <li>Dan Costello ~ <code>dan@dgi.com</code> /   <code>dan.costello2@gmail.com</code></li> <li>Possibly you!?</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>Plz do! Send me that PR!</p>"},{"location":"#license","title":"License","text":"<p>All dgpy-libs are MIT licensed</p> <pre><code>dgpy-libs\n\nThe MIT License (MIT)\n\nCopyright (c) 2019-2026 Dynamic Graphics Inc (dgi)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n</code></pre>"},{"location":"libs/aiopen/","title":"aiopen","text":""},{"location":"libs/aiopen/#aiopen","title":"aiopen\u00b6","text":"<p>Install: <code>pip install aiopen</code></p> <p>Async-open</p> <p>Why not use aiofiles?</p> <ul> <li>Wanted more type annotations</li> <li>aiofiles uses ye ole <code>@coroutine</code> decorator -- aiopen uses python3.6+ <code>async/await</code></li> <li>aiopen is a callable module, so you can do:<ul> <li><code>import aiopen</code></li> <li><code>async with aiopen('afile.txt', 'w') as f: await f.write('some text!')</code></li> <li><code>async with aiopen('afile.txt', 'r') as f: content = await f.read()</code></li> </ul> </li> </ul> <p>(Big shouts out to the aiofiles people, aiopen is entirely based off of aiofiles)</p>"},{"location":"libs/aiopen/#usage","title":"Usage:\u00b6","text":"<p>Just import it! The module is also callable!</p> <pre>import aiopen\n\nasync with aiopen('afile.txt', 'w') as f:\n    await f.write('some text!')\n\nasync with aiopen('afile.txt', 'r') as f:\n    content = await f.read()\n    print(content)\n</pre>"},{"location":"libs/aiopen/aiopen.api/","title":"aiopen","text":""},{"location":"libs/aiopen/aiopen.api/#aiopen","title":"aiopen","text":"<p><code>aiopen</code> ~ Async version of python's built in open -- based on aiofiles</p> <p>Modules:</p> <ul> <li> <code>core</code>           \u2013            <p>Async io base functions and utilities</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>aiopen</code>             \u2013              <p>Async version of the <code>open</code> builtin</p> </li> </ul>"},{"location":"libs/aiopen/aiopen.api/#aiopen.aiopen","title":"aiopen","text":"<pre><code>aiopen(\n    file: PathType,\n    mode: str = \"r\",\n    *,\n    buffering: int = -1,\n    encoding: str | None = None,\n    errors: None = None,\n    newline: None = None,\n    closefd: bool = True,\n    opener: None = None,\n    loop: AbstractEventLoop | None = None,\n    executor: Any = None,\n) -&gt; AiopenContextManager\n</code></pre> <p>Async version of the <code>open</code> builtin</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def main():\n...     async with aiopen(\"test.txt\", \"w\") as f:\n...         await f.write(\"test\")\n...     async with aiopen(\"test.txt\", \"r\") as f:\n...         assert await f.read() == \"test\"\n&gt;&gt;&gt; asyncio.run(main())\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; if os.path.exists(\"test.txt\"):\n...     os.remove(\"test.txt\")\n</code></pre>"},{"location":"libs/asyncify/","title":"asyncify","text":"In\u00a0[1]: Copied! <pre>import asyncify\n\n\n# OR\nfrom asyncify import (\n    asyncify,  # asyncio.run polyfill for python36\n)\n\n\ndef add(a, b):\n    return a + b\n\n\nassert add(1, 2) == 3\n\n\n@asyncify\ndef add_async(a, b):\n    return a + b\n\n\nres = await add_async(1, 2)\nassert res == 3\n</pre> import asyncify   # OR from asyncify import (     asyncify,  # asyncio.run polyfill for python36 )   def add(a, b):     return a + b   assert add(1, 2) == 3   @asyncify def add_async(a, b):     return a + b   res = await add_async(1, 2) assert res == 3"},{"location":"libs/asyncify/#asyncify","title":"asyncify\u00b6","text":"<p>TLDR: Sync 2 Async decorator</p> <p>Install: <code>pip install asyncify</code></p> <p>Usage:</p>"},{"location":"libs/asyncify/asyncify.api/","title":"asyncify","text":""},{"location":"libs/asyncify/asyncify.api/#asyncify","title":"asyncify","text":"<p>Asyncify</p> <p>Modules:</p> <ul> <li> <code>aios</code>           \u2013            <p>aios = asyncio + os</p> </li> <li> <code>core</code>           \u2013            <p>Asyncify core</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>aiorun_anyio</code>             \u2013              <p>Run an async function or awaitable using anyio</p> </li> <li> <code>aiterable</code>             \u2013              <p>Convert any-iterable to an async iterator</p> </li> <li> <code>asyncify</code>             \u2013              <p>Makes a sync function async</p> </li> <li> <code>await_or_return</code>             \u2013              <p>Return the result of an awaitable or return the object</p> </li> <li> <code>is_async</code>             \u2013              <p>Return True if function/object is async/awaitable</p> </li> <li> <code>run</code>             \u2013              <p>Run an async/awaitable function (Polyfill asyncio.run)</p> </li> </ul>"},{"location":"libs/asyncify/asyncify.api/#asyncify.aiorun_anyio","title":"aiorun_anyio","text":"<pre><code>aiorun_anyio(\n    awaitable_or_func: Awaitable[T_Retval]\n    | Callable[..., Coroutine[Any, Any, T_Retval]],\n    *args: object,\n    backend: str = \"asyncio\",\n    backend_options: dict[str, Any] | None = None,\n) -&gt; T_Retval\n</code></pre> <p>Run an async function or awaitable using anyio</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T_Retval</code> (              <code>T_Retval</code> )          \u2013            <p>Return value of the function</p> </li> </ul>"},{"location":"libs/asyncify/asyncify.api/#asyncify.aiorun_anyio(awaitable_or_func)","title":"<code>awaitable_or_func</code>","text":"(<code>Awaitable[T_Retval] | Callable[..., Coroutine[Any, Any, T_Retval]]</code>)           \u2013            <p>Function or awaitable to run</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.aiorun_anyio(*args)","title":"<code>*args</code>","text":"(<code>object</code>, default:                   <code>()</code> )           \u2013            <p>args to pass to the function</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.aiorun_anyio(backend)","title":"<code>backend</code>","text":"(<code>str</code>, default:                   <code>'asyncio'</code> )           \u2013            <p>Backend to use for running the function</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.aiorun_anyio(backend_options)","title":"<code>backend_options</code>","text":"(<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Options to pass to the backend</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.aiterable","title":"aiterable","text":"<pre><code>aiterable(\n    it: Iterable[T] | AsyncIterable[T],\n) -&gt; AsyncIterator[T]\n</code></pre> <p>Convert any-iterable to an async iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; plain_jane_list = list(range(10))\n&gt;&gt;&gt; async def consume_aiterable(it):\n...     stuff = []\n...     async for el in aiterable(it):\n...         stuff.append(el)\n...     return stuff\n&gt;&gt;&gt; run(consume_aiterable(plain_jane_list))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; async def async_gen():\n...     for b in range(10):\n...        yield b\n&gt;&gt;&gt; run(consume_aiterable(async_gen()))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(consume_aiterable(AsyncIterable()))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"libs/asyncify/asyncify.api/#asyncify.asyncify","title":"asyncify","text":"<pre><code>asyncify(\n    funk: Callable[P, T],\n    *,\n    loop: AbstractEventLoop | None = None,\n    executor: Any | None = None,\n) -&gt; Callable[P, Awaitable[T]]\n</code></pre> <p>Makes a sync function async</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[P, Awaitable[T]]</code>           \u2013            <p>An asynchronous function</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncify import asyncify\n&gt;&gt;&gt; def add(a, b):\n...     return a + b\n&gt;&gt;&gt; add(1, 5)\n6\n&gt;&gt;&gt; @asyncify\n... def add_async(a, b):\n...     return a + b\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; run(add_async(1, 5))\n6\n</code></pre>"},{"location":"libs/asyncify/asyncify.api/#asyncify.asyncify(funk)","title":"<code>funk</code>","text":"(<code>Callable[P, T]</code>)           \u2013            <p>Function to make into an async coroutine</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.asyncify(loop)","title":"<code>loop</code>","text":"(<code>AbstractEventLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>Event loop in which to run/execute</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.asyncify(executor)","title":"<code>executor</code>","text":"(<code>Any | None</code>, default:                   <code>None</code> )           \u2013            <p>Executor to with which to execute</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.await_or_return","title":"await_or_return  <code>async</code>","text":"<pre><code>await_or_return(obj: Awaitable[T] | T) -&gt; T\n</code></pre> <p>Return the result of an awaitable or return the object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncify import await_or_return, run\n&gt;&gt;&gt; def add(a, b): return a + b\n&gt;&gt;&gt; run(await_or_return(add(1, 4)))\n5\n&gt;&gt;&gt; async def add_(a, b): return a + b\n&gt;&gt;&gt; run(await_or_return(add_(1, 4)))\n5\n</code></pre>"},{"location":"libs/asyncify/asyncify.api/#asyncify.is_async","title":"is_async","text":"<pre><code>is_async(obj: Any) -&gt; bool\n</code></pre> <p>Return True if function/object is async/awaitable</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the object is async/awaitable; False otherwise</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncify import is_async\n&gt;&gt;&gt; def add(a, b): return a + b\n&gt;&gt;&gt; is_async(add)\nFalse\n&gt;&gt;&gt; async def add_(a, b): return a + b\n&gt;&gt;&gt; is_async(add_)\nTrue\n</code></pre>"},{"location":"libs/asyncify/asyncify.api/#asyncify.is_async(obj)","title":"<code>obj</code>","text":"(<code>Any</code>)           \u2013            <p>Object (probably a function) that could be async</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.run","title":"run","text":"<pre><code>run(\n    aw: Coroutine[Any, Any, T],\n    *,\n    debug: bool | None = None,\n    **kwargs: Any,\n) -&gt; T\n</code></pre> <p>Run an async/awaitable function (Polyfill asyncio.run)</p> <p>Emulate <code>asyncio.run()</code> for snakes below python 3.7; <code>asyncio.run</code> was added in python3.7.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code> (              <code>T</code> )          \u2013            <p>Return the result of running the async function</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def add(a, b):\n...     return a + b\n...\n&gt;&gt;&gt; from asyncify.core import run\n&gt;&gt;&gt; run(add(1, 4))\n5\n</code></pre>"},{"location":"libs/asyncify/asyncify.api/#asyncify.run(aw)","title":"<code>aw</code>","text":"(<code>Awaitable[T]</code>)           \u2013            <p>Async/awaitable function to run</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.run(debug)","title":"<code>debug</code>","text":"(<code>Optional[bool]</code>, default:                   <code>None</code> )           \u2013            <p>If True run event loop in debug mode</p>"},{"location":"libs/asyncify/asyncify.api/#asyncify.run(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>keyword arguments to be passed to the wrapped function</p>"},{"location":"libs/fmts/fmts.api/","title":"fmts","text":""},{"location":"libs/fmts/fmts.api/#fmts","title":"fmts","text":"<p>String utils</p> <p>Classes:</p> <ul> <li> <code>HTML</code>           \u2013            <p>HTML formatting utils staticmethod container</p> </li> <li> <code>pstr</code>           \u2013            <p>Pretty-string subclass</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>anystr</code>             \u2013              <p>Convert a given function to accept any string type</p> </li> <li> <code>anystr2anystr</code>             \u2013              <p>Convert a str-to-str function to allow for <code>AnyStr</code></p> </li> <li> <code>b64_html_gif</code>             \u2013              <p>Return a HTML base64 gif image tag</p> </li> <li> <code>b64_html_img</code>             \u2013              <p>Return an img tag given a base64-jpeg-image-string</p> </li> <li> <code>b64_html_jpg</code>             \u2013              <p>Return a HTML base64 jpg image tag</p> </li> <li> <code>b64_html_png</code>             \u2013              <p>Return a HTML base64 png image tag</p> </li> <li> <code>base64_jpg_html</code>             \u2013              <p>Return an img tag given a base64-jpeg-image-string</p> </li> <li> <code>binstr</code>             \u2013              <p>Convert an integer to a binary string</p> </li> <li> <code>body_contents</code>             \u2013              <p>Parse the innertext for body tags in an html string</p> </li> <li> <code>bytes2str</code>             \u2013              <p>Convert bytes to a string</p> </li> <li> <code>camel2kebab</code>             \u2013              <p>Convert a given camelCase string to kebab-case</p> </li> <li> <code>camel2pascal</code>             \u2013              <p>Convert a given camelCase string to PascalCase</p> </li> <li> <code>camel2snake</code>             \u2013              <p>Convert a 'camelCase' string to a 'snake_case' string</p> </li> <li> <code>camel_characters_set</code>             \u2013              <p>Return a set of all the characters that are allowed in camel case</p> </li> <li> <code>carrots</code>             \u2013              <p>Add carrots on a line below given a string</p> </li> <li> <code>dedent</code>             \u2013              <p>Dedent a string</p> </li> <li> <code>dos2unix</code>             \u2013              <p>Replace CRLF line endings with LF line endings for a given string</p> </li> <li> <code>dseconds</code>             \u2013              <p>Format time duration given initial and final timestamps in seconds</p> </li> <li> <code>ensure_trailing_newline</code>             \u2013              <p>Return a string that has only one trailing new line</p> </li> <li> <code>ensure_utf8</code>             \u2013              <p>Return a string that ensured to be utf-8.</p> </li> <li> <code>enum_strings</code>             \u2013              <p>Return a generator with enumerated strings</p> </li> <li> <code>filesize_str</code>             \u2013              <p>Get the human readable filesize string for a file given its path</p> </li> <li> <code>indent</code>             \u2013              <p>Indent a string a given number of spaces</p> </li> <li> <code>is_identifier</code>             \u2013              <p>Return True if a string is a valid python identifier; False otherwise</p> </li> <li> <code>is_snake</code>             \u2013              <p>Check if a given string is snake_case</p> </li> <li> <code>isidentifier</code>             \u2013              <p>Return True if a string is a valid python identifier; False otherwise</p> </li> <li> <code>kebab2camel</code>             \u2013              <p>Convert a given kebab-case string to camelCase</p> </li> <li> <code>kebab2pascal</code>             \u2013              <p>Convert a given kebab-case string to PascalCase</p> </li> <li> <code>kebab2snake</code>             \u2013              <p>Convert a given kebab-case string to snake_case</p> </li> <li> <code>kebab_characters_set</code>             \u2013              <p>Return a set of all the characters that are allowed in camel case</p> </li> <li> <code>long_timestamp_string</code>             \u2013              <p>Return a 'long-form' timestamp string given epoch-seconds float</p> </li> <li> <code>longest_line</code>             \u2013              <p>Return the length of the longest line in a string</p> </li> <li> <code>multi_replace</code>             \u2013              <p>Replace multiple patterns in a string</p> </li> <li> <code>nbytes_str</code>             \u2013              <p>Format nbytesber of bytes to human readable form</p> </li> <li> <code>nseconds</code>             \u2013              <p>Format a number of seconds as a human readable string</p> </li> <li> <code>overscore</code>             \u2013              <p>Add underscores on a line above the given string</p> </li> <li> <code>overscore_carrots</code>             \u2013              <p>Add underscores on a line above a string and carrots on a line below</p> </li> <li> <code>pascal2camel</code>             \u2013              <p>Convert a 'PascalCase' string to a 'camelCase' string</p> </li> <li> <code>pascal2kebab</code>             \u2013              <p>Convert a given PascalCase string to kebab-case</p> </li> <li> <code>pascal2snake</code>             \u2013              <p>Convert a given PascalCase string to snake_case</p> </li> <li> <code>printable_characters_set</code>             \u2013              <p>Return set of all printable characters</p> </li> <li> <code>randhexstr</code>             \u2013              <p>Return a random hex string</p> </li> <li> <code>random_string</code>             \u2013              <p>Return a random ascii string (length=str_len; default=4)</p> </li> <li> <code>rm_b</code>             \u2013              <p>Remove the b'' from binary strings and sub-strings that contain b''</p> </li> <li> <code>rm_character</code>             \u2013              <p>Remove a character in a string globally</p> </li> <li> <code>rm_dunderscore</code>             \u2013              <p>Replace n&gt;=2 underscores with a single underscore</p> </li> <li> <code>rm_multilines</code>             \u2013              <p>Remove blank lines from a string</p> </li> <li> <code>rm_u</code>             \u2013              <p>Remove the u'' from unicode strings and sub-strings that contain u''</p> </li> <li> <code>rm_whitespace</code>             \u2013              <p>Replace n&gt;=2 spaces with a single underscore</p> </li> <li> <code>snake2camel</code>             \u2013              <p>Convert a given snake_case string to camelCase</p> </li> <li> <code>snake2kebab</code>             \u2013              <p>Convert a given snake_case string to kebab-case</p> </li> <li> <code>snake2pascal</code>             \u2013              <p>Convert a given snake_case string to PascalCase</p> </li> <li> <code>space_pad_strings</code>             \u2013              <p>Space pads strings to match the string with the max length</p> </li> <li> <code>string_sanitize</code>             \u2013              <p>Clean up a string</p> </li> <li> <code>strip_ascii</code>             \u2013              <p>Remove all ascii characters from a string</p> </li> <li> <code>strip_comments</code>             \u2013              <p>Remove comments from python/shell scripts given the script as a string</p> </li> <li> <code>strip_non_ascii</code>             \u2013              <p>Remove all ascii characters from a string</p> </li> <li> <code>striterable</code>             \u2013              <p>Yield 'clean' sub-strings from an input string</p> </li> <li> <code>timestamp</code>             \u2013              <p>Time stamp string w/ format yyyymmdd-HHMMSS</p> </li> <li> <code>truncate_string</code>             \u2013              <p>Truncate a string at either a max number of lines or characters</p> </li> <li> <code>udiff</code>             \u2013              <p>Return universal-diff as a string</p> </li> </ul>"},{"location":"libs/fmts/fmts.api/#fmts.HTML","title":"HTML","text":"<p>HTML formatting utils staticmethod container</p> <p>Methods:</p> <ul> <li> <code>html_tag</code>             \u2013              <p>Return an HTML tag with a string as the innerHTML</p> </li> <li> <code>table</code>             \u2013              <p>Return an string surrounded with 'table-HTML' tags</p> </li> <li> <code>tablebody</code>             \u2013              <p>Return an string surrounded with 'tbody-HTML' tags</p> </li> <li> <code>tablehead</code>             \u2013              <p>Return an string surrounded with 'thead-HTML' tags</p> </li> <li> <code>tbody</code>             \u2013              <p>Return an string surrounded with 'tbody-HTML' tags</p> </li> <li> <code>td</code>             \u2013              <p>Return an string surrounded with 'td-HTML' tags</p> </li> <li> <code>th</code>             \u2013              <p>Return an string surrounded with 'th-HTML' tags</p> </li> <li> <code>thead</code>             \u2013              <p>Return an string surrounded with 'thead-HTML' tags</p> </li> <li> <code>tr</code>             \u2013              <p>Return an string surrounded with 'tr-HTML' tags</p> </li> </ul>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.html_tag","title":"html_tag  <code>staticmethod</code>","text":"<pre><code>html_tag(tag_str: str, string: str = '') -&gt; str\n</code></pre> <p>Return an HTML tag with a string as the innerHTML</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.table","title":"table  <code>staticmethod</code>","text":"<pre><code>table(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'table-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.table(\"string\")\n'&lt;table&gt;string&lt;/table&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.table(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tablebody","title":"tablebody  <code>staticmethod</code>","text":"<pre><code>tablebody(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'tbody-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.tablebody(\"string\")\n'&lt;tbody&gt;string&lt;/tbody&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tablebody(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tablehead","title":"tablehead  <code>staticmethod</code>","text":"<pre><code>tablehead(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'thead-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.tablehead(\"string\")\n'&lt;thead&gt;string&lt;/thead&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tablehead(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tbody","title":"tbody  <code>staticmethod</code>","text":"<pre><code>tbody(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'tbody-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.tbody(\"string\")\n'&lt;tbody&gt;string&lt;/tbody&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tbody(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.td","title":"td  <code>staticmethod</code>","text":"<pre><code>td(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'td-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.td(\"string\")\n'&lt;td&gt;string&lt;/td&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.td(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.th","title":"th  <code>staticmethod</code>","text":"<pre><code>th(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'th-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.th(\"string\")\n'&lt;th&gt;string&lt;/th&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.th(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.thead","title":"thead  <code>staticmethod</code>","text":"<pre><code>thead(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'thead-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.thead(\"string\")\n'&lt;thead&gt;string&lt;/thead&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.thead(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tr","title":"tr  <code>staticmethod</code>","text":"<pre><code>tr(string: str) -&gt; str\n</code></pre> <p>Return an string surrounded with 'tr-HTML' tags</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; HTML.tr(\"string\")\n'&lt;tr&gt;string&lt;/tr&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.HTML.tr(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string</p>"},{"location":"libs/fmts/fmts.api/#fmts.pstr","title":"pstr","text":"<p>               Bases: <code>str</code></p> <p>Pretty-string subclass</p>"},{"location":"libs/fmts/fmts.api/#fmts.anystr","title":"anystr","text":"<pre><code>anystr(fn: Callable[[str], _R\" backlink-type=\"used-by\" backlink-anchor=\"fmts.anystr\" optional hover&gt;_R]) -&gt; Callable[[AnyStr], _R]\n</code></pre> <p>Convert a given function to accept any string type</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[[AnyStr], _R]</code>           \u2013            <p>Callable[[AnyStr], R]: function that accepts one arg that is a string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def _is_upper(string: str) -&gt; bool:\n...     return string == string.upper()\n&gt;&gt;&gt; is_upper = anystr(_is_upper)\n&gt;&gt;&gt; is_upper('hello')\nFalse\n&gt;&gt;&gt; is_upper('HELLO')\nTrue\n&gt;&gt;&gt; is_upper(b'hello')\nFalse\n&gt;&gt;&gt; is_upper(b'HELLO')\nTrue\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.anystr(fn)","title":"<code>fn</code>","text":"(<code>Callable[[str], _R]</code>)           \u2013            <p>function to convert</p>"},{"location":"libs/fmts/fmts.api/#fmts.anystr2anystr","title":"anystr2anystr","text":"<pre><code>anystr2anystr(\n    fn: Callable[[str], str],\n) -&gt; Callable[[AnyStr], AnyStr]\n</code></pre> <p>Convert a str-to-str function to allow for <code>AnyStr</code></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[[AnyStr], AnyStr]</code>           \u2013            <p>Callable[[AnyStr], AnyStr]: function that accepts any string type</p> </li> </ul>"},{"location":"libs/fmts/fmts.api/#fmts.anystr2anystr(fn)","title":"<code>fn</code>","text":"(<code>Callable[[str], str]</code>)           \u2013            <p>function to convert</p>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_gif","title":"b64_html_gif","text":"<pre><code>b64_html_gif(b64_string: str) -&gt; str\n</code></pre> <p>Return a HTML base64 gif image tag</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>base64 html image tag</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; b64_html_gif(\"BASE64_STRING\")\n'&lt;img src=\"data:image/gif;base64,BASE64_STRING\"&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_gif(b64_string)","title":"<code>b64_string</code>","text":"(<code>str</code>)           \u2013            <p>Base64 gif image string</p>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_img","title":"b64_html_img","text":"<pre><code>b64_html_img(\n    b64_string: str | bytes, img_format: str\n) -&gt; str\n</code></pre> <p>Return an img tag given a base64-jpeg-image-string</p>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_jpg","title":"b64_html_jpg","text":"<pre><code>b64_html_jpg(b64_string: str) -&gt; str\n</code></pre> <p>Return a HTML base64 jpg image tag</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>base64 html jpg image tag</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; b64_html_jpg(\"BASE64_STRING\")\n'&lt;img src=\"data:image/jpg;base64,BASE64_STRING\"&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_jpg(b64_string)","title":"<code>b64_string</code>","text":"(<code>str</code>)           \u2013            <p>Base64 jpg image string</p>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_png","title":"b64_html_png","text":"<pre><code>b64_html_png(b64_string: str) -&gt; str\n</code></pre> <p>Return a HTML base64 png image tag</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>base64 html image tag</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; b64_html_png(\"BASE64_STRING\")\n'&lt;img src=\"data:image/png;base64,BASE64_STRING\"&gt;'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.b64_html_png(b64_string)","title":"<code>b64_string</code>","text":"(<code>str</code>)           \u2013            <p>Base64 image string</p>"},{"location":"libs/fmts/fmts.api/#fmts.base64_jpg_html","title":"base64_jpg_html","text":"<pre><code>base64_jpg_html(b64_string: str | bytes) -&gt; str\n</code></pre> <p>Return an img tag given a base64-jpeg-image-string</p>"},{"location":"libs/fmts/fmts.api/#fmts.binstr","title":"binstr","text":"<pre><code>binstr(number: int) -&gt; str\n</code></pre> <p>Convert an integer to a binary string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>binary string for the given number</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; binstr(200)\n'11001000'\n&gt;&gt;&gt; binstr(10)\n'1010'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.binstr(number)","title":"<code>number</code>","text":"(<code>int</code>)           \u2013            <p>Number to convert</p>"},{"location":"libs/fmts/fmts.api/#fmts.body_contents","title":"body_contents","text":"<pre><code>body_contents(html_string: str) -&gt; list[str]\n</code></pre> <p>Parse the innertext for body tags in an html string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>list[str]</code> )          \u2013            <p>the inner text for the body tags</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; html_string = '&lt;html&gt;&lt;body&gt;hello&lt;/body&gt;&lt;/html&gt;'\n&gt;&gt;&gt; body_contents(html_string)\n['hello']\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.body_contents(html_string)","title":"<code>html_string</code>","text":"(<code>str</code>)           \u2013            <p>html to parse</p>"},{"location":"libs/fmts/fmts.api/#fmts.bytes2str","title":"bytes2str","text":"<pre><code>bytes2str(bites: bytes, encoding: str = 'utf-8') -&gt; str\n</code></pre> <p>Convert bytes to a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>The bytes as a string</p> </li> </ul>"},{"location":"libs/fmts/fmts.api/#fmts.bytes2str(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>bytes to convert to string</p>"},{"location":"libs/fmts/fmts.api/#fmts.bytes2str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>encoding as a string; defaults to 'utf-8'</p>"},{"location":"libs/fmts/fmts.api/#fmts.camel2kebab","title":"camel2kebab","text":"<pre><code>camel2kebab(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given camelCase string to kebab-case</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel2kebab('camelCase')\n'camel-case'\n&gt;&gt;&gt; camel2kebab(b'camelCase')\nb'camel-case'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.camel2pascal","title":"camel2pascal","text":"<pre><code>camel2pascal(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given camelCase string to PascalCase</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel2pascal('camelCase')\n'CamelCase'\n&gt;&gt;&gt; camel2pascal(b'camelCase')\nb'CamelCase'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.camel2snake","title":"camel2snake","text":"<pre><code>camel2snake(string: str) -&gt; str\n</code></pre> <p>Convert a 'camelCase' string to a 'snake_case' string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>snake_case string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; camel2snake('camelCase')\n'camel_case'\n&gt;&gt;&gt; camel2snake(b'camelCase')\nb'camel_case'\n&gt;&gt;&gt; camel2snake('PascalCase')\n'pascal_case'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.camel2snake(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>a camelCase string</p>"},{"location":"libs/fmts/fmts.api/#fmts.camel_characters_set","title":"camel_characters_set  <code>cached</code>","text":"<pre><code>camel_characters_set() -&gt; set[str]\n</code></pre> <p>Return a set of all the characters that are allowed in camel case</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; CAMEL_CHARACTERS\n'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n&gt;&gt;&gt; camel_characters_set() == {c for c in CAMEL_CHARACTERS}\nTrue\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.carrots","title":"carrots","text":"<pre><code>carrots(string: str) -&gt; str\n</code></pre> <p>Add carrots on a line below given a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>'carrot-ed-scored' string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; carrots(\"A TITLE\")\n'A TITLE\\n^^^^^^^'\n&gt;&gt;&gt; print(carrots(\"A TITLE\"))\nA TITLE\n^^^^^^^\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.carrots(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string to under-carrot</p>"},{"location":"libs/fmts/fmts.api/#fmts.dedent","title":"dedent","text":"<pre><code>dedent(string: str) -&gt; str\n</code></pre> <p>Dedent a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Unindented string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = '    this is a string'\n&gt;&gt;&gt; dedent(s)\n'this is a string'\n&gt;&gt;&gt; s = '        this is a string'\n&gt;&gt;&gt; dedent(s)\n'    this is a string'\n&gt;&gt;&gt; s = \"    this is a string\\n    with 2 lines\"\n&gt;&gt;&gt; print(dedent(s))\nthis is a string\nwith 2 lines\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.dedent(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string to dedent</p>"},{"location":"libs/fmts/fmts.api/#fmts.dos2unix","title":"dos2unix","text":"<pre><code>dos2unix(string: str) -&gt; str\n</code></pre> <p>Replace CRLF line endings with LF line endings for a given string</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dos2unix('hello\\r\\nworld')\n'hello\\nworld'\n&gt;&gt;&gt; type(b'hello\\r\\nworld')\n&lt;class 'bytes'&gt;\n&gt;&gt;&gt; dos2unix(b'hello\\r\\nworld')\nb'hello\\nworld'\n&gt;&gt;&gt; type(dos2unix(b'hello\\r\\nworld'))\n&lt;class 'bytes'&gt;\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.dseconds","title":"dseconds","text":"<pre><code>dseconds(ti: float | int, tf: float | int) -&gt; str\n</code></pre> <p>Format time duration given initial and final timestamps in seconds</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Formatted time duration string readable by humans</p> </li> </ul> <p>Examples:</p> <p>Less than or equal to one second</p> <pre><code>&gt;&gt;&gt; for i in range(0, 10, 2):\n...     (10**-i, dseconds(0, 10**(-i)))\n...\n(1, '1.000 sec')\n(0.01, '10.000 ms')\n(0.0001, '100.000 \u00c3\u017d\u00c2\u00bcs')\n(1e-06, '1.000 \u00c3\u017d\u00c2\u00bcs')\n(1e-08, '10.000 ns')\n</code></pre> <p>Greater than or equal to one second</p> <pre><code>&gt;&gt;&gt; for i in range(0, 5):\n...     (f\"{10**i} seconds\", dseconds(0, 10**i))\n...\n('1 seconds', '1.000 sec')\n('10 seconds', '10.000 sec')\n('100 seconds', '01:40 (mm:ss)')\n('1000 seconds', '16:40 (mm:ss)')\n('10000 seconds', '02:46:40 (hh:mm:ss)')\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.dseconds(ti)","title":"<code>ti</code>","text":"(<code>float | int</code>)           \u2013            <p>Initial time in seconds</p>"},{"location":"libs/fmts/fmts.api/#fmts.dseconds(tf)","title":"<code>tf</code>","text":"(<code>float | int</code>)           \u2013            <p>Final time in seconds</p>"},{"location":"libs/fmts/fmts.api/#fmts.ensure_trailing_newline","title":"ensure_trailing_newline","text":"<pre><code>ensure_trailing_newline(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Return a string that has only one trailing new line</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ensure_trailing_newline(\"foo\")\n'foo\\n'\n&gt;&gt;&gt; ensure_trailing_newline('foo\\n')\n'foo\\n'\n&gt;&gt;&gt; ensure_trailing_newline(\"foo\\n\\n\")\n'foo\\n'\n&gt;&gt;&gt; ensure_trailing_newline(b'foo')\nb'foo\\n'\n&gt;&gt;&gt; ensure_trailing_newline(b'foo\\n')\nb'foo\\n'\n&gt;&gt;&gt; ensure_trailing_newline(b'foo\\n\\n')\nb'foo\\n'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.ensure_utf8","title":"ensure_utf8","text":"<pre><code>ensure_utf8(string: str | bytes) -&gt; str\n</code></pre> <p>Return a string that ensured to be utf-8.</p> <p>This is often needed for those rare cases where some weird non-unicode character or escape sequence is present within a string; This method protects against the possibility of a UnicodeDecodeError.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The unicode-encoded version of a string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ensure_utf8('hello')\n'hello'\n&gt;&gt;&gt; ensure_utf8(b'hello')\n'hello'\n&gt;&gt;&gt; latin_bytes_with_weird_characters = b'hello\\xc3\\xa9'\n&gt;&gt;&gt; latin_string = ensure_utf8(latin_bytes_with_weird_characters)\n&gt;&gt;&gt; latin_string\n'hello\u00e9'\n&gt;&gt;&gt; problem_bytes = b'hello\\\\x00'\n&gt;&gt;&gt; problem_bytes_utf8 = ensure_utf8(problem_bytes)\n&gt;&gt;&gt; problem_bytes_utf8\n'hello\\\\x00'\n&gt;&gt;&gt; ensure_utf8('hello\\\\x00')\n'hello\\\\x00'\n&gt;&gt;&gt; ensure_utf8(b'hello\\\\x00')\n'hello\\\\x00'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.ensure_utf8(string)","title":"<code>string</code>","text":"(<code>str | bytes</code>)           \u2013            <p>A string which you/one would like the unicode version of</p>"},{"location":"libs/fmts/fmts.api/#fmts.enum_strings","title":"enum_strings","text":"<pre><code>enum_strings(\n    strings: list[str], numsep: str = \")\"\n) -&gt; Iterable[str]\n</code></pre> <p>Return a generator with enumerated strings</p> <p>Returns:</p> <ul> <li> <code>Iterable[str]</code>           \u2013            <p>Generator[str]: Generator with enumerated strings</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(enum_strings(list(map(str, range(5)))))\n['1) 0', '2) 1', '3) 2', '4) 3', '5) 4']\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.filesize_str","title":"filesize_str","text":"<pre><code>filesize_str(filepath: str) -&gt; str\n</code></pre> <p>Get the human readable filesize string for a file given its path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Size of the file</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>FileNotFoundError</code>             \u2013            <p>If the given fspath does not exist</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fspath = \"filesize_str.doctest.txt\"\n&gt;&gt;&gt; with open(fspath, \"w\") as f:\n...     f.write(\"dummy file with some stuff\")\n26\n&gt;&gt;&gt; filesize_str(fspath)\n'26.0 bytes'\n&gt;&gt;&gt; from os import remove; remove(fspath)\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.filesize_str(filepath)","title":"<code>filepath</code>","text":"(<code>str</code>)           \u2013            <p>path to file</p>"},{"location":"libs/fmts/fmts.api/#fmts.indent","title":"indent","text":"<pre><code>indent(\n    string: AnyStr,\n    prefix: str = \"    \",\n    predicate: Callable[[str], bool] | None = None,\n) -&gt; AnyStr\n</code></pre> <p>Indent a string a given number of spaces</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AnyStr</code>           \u2013            <p>Indented string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; s = \"this is a string\"\n&gt;&gt;&gt; indent(s)\n'    this is a string'\n&gt;&gt;&gt; s = \"this is a\\nmultiline string\"\n&gt;&gt;&gt; indent(s)\n'    this is a\\n    multiline string'\n&gt;&gt;&gt; print(indent(s))\n    this is a\n    multiline string\n&gt;&gt;&gt; s = \"this is a\\nmultiline string\"\n&gt;&gt;&gt; print(indent(s, '  '))\n  this is a\n  multiline string\n&gt;&gt;&gt; indent(b'this is a string')\nb'    this is a string'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.indent(string)","title":"<code>string</code>","text":"(<code>AnyStr</code>)           \u2013            <p>string to indent</p>"},{"location":"libs/fmts/fmts.api/#fmts.indent(prefix)","title":"<code>prefix</code>","text":"(<code>str</code>, default:                   <code>'    '</code> )           \u2013            <p>prefix to use for indentation; defaults to 4 spaces</p>"},{"location":"libs/fmts/fmts.api/#fmts.indent(predicate)","title":"<code>predicate</code>","text":"(<code>Callable[[str], bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional predicate to determine whether to indent a line;</p>"},{"location":"libs/fmts/fmts.api/#fmts.is_dunder","title":"is_dunder","text":"<pre><code>is_dunder(string: str) -&gt; bool\n</code></pre> <p>Return True if a string is 'dunder' (starts and ends with '__')</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if is a dunder</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_dunder(\"__dunder__\")\nTrue\n&gt;&gt;&gt; is_dunder(\"not_dunder\")\nFalse\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.is_dunder(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to check</p>"},{"location":"libs/fmts/fmts.api/#fmts.is_identifier","title":"is_identifier","text":"<pre><code>is_identifier(string: str) -&gt; bool\n</code></pre> <p>Return True if a string is a valid python identifier; False otherwise</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if is an identifier</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_identifier(\"herm\")\nTrue\n&gt;&gt;&gt; is_identifier(\"something that contains spaces\")\nFalse\n&gt;&gt;&gt; is_identifier(\"import\")\nFalse\n&gt;&gt;&gt; is_identifier(\"something.with.periods\")\nFalse\n&gt;&gt;&gt; is_identifier(\"astring-with-dashes\")\nFalse\n&gt;&gt;&gt; is_identifier(\"astring_with_underscores\")\nTrue\n&gt;&gt;&gt; is_identifier(b\"astring_with_underscores\")\nTrue\n&gt;&gt;&gt; is_identifier(123)\nFalse\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.is_identifier(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String (likely to be used as a key) to check</p>"},{"location":"libs/fmts/fmts.api/#fmts.is_snake","title":"is_snake","text":"<pre><code>is_snake(string: AnyStr) -&gt; bool\n</code></pre> <p>Check if a given string is snake_case</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if the string is snake_case, False otherwise</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_snake('snake_case')\nTrue\n&gt;&gt;&gt; is_snake('kebab-case')\nFalse\n&gt;&gt;&gt; is_snake(b'snake_case')\nTrue\n&gt;&gt;&gt; is_snake(b'kebab-case')\nFalse\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.is_snake(string)","title":"<code>string</code>","text":"(<code>AnyStr</code>)           \u2013            <p>string to check</p>"},{"location":"libs/fmts/fmts.api/#fmts.isidentifier","title":"isidentifier","text":"<pre><code>isidentifier(string: AnyStr) -&gt; bool\n</code></pre> <p>Return True if a string is a valid python identifier; False otherwise</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if is an identifier</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; isidentifier(\"herm\")\nTrue\n&gt;&gt;&gt; isidentifier(\"something that contains spaces\")\nFalse\n&gt;&gt;&gt; isidentifier(\"import\")\nFalse\n&gt;&gt;&gt; isidentifier(\"something.with.periods\")\nFalse\n&gt;&gt;&gt; isidentifier(\"astring-with-dashes\")\nFalse\n&gt;&gt;&gt; isidentifier(\"astring_with_underscores\")\nTrue\n&gt;&gt;&gt; isidentifier(123)\nFalse\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.isidentifier(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String (likely to be used as a key) to check</p>"},{"location":"libs/fmts/fmts.api/#fmts.kebab2camel","title":"kebab2camel","text":"<pre><code>kebab2camel(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given kebab-case string to camelCase</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kebab2camel('kebab-case')\n'kebabCase'\n&gt;&gt;&gt; kebab2camel(b'kebab-case')\nb'kebabCase'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.kebab2pascal","title":"kebab2pascal","text":"<pre><code>kebab2pascal(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given kebab-case string to PascalCase</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kebab2pascal('kebab-case')\n'KebabCase'\n&gt;&gt;&gt; kebab2pascal(b'kebab-case')\nb'KebabCase'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.kebab2snake","title":"kebab2snake","text":"<pre><code>kebab2snake(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given kebab-case string to snake_case</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kebab2snake('kebab-case')\n'kebab_case'\n&gt;&gt;&gt; kebab2snake(b'kebab-case')\nb'kebab_case'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.kebab2snake(string)","title":"<code>string</code>","text":"(<code>AnyStr</code>)           \u2013            <p>kebab case string</p>"},{"location":"libs/fmts/fmts.api/#fmts.kebab_characters_set","title":"kebab_characters_set  <code>cached</code>","text":"<pre><code>kebab_characters_set() -&gt; set[str]\n</code></pre> <p>Return a set of all the characters that are allowed in camel case</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; KEBAB_CHARACTERS\n'abcdefghijklmnopqrstuvwxyz0123456789-'\n&gt;&gt;&gt; kebab_characters_set() == {c for c in KEBAB_CHARACTERS}\nTrue\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.long_timestamp_string","title":"long_timestamp_string","text":"<pre><code>long_timestamp_string(timestamp_sec: float) -&gt; str\n</code></pre> <p>Return a 'long-form' timestamp string given epoch-seconds float</p>"},{"location":"libs/fmts/fmts.api/#fmts.longest_line","title":"longest_line","text":"<pre><code>longest_line(string: str | bytes) -&gt; int\n</code></pre> <p>Return the length of the longest line in a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The length of the longest line in the string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; longest_line('hello\\nworld')\n5\n&gt;&gt;&gt; longest_line(b'hello\\nworld')\n5\n&gt;&gt;&gt; longest_line('hello world')\n11\n&gt;&gt;&gt; longest_line(b'hello world')\n11\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.longest_line(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String that has either one or more lines</p>"},{"location":"libs/fmts/fmts.api/#fmts.multi_replace","title":"multi_replace","text":"<pre><code>multi_replace(\n    string: str,\n    replacements: list[tuple[str, str]]\n    | list[list[str]]\n    | dict[str, str]\n    | ItemsView[str, str],\n) -&gt; str\n</code></pre> <p>Replace multiple patterns in a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Input string with all the replacements applied in order</p> </li> </ul> <p>Examples:</p> <p>Works with a list of lists!</p> <pre><code>&gt;&gt;&gt; replacements = [['hello', 'goodbye'], ['world', 'earth']]\n&gt;&gt;&gt; multi_replace('hello, world', replacements)\n'goodbye, earth'\n</code></pre> <p>Works with a list of tuples!</p> <pre><code>&gt;&gt;&gt; replacements = [('hello', 'goodbye'), ('world', 'earth')]\n&gt;&gt;&gt; multi_replace('hello, world', replacements)\n'goodbye, earth'\n</code></pre> <p>Works with a dictionary where all keys and values are strings!</p> <pre><code>&gt;&gt;&gt; replacements = {'hello': 'goodbye', 'world': 'earth'}\n&gt;&gt;&gt; multi_replace('hello, world', replacements)\n'goodbye, earth'\n</code></pre> <pre><code>&gt;&gt;&gt; replacements = [['hello', 'goodbye'], ['world', 'this', 'will', 'fail']]\n&gt;&gt;&gt; try:\n...     multi_replace('hello, world', replacements)\n... except ValueError:\n...     print('ValueError raised')\nValueError raised\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.multi_replace(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Strint to apply</p>"},{"location":"libs/fmts/fmts.api/#fmts.multi_replace(replacements)","title":"<code>replacements</code>","text":"(<code>list[tuple[str, str]] | list[list[str]] | dict[str, str] | ItemsView[str, str]</code>)           \u2013            <p>Replacement combos</p>"},{"location":"libs/fmts/fmts.api/#fmts.nbytes","title":"nbytes","text":"<pre><code>nbytes(nbytes: int | float) -&gt; str\n</code></pre> <p>Alias for nbytes_str (for backward compatibility)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nbytes(100)\n'100.0 bytes'\n&gt;&gt;&gt; nbytes(1000)\n'1000.0 bytes'\n&gt;&gt;&gt; nbytes(10000)\n'9.8 KB'\n&gt;&gt;&gt; nbytes(100000)\n'97.7 KB'\n&gt;&gt;&gt; nbytes(1000000)\n'976.6 KB'\n&gt;&gt;&gt; nbytes(10_000_000)\n'9.5 MB'\n&gt;&gt;&gt; nbytes(100_000_000)\n'95.4 MB'\n&gt;&gt;&gt; nbytes(1000000000)\n'953.7 MB'\n&gt;&gt;&gt; nbytes(10000000000)\n'9.3 GB'\n&gt;&gt;&gt; nbytes(100000000000)\n'93.1 GB'\n&gt;&gt;&gt; nbytes(1000000000000)\n'931.3 GB'\n&gt;&gt;&gt; nbytes(10000000000000)\n'9.1 TB'\n&gt;&gt;&gt; nbytes(100000000000000)\n'90.9 TB'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.nbytes_str","title":"nbytes_str","text":"<pre><code>nbytes_str(nbytes: int | float) -&gt; str\n</code></pre> <p>Format nbytesber of bytes to human readable form</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>nbytesber of bytes formatted</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If given number of bytes is invalid/negative</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nbytes_str(100)\n'100.0 bytes'\n&gt;&gt;&gt; nbytes_str(1000)\n'1000.0 bytes'\n&gt;&gt;&gt; nbytes_str(10000)\n'9.8 KB'\n&gt;&gt;&gt; nbytes_str(100000)\n'97.7 KB'\n&gt;&gt;&gt; nbytes_str(1000000)\n'976.6 KB'\n&gt;&gt;&gt; nbytes_str(10_000_000)\n'9.5 MB'\n&gt;&gt;&gt; nbytes_str(100_000_000)\n'95.4 MB'\n&gt;&gt;&gt; nbytes_str(1000000000)\n'953.7 MB'\n&gt;&gt;&gt; nbytes_str(10000000000)\n'9.3 GB'\n&gt;&gt;&gt; nbytes_str(100000000000)\n'93.1 GB'\n&gt;&gt;&gt; nbytes_str(1000000000000)\n'931.3 GB'\n&gt;&gt;&gt; nbytes_str(10000000000000)\n'9.1 TB'\n&gt;&gt;&gt; nbytes_str(100000000000000)\n'90.9 TB'\n&gt;&gt;&gt; nbytes_str(-100000000000)\n'-93.1 GB'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.nbytes_str(nbytes)","title":"<code>nbytes</code>","text":"(<code>int | float</code>)           \u2013            <p>number of bytes</p>"},{"location":"libs/fmts/fmts.api/#fmts.nseconds","title":"nseconds","text":"<pre><code>nseconds(nsec: float) -&gt; str\n</code></pre> <p>Format a number of seconds as a human readable string</p> <p>Formats nsec if t2 is None as a string; Calculates the time and formats the time t2-nsec if t2 is not None.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Formatted time duration string readable by humans</p> </li> </ul> <p>Examples:</p> <p>Less than or equal to one second</p> <pre><code>&gt;&gt;&gt; for i in range(0, 10, 2):\n...     (10**-i, nseconds(10**(-i)))\n...\n(1, '1.000 sec')\n(0.01, '10.000 ms')\n(0.0001, '100.000 \u00c3\u017d\u00c2\u00bcs')\n(1e-06, '1.000 \u00c3\u017d\u00c2\u00bcs')\n(1e-08, '10.000 ns')\n</code></pre> <p>Greater than or equal to one second</p> <pre><code>&gt;&gt;&gt; for i in range(0, 5):\n...     (f\"{10**i} seconds\", nseconds(10**i))\n...\n('1 seconds', '1.000 sec')\n('10 seconds', '10.000 sec')\n('100 seconds', '01:40 (mm:ss)')\n('1000 seconds', '16:40 (mm:ss)')\n('10000 seconds', '02:46:40 (hh:mm:ss)')\n&gt;&gt;&gt; nseconds(-60)\n'01:00 (mm:ss)'\n&gt;&gt;&gt; nseconds(60)\n'01:00 (mm:ss)'\n&gt;&gt;&gt; nseconds(0)\n'0 sec'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.nseconds(nsec)","title":"<code>nsec</code>","text":"(<code>float</code>)           \u2013            <p>Timestamp epoch seconds</p>"},{"location":"libs/fmts/fmts.api/#fmts.overscore","title":"overscore","text":"<pre><code>overscore(string: str) -&gt; str\n</code></pre> <p>Add underscores on a line above the given string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>'Over-scored' string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; overscore(\"A TITLE\")\n'_______\\nA TITLE'\n&gt;&gt;&gt; print(overscore(\"A TITLE\"))\n_______\nA TITLE\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.overscore(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string to overscore</p>"},{"location":"libs/fmts/fmts.api/#fmts.overscore_carrots","title":"overscore_carrots","text":"<pre><code>overscore_carrots(string: str) -&gt; str\n</code></pre> <p>Add underscores on a line above a string and carrots on a line below</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>'Over-scored' and carroted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; overscore_carrots(\"A TITLE\")\n'_______\\nA TITLE\\n^^^^^^^'\n&gt;&gt;&gt; print(overscore_carrots(\"A TITLE\"))\n_______\nA TITLE\n^^^^^^^\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.overscore_carrots(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>Input string to overscore and carrot</p>"},{"location":"libs/fmts/fmts.api/#fmts.pascal2camel","title":"pascal2camel","text":"<pre><code>pascal2camel(string: str) -&gt; str\n</code></pre> <p>Convert a 'PascalCase' string to a 'camelCase' string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>camelCase string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pascal2camel('PascalCase')\n'pascalCase'\n&gt;&gt;&gt; pascal2camel(b'PascalCase')\nb'pascalCase'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.pascal2camel(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>a PascalCase string</p>"},{"location":"libs/fmts/fmts.api/#fmts.pascal2kebab","title":"pascal2kebab","text":"<pre><code>pascal2kebab(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given PascalCase string to kebab-case</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pascal2kebab('PascalCase')\n'pascal-case'\n&gt;&gt;&gt; pascal2kebab(b'PascalCase')\nb'pascal-case'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.pascal2snake","title":"pascal2snake","text":"<pre><code>pascal2snake(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given PascalCase string to snake_case</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pascal2snake('PascalCase')\n'pascal_case'\n&gt;&gt;&gt; pascal2snake(b'PascalCase')\nb'pascal_case'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.printable_characters_set","title":"printable_characters_set  <code>cached</code>","text":"<pre><code>printable_characters_set() -&gt; set[str]\n</code></pre> <p>Return set of all printable characters</p> <p>Returns:</p> <ul> <li> <code>set[str]</code>           \u2013            <p>set[str]: set of all printable characters</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; printable_characters_set() == {c for c in printable}\nTrue\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.randhexstr","title":"randhexstr","text":"<pre><code>randhexstr(length: int = 8) -&gt; str\n</code></pre> <p>Return a random hex string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>random hex string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = randhexstr()\n&gt;&gt;&gt; isinstance(a, str)\nTrue\n&gt;&gt;&gt; len(a)\n8\n&gt;&gt;&gt; b = randhexstr(10)\n&gt;&gt;&gt; isinstance(b, str)\nTrue\n&gt;&gt;&gt; len(b)\n10\n&gt;&gt;&gt; randhexstr(0)\nTraceback (most recent call last):\n    ...\nValueError: length must be a positive even number\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.randhexstr(length)","title":"<code>length</code>","text":"(<code>int</code>, default:                   <code>8</code> )           \u2013            <p>length of desired random string (defaults to 4)</p>"},{"location":"libs/fmts/fmts.api/#fmts.random_string","title":"random_string","text":"<pre><code>random_string(length: int = 8, *, hex: bool = False) -&gt; str\n</code></pre> <p>Return a random ascii string (length=str_len; default=4)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = random_string()\n&gt;&gt;&gt; isinstance(a, str)\nTrue\n&gt;&gt;&gt; len(a)\n8\n&gt;&gt;&gt; a = random_string(12)\n&gt;&gt;&gt; isinstance(a, str)\nTrue\n&gt;&gt;&gt; len(a)\n12\n&gt;&gt;&gt; a = random_string(8, hex=True)\n&gt;&gt;&gt; isinstance(a, str)\nTrue\n&gt;&gt;&gt; len(a)\n8\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.rm_b","title":"rm_b","text":"<pre><code>rm_b(string: str) -&gt; str\n</code></pre> <p>Remove the b'' from binary strings and sub-strings that contain b''</p> <p>Taken from 'pupy' (Pretty Useful Python (which jesse wrote))</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string without binary b'' quotes surround it</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rm_b(\"b'a_string'\")\n'a_string'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.rm_b(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>A string surrounded by b'' or a sub-string with b''</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_character","title":"rm_character","text":"<pre><code>rm_character(\n    string: str, split_str: str, join_str: str\n) -&gt; str\n</code></pre> <p>Remove a character in a string globally</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String with the character/string given by split_str removed</p> </li> </ul>"},{"location":"libs/fmts/fmts.api/#fmts.rm_character(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to remove characters from</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_character(split_str)","title":"<code>split_str</code>","text":"(<code>str</code>)           \u2013            <p>character to remove</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_character(join_str)","title":"<code>join_str</code>","text":"(<code>str</code>)           \u2013            <p>character to join the split-string on</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_dunderscore","title":"rm_dunderscore","text":"<pre><code>rm_dunderscore(string: str) -&gt; str\n</code></pre> <p>Replace n&gt;=2 underscores with a single underscore</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String with no adjacent underscores</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rm_dunderscore('there____are___many____double_______underscores')\n'there_are_many_double_underscores'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.rm_dunderscore(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to remove double underscores from</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_multilines","title":"rm_multilines","text":"<pre><code>rm_multilines(string: str) -&gt; str\n</code></pre> <p>Remove blank lines from a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>string without blank lines</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rm_multilines('hello\\n\\nworld')\n'hello\\nworld'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.rm_multilines(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string possibly containing blank lines</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_u","title":"rm_u","text":"<pre><code>rm_u(string: str) -&gt; str\n</code></pre> <p>Remove the u'' from unicode strings and sub-strings that contain u''</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>A string without unicode u'' quotes surround it</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = \"u'a_string'\"\n&gt;&gt;&gt; rm_u(a)\n'a_string'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.rm_u(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>A string surrounded by u'' or a sub-string with u''</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_whitespace","title":"rm_whitespace","text":"<pre><code>rm_whitespace(string: str, join_str: str = ' ') -&gt; str\n</code></pre> <p>Replace n&gt;=2 spaces with a single underscore</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String with no spaces and underscores where there were spaces</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rm_whitespace('there are lots of    spaces')\n'there are lots of spaces'\n&gt;&gt;&gt; rm_whitespace('there are lots of    spaces', join_str='_')\n'there_are_lots_of_spaces'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.rm_whitespace(join_str)","title":"<code>join_str</code>","text":"(<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>String to join on; defaults to a space (' ')</p>"},{"location":"libs/fmts/fmts.api/#fmts.rm_whitespace(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to remove spaces from</p>"},{"location":"libs/fmts/fmts.api/#fmts.snake2camel","title":"snake2camel","text":"<pre><code>snake2camel(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given snake_case string to camelCase</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snake2camel('camel_case')\n'camelCase'\n&gt;&gt;&gt; snake2camel(b'camel_case')\nb'camelCase'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.snake2camel(string)","title":"<code>string</code>","text":"(<code>AnyStr</code>)           \u2013            <p>snake case string</p>"},{"location":"libs/fmts/fmts.api/#fmts.snake2kebab","title":"snake2kebab","text":"<pre><code>snake2kebab(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given snake_case string to kebab-case</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snake2kebab('kebab_case')\n'kebab-case'\n&gt;&gt;&gt; snake2kebab(b'kebab_case')\nb'kebab-case'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.snake2kebab(string)","title":"<code>string</code>","text":"(<code>AnyStr</code>)           \u2013            <p>snake case string</p>"},{"location":"libs/fmts/fmts.api/#fmts.snake2pascal","title":"snake2pascal","text":"<pre><code>snake2pascal(string: AnyStr) -&gt; AnyStr\n</code></pre> <p>Convert a given snake_case string to PascalCase</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>AnyStr</code>           \u2013            <p>PascalCase string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; snake2pascal('pascal_case')\n'PascalCase'\n&gt;&gt;&gt; snake2pascal(b'pascal_case')\nb'PascalCase'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.snake2pascal(string)","title":"<code>string</code>","text":"(<code>AnyStr</code>)           \u2013            <p>snake case string</p>"},{"location":"libs/fmts/fmts.api/#fmts.space_pad_strings","title":"space_pad_strings","text":"<pre><code>space_pad_strings(\n    strings: list[str], justify: str = \"left\"\n) -&gt; list[str]\n</code></pre> <p>Space pads strings to match the string with the max length</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of space-padded strings</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; space_pad_strings([\"a\", \"bb\", \"ccc\"])\n['a  ', 'bb ', 'ccc']\n&gt;&gt;&gt; space_pad_strings([\"a\", \"bb\", \"ccc\"], justify='right')\n['  a', ' bb', 'ccc']\n&gt;&gt;&gt; space_pad_strings([\"a\", \"bb\", \"ccc\"], justify='center')\nTraceback (most recent call last):\n...\nValueError: justify must be 'left' or 'right', not center; case-insensitive\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.str_is_identifier","title":"str_is_identifier","text":"<pre><code>str_is_identifier(string: str) -&gt; bool\n</code></pre> <p>Return True if a string is a valid python identifier; False otherwise</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if is an identifier</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; str_is_identifier(\"howdy\")\nTrue\n&gt;&gt;&gt; str_is_identifier(\"class\")\nFalse\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.str_is_identifier(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String (likely to be used as a key) to check</p>"},{"location":"libs/fmts/fmts.api/#fmts.string_sanitize","title":"string_sanitize","text":"<pre><code>string_sanitize(string: str) -&gt; str\n</code></pre> <p>Clean up a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>input string sanitized</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; string_sanitize('5/9999((5')\n'599995'\n&gt;&gt;&gt; string_sanitize('question????,')\n'question'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.string_sanitize(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to sanitize</p>"},{"location":"libs/fmts/fmts.api/#fmts.strip_ascii","title":"strip_ascii","text":"<pre><code>strip_ascii(string: str) -&gt; str\n</code></pre> <p>Remove all ascii characters from a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>string of only the non-ascii characters</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; string_w_non_ascii_chars = 'Three fourths: \u00be'\n&gt;&gt;&gt; strip_ascii(string_w_non_ascii_chars)\n'\u00be'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.strip_ascii(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string with non-ascii characters</p>"},{"location":"libs/fmts/fmts.api/#fmts.strip_comments","title":"strip_comments","text":"<pre><code>strip_comments(string: str) -&gt; str\n</code></pre> <p>Remove comments from python/shell scripts given the script as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>input string with comments striped out</p> </li> </ul> <p>Examples:</p> <p>Here is an example of stripping comments from a python-ish script:</p> <pre><code>&gt;&gt;&gt; python_script_ish = r'''# some encoding\n... # this is a comment\n... # this is another comment\n... print('hello bob')\n... print('hello bobert')  # bob is short for bobert\n... '''\n&gt;&gt;&gt; a = strip_comments(python_script_ish)\n&gt;&gt;&gt; a.splitlines(keepends=False)\n['', '', '', \"print('hello bob')\", \"print('hello bobert')  \"]\n</code></pre> <p>Here is an example of stripping comments from a bash/shell-ish script:</p> <pre><code>&gt;&gt;&gt; bash_script_ish = r'''#!/bin/bash\n... # this is a comment\n... # this is another comment\n... echo \"hello\"\n... echo \"hello again\" # comment\n... '''\n&gt;&gt;&gt; a = strip_comments(bash_script_ish)\n&gt;&gt;&gt; a.splitlines(keepends=False)\n['', '', '', 'echo \"hello\"', 'echo \"hello again\" ']\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.strip_comments(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string with <code>#</code> comments</p>"},{"location":"libs/fmts/fmts.api/#fmts.strip_non_ascii","title":"strip_non_ascii","text":"<pre><code>strip_non_ascii(s: str) -&gt; str\n</code></pre> <p>Remove all ascii characters from a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>string of only the non-ascii characters</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; string_w_non_ascii_chars = 'Three fourths: \u00be'\n&gt;&gt;&gt; strip_non_ascii(string_w_non_ascii_chars)\n'Three fourths: '\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.strip_non_ascii(s)","title":"<code>s</code>","text":"(<code>str</code>)           \u2013            <p>string with non-ascii characters</p>"},{"location":"libs/fmts/fmts.api/#fmts.striterable","title":"striterable","text":"<pre><code>striterable(string: str) -&gt; Iterable[str]\n</code></pre> <p>Yield 'clean' sub-strings from an input string</p> <p>This method takes a string (like the string that would be a dat file) and yields strings from that string separated by some delimiter.</p> Delimiters <ul> <li> <li> <li> (unix AND dos!) <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>Iterable[str]</code>           \u2013            <p>Filter/generator of 'clean' strings for comparison</p> </li> </ul> <p>Examples:</p> <p>Simple spaces example:</p> <pre><code>&gt;&gt;&gt; string_w_spaces = 'this is a string with spaces'\n&gt;&gt;&gt; list(striterable(string_w_spaces))\n['this', 'is', 'a', 'string', 'with', 'spaces']\n</code></pre> <p>Leading and trailing spaces example:</p> <pre><code>&gt;&gt;&gt; string_w_spaces = '     this is a string with spaces     '\n&gt;&gt;&gt; list(striterable(string_w_spaces))\n['this', 'is', 'a', 'string', 'with', 'spaces']\n</code></pre> <p>Tabs example:</p> <pre><code>&gt;&gt;&gt; strings = ['string', 'separated', 'by', 'tabs']\n&gt;&gt;&gt; tab_separated = '\\t'.join(strings)\n&gt;&gt;&gt; list(striterable(tab_separated))\n['string', 'separated', 'by', 'tabs']\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.striterable(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be turned into a striterable</p>"},{"location":"libs/fmts/fmts.api/#fmts.t9","title":"t9","text":"<pre><code>t9(string: str) -&gt; int\n</code></pre> <p>Convert a string to a number using ye olde T9</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>T9 integer</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t9(\"Hello World\")\n43556096753\n&gt;&gt;&gt; t9(\"dgpy\")\n3479\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.t9(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to convert to T9 integer</p>"},{"location":"libs/fmts/fmts.api/#fmts.t9_str","title":"t9_str","text":"<pre><code>t9_str(string: str) -&gt; str\n</code></pre> <p>Convert a string to a number using ye olde T9</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>T9 integer as a string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t9_str(\"Hello World\")\n'43556096753'\n&gt;&gt;&gt; t9_str(\"dgpy\")\n'3479'\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.t9_str(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to convert to T9 integer</p>"},{"location":"libs/fmts/fmts.api/#fmts.timestamp","title":"timestamp","text":"<pre><code>timestamp(ts: float | datetime | None = None) -&gt; str\n</code></pre> <p>Time stamp string w/ format yyyymmdd-HHMMSS</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>timestamp string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; stamps = ['20190225-161151', '20190225-081151']\n&gt;&gt;&gt; timestamp(1551111111.111111) in stamps\nTrue\n&gt;&gt;&gt; datetime.now().strftime(\"%Y%m%d-%H%M%S\") == timestamp()\nTrue\n&gt;&gt;&gt; timestamp(datetime.now()) == timestamp()\nTrue\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.timestamp(ts)","title":"<code>ts</code>","text":"(<code>float | datetime | None</code>, default:                   <code>None</code> )           \u2013            <p>datetime or float</p>"},{"location":"libs/fmts/fmts.api/#fmts.truncate_string","title":"truncate_string","text":"<pre><code>truncate_string(\n    string: str,\n    maxlines: int = 120,\n    max_characters: int = 4096,\n) -&gt; str\n</code></pre> <p>Truncate a string at either a max number of lines or characters</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Truncated string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; truncate_string('a')\n'a'\n&gt;&gt;&gt; print(truncate_string('a\\n' * 10, maxlines=5))\na\na\na\na\na\n---------------------------\n... Truncated @ 5 lines...\n---------------------------\n</code></pre>"},{"location":"libs/fmts/fmts.api/#fmts.truncate_string(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to truncate</p>"},{"location":"libs/fmts/fmts.api/#fmts.truncate_string(maxlines)","title":"<code>maxlines</code>","text":"(<code>int</code>, default:                   <code>120</code> )           \u2013            <p>Max number of lines the truncated string can have; default is 120</p>"},{"location":"libs/fmts/fmts.api/#fmts.truncate_string(max_characters)","title":"<code>max_characters</code>","text":"(<code>int</code>, default:                   <code>4096</code> )           \u2013            <p>Max number of characters the string can have; default is 4096</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff","title":"udiff","text":"<pre><code>udiff(\n    a_lines: Sequence[str],\n    b_lines: Sequence[str],\n    fromfile: str = \"A\",\n    tofile: str = \"B\",\n    n: int = 0,\n    maxlines: int = 120,\n    max_characters: int = 4096,\n) -&gt; str\n</code></pre> <p>Return universal-diff as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>universal diff string that is truncated if too long</p> </li> </ul>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(a_lines)","title":"<code>a_lines</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>First set of lines as strings</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(b_lines)","title":"<code>b_lines</code>","text":"(<code>Sequence[str]</code>)           \u2013            <p>Second set of lines as strings</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(fromfile)","title":"<code>fromfile</code>","text":"(<code>str</code>, default:                   <code>'A'</code> )           \u2013            <p>Name or label of the first file/lines (Default = 'A')</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(tofile)","title":"<code>tofile</code>","text":"(<code>str</code>, default:                   <code>'B'</code> )           \u2013            <p>Name or label of the second file/lines (Default = 'B')</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(n)","title":"<code>n</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of context lines to give in diff (Default = 0)</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(maxlines)","title":"<code>maxlines</code>","text":"(<code>int</code>, default:                   <code>120</code> )           \u2013            <p>Number of diff lines to truncate at (Default = 120)</p>"},{"location":"libs/fmts/fmts.api/#fmts.udiff(max_characters)","title":"<code>max_characters</code>","text":"(<code>int</code>, default:                   <code>4096</code> )           \u2013            <p>Number of characters to truncate at (Default = 4096)</p>"},{"location":"libs/funkify/","title":"funkify","text":""},{"location":"libs/funkify/#funkify","title":"funkify\u00b6","text":"<p>Install: <code>pip install funkify</code></p> <p>Make a module/package/script callable.</p>"},{"location":"libs/funkify/#usage","title":"Usage:\u00b6","text":""},{"location":"libs/funkify/#1-write-a-file-called-a_modulepy-with-some-function-and-decorate-said-function-with-funkify","title":"1) Write a file called <code>a_module.py</code> with some function and decorate said function with funkify\u00b6","text":"<pre>import funkify\n\n@funkify\ndef some_funk_name_doesnt_matter():\n\treturn 'howdy'\n</pre>"},{"location":"libs/funkify/#2-import-a_module-and-call-it-like-you-would-a-function","title":"2) Import a_module and call it like you would a function!\u00b6","text":"<pre>import a_module\na_module.some_funk_name_doesnt_matter_what_it_is()  # returns 'howdy'\na_module()  # ALSO returns 'howdy'\n</pre>"},{"location":"libs/funkify/funkify.api/","title":"funkify","text":""},{"location":"libs/funkify/funkify.api/#funkify","title":"funkify","text":"<p><code>funkify</code> ~ make modules callable</p> <p>Functions:</p> <ul> <li> <code>default_export</code>             \u2013              <p>Assign a function to a module's call attr</p> </li> <li> <code>funkify</code>             \u2013              <p>Assign a function to a module's call attr</p> </li> </ul>"},{"location":"libs/funkify/funkify.api/#funkify.default_export","title":"default_export","text":"<pre><code>default_export(funk: T, *, key: str | None = None) -&gt; T\n</code></pre> <p>Assign a function to a module's call attr</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>T</code>           \u2013            <p>Callable[..., T]: the function passed in</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>AttributeError</code>             \u2013            <p>if key is None and exported obj no module attr</p> </li> <li> <code>ValueError</code>             \u2013            <p>if key is not in sys.modules</p> </li> </ul>"},{"location":"libs/funkify/funkify.api/#funkify.default_export(funk)","title":"<code>funk</code>","text":"(<code>T</code>)           \u2013            <p>function to be made callable</p>"},{"location":"libs/funkify/funkify.api/#funkify.default_export(key)","title":"<code>key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>module name as it would appear in sys.modules</p>"},{"location":"libs/funkify/funkify.api/#funkify.funkify","title":"funkify","text":"<pre><code>funkify(\n    funk: Callable[..., T], *, key: str | None = None\n) -&gt; Callable[..., T]\n</code></pre> <p>Assign a function to a module's call attr</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[..., T]</code>           \u2013            <p>Callable[..., T]: the function passed in</p> </li> </ul>"},{"location":"libs/funkify/funkify.api/#funkify.funkify(funk)","title":"<code>funk</code>","text":"(<code>Callable[..., T]</code>)           \u2013            <p>function to be made callable</p>"},{"location":"libs/funkify/funkify.api/#funkify.funkify(key)","title":"<code>key</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>module name as it would appear in sys.modules</p>"},{"location":"libs/h5/","title":"h5","text":""},{"location":"libs/h5/#h5","title":"h5\u00b6","text":"<p>Install: <code>pip install h5</code></p> <p>Util functions for h5py and home of recursive generators!</p>"},{"location":"libs/h5/h5.api/","title":"h5","text":""},{"location":"libs/h5/h5.api/#h5","title":"h5","text":"<p>HDF5 functions, and utils, and generators, OH MY!</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>h5.cli</p> </li> <li> <code>core</code>           \u2013            <p>HDF5 functions, and utils, and generators, OH MY!</p> </li> <li> <code>dev</code>           \u2013            <p>h5.dev ~ Under construction!</p> </li> <li> <code>legacy</code>           \u2013            <p>Legacy; to be deprecated</p> </li> <li> <code>testing</code>           \u2013            </li> </ul> <p>Classes:</p> <ul> <li> <code>FileInfo</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>as_h5py_obj</code>             \u2013              <p>Convert a path or h5py object to an h5py object</p> </li> <li> <code>attrs</code>             \u2013              <p>Return a generator that yields tuples with: (HDF5-path, HDF5-attr)</p> </li> <li> <code>attrs_dict</code>             \u2013              <p>Load an HDF5 file from a fspath into a dictionary</p> </li> <li> <code>attrs_gen</code>             \u2013              <p>Return a generator that yields tuples with: (HDF5-path, HDF5-attr)</p> </li> <li> <code>attrs_gen_from_fspath</code>             \u2013              <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> </li> <li> <code>datasets</code>             \u2013              <p>Return a generator that yields tuples with: (HDF5-path, Dataset)</p> </li> <li> <code>datasets_dict</code>             \u2013              <p>Load an HDF5 file from a fspath into a dictionary</p> </li> <li> <code>datasets_gen</code>             \u2013              <p>Return a generator that yields tuples with: (HDF5-path, Dataset)</p> </li> <li> <code>datasets_gen_from_fspath</code>             \u2013              <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> </li> <li> <code>datasets_keys_list</code>             \u2013              <p>Return a list of all keys/paths for an h5py object.</p> </li> <li> <code>fmt_h5_path</code>             \u2013              <p>Format function for HDF5-path-strings</p> </li> <li> <code>groups</code>             \u2013              <p>Return a generator that yields tuples with: (HDF5-path, h5py.Group)</p> </li> <li> <code>groups_gen</code>             \u2013              <p>Return a generator that yields tuples with: (HDF5-path, h5py.Group)</p> </li> <li> <code>groups_gen_from_fspath</code>             \u2013              <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> </li> <li> <code>h5_attrs_dict</code>             \u2013              <p>Alias for h5.attrs_dict</p> </li> <li> <code>h5_attrs_gen</code>             \u2013              <p>Alias for h5.datasets_gen</p> </li> <li> <code>h5_attrs_gen_from_fspath</code>             \u2013              <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> </li> <li> <code>h5_datasets_dict</code>             \u2013              <p>Alias for h5.datasets_dict</p> </li> <li> <code>h5_datasets_gen</code>             \u2013              <p>Alias for h5.datasets_gen</p> </li> <li> <code>h5_datasets_gen_from_fspath</code>             \u2013              <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> </li> <li> <code>h5py_obj_attrs_gen</code>             \u2013              <p>Recursive h5py.AttributeManager generator.</p> </li> <li> <code>h5py_obj_dataset_gen</code>             \u2013              <p>Recursive h5 dataset generator.</p> </li> <li> <code>h5py_obj_gen</code>             \u2013              <p>Recursive h5 dataset/group generator.</p> </li> <li> <code>h5py_obj_groups_gen</code>             \u2013              <p>Recursive h5 groups generator.</p> </li> <li> <code>h5py_obj_keys_gen</code>             \u2013              <p>Recursive h5 dataset generator.</p> </li> <li> <code>is_dataset</code>             \u2013              <p>h5py.Dataset type guard</p> </li> <li> <code>is_file</code>             \u2013              <p>h5py.File type guard</p> </li> <li> <code>is_group</code>             \u2013              <p>h5py.Group type guard</p> </li> <li> <code>is_h5py_dataset</code>             \u2013              <p>h5py.Dataset type guard</p> </li> <li> <code>is_h5py_file</code>             \u2013              <p>h5py.File type guard</p> </li> <li> <code>is_h5py_group</code>             \u2013              <p>h5py.Group type guard</p> </li> <li> <code>is_hdf5</code>             \u2013              <p>Check if a file is an HDF5 file</p> </li> <li> <code>keys_list</code>             \u2013              <p>Return a list of all keys/paths for an h5py object.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>H5pyCompression</code>               (<code>TypeAlias</code>)           \u2013            <p>h5py mode strings (taken from h5py docstrings)):</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.H5pyCompression","title":"H5pyCompression  <code>module-attribute</code>","text":"<pre><code>H5pyCompression: TypeAlias = Literal['gzip', 'lzf', 'szip']\n</code></pre> <p>h5py mode strings (taken from h5py docstrings)): <pre><code>r        Readonly, file must exist (default)\nr+       Read/write, file must exist\nw        Create file, truncate if exists\nw- or x  Create file, fail if exists\na        Read/write if exists, create otherwise\n</code></pre></p>"},{"location":"libs/h5/h5.api/#h5.FileInfo","title":"FileInfo  <code>dataclass</code>","text":"<pre><code>FileInfo(\n    groups: dict[str, GroupInfo],\n    attrs: dict[str, Any],\n    datasets: dict[str, DatasetInfo],\n    fspath: str,\n    fssize: int,\n    key: str,\n    h5type: Literal[\"file\"],\n)\n</code></pre> <p>               Bases: <code>GroupLikeInfo</code></p> <p>Methods:</p> <ul> <li> <code>from_h5py_file</code>             \u2013              <p>Return <code>FileInfo</code> from <code>h5py.File</code> object</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.FileInfo.from_h5py_file","title":"from_h5py_file  <code>classmethod</code>","text":"<pre><code>from_h5py_file(h5py_group: File) -&gt; FileInfo\n</code></pre> <p>Return <code>FileInfo</code> from <code>h5py.File</code> object</p> <p>could do with dict-comprehension, but  not readable (imo)</p> <pre><code>datasets_and_groups = {\n    obj.name: H5Group.from_h5py_group(obj)\n    if isinstance(obj, Group)\n    else H5Dataset.from_h5py_dataset(obj)\n    for obj in h5py_group.values()\n}\n</code></pre>"},{"location":"libs/h5/h5.api/#h5.as_h5py_obj","title":"as_h5py_obj","text":"<pre><code>as_h5py_obj(obj: File | Group | FsPath) -&gt; File | Group\n</code></pre> <p>Convert a path or h5py object to an h5py object</p>"},{"location":"libs/h5/h5.api/#h5.attrs","title":"attrs","text":"<pre><code>attrs(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, AttributeManager]]\n</code></pre> <p>Return a generator that yields tuples with: (HDF5-path, HDF5-attr)</p>"},{"location":"libs/h5/h5.api/#h5.attrs_dict","title":"attrs_dict","text":"<pre><code>attrs_dict(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; dict[str, dict[str, str | NDArray[Any] | int | float]]\n</code></pre> <p>Load an HDF5 file from a fspath into a dictionary</p> <p>Given a fspath this method loads an HDF5 file into a dictionary where the key =&gt; value pairs are the HDF5-path =&gt; HDF5-dataset for the file. This method relies on the h5_dataset_gen that is in this very module to generate tuples of the form (HDF5-path, HDF5-dataset).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, str | NDArray[Any] | int | float]]</code>           \u2013            <p>Dictionary with key =&gt; value paris of HDF5-path =&gt; HDF5-dataset</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.attrs_dict(h5_obj)","title":"<code>h5_obj</code>","text":"(<code>str</code>)           \u2013            <p>Filepath to an HDF5 format file</p>"},{"location":"libs/h5/h5.api/#h5.attrs_dict(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>HDF5 path to recurse down from</p>"},{"location":"libs/h5/h5.api/#h5.attrs_gen","title":"attrs_gen","text":"<pre><code>attrs_gen(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, AttributeManager]]\n</code></pre> <p>Return a generator that yields tuples with: (HDF5-path, HDF5-attr)</p>"},{"location":"libs/h5/h5.api/#h5.attrs_gen_from_fspath","title":"attrs_gen_from_fspath","text":"<pre><code>attrs_gen_from_fspath(\n    fspath: FsPath, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, AttributeManager]]\n</code></pre> <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, AttributeManager]]</code>           \u2013            <p>Generator that yields tuples of the form (h5-path, h5py.AttributeManager) tuples</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.attrs_gen_from_fspath(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to h5 format file</p>"},{"location":"libs/h5/h5.api/#h5.attrs_gen_from_fspath(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>h5 path to start from. Defaults to \"\".</p>"},{"location":"libs/h5/h5.api/#h5.datasets","title":"datasets","text":"<pre><code>datasets(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Dataset]]\n</code></pre> <p>Return a generator that yields tuples with: (HDF5-path, Dataset)</p>"},{"location":"libs/h5/h5.api/#h5.datasets_dict","title":"datasets_dict","text":"<pre><code>datasets_dict(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; dict[str, NDArray[Any] | int8 | float64]\n</code></pre> <p>Load an HDF5 file from a fspath into a dictionary</p> <p>Given a fspath this method loads an HDF5 file into a dictionary where the key =&gt; value pairs are the HDF5-path =&gt; HDF5-dataset for the file. This method relies on the h5_dataset_gen that is in this very module to generate tuples of the form (HDF5-path, HDF5-dataset).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, NDArray[Any] | int8 | float64]</code>           \u2013            <p>Dictionary with key =&gt; value paris of HDF5-path =&gt; HDF5-dataset</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.datasets_dict(h5_obj)","title":"<code>h5_obj</code>","text":"(<code>str</code>)           \u2013            <p>Filepath to an HDF5 format file</p>"},{"location":"libs/h5/h5.api/#h5.datasets_dict(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>Path to start from. Defaults to \"\".</p>"},{"location":"libs/h5/h5.api/#h5.datasets_gen","title":"datasets_gen","text":"<pre><code>datasets_gen(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Dataset]]\n</code></pre> <p>Return a generator that yields tuples with: (HDF5-path, Dataset)</p>"},{"location":"libs/h5/h5.api/#h5.datasets_gen_from_fspath","title":"datasets_gen_from_fspath","text":"<pre><code>datasets_gen_from_fspath(\n    fspath: str, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Dataset]]\n</code></pre> <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, Dataset]]</code>           \u2013            <p>Generator that yields tuples of the form (h5-path, h5py.Dataset) tuples</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.datasets_gen_from_fspath(fspath)","title":"<code>fspath</code>","text":"(<code>str</code>)           \u2013            <p>fspath to h5 format file</p>"},{"location":"libs/h5/h5.api/#h5.datasets_gen_from_fspath(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>h5 path to start from. Defaults to \"\".</p>"},{"location":"libs/h5/h5.api/#h5.datasets_keys_list","title":"datasets_keys_list","text":"<pre><code>datasets_keys_list(\n    h5py_obj: File | Group | FsPath,\n) -&gt; list[str]\n</code></pre> <p>Return a list of all keys/paths for an h5py object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.Dataset)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.datasets_keys_list(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group | FsPath</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/h5/h5.api/#h5.fmt_h5_path","title":"fmt_h5_path  <code>cached</code>","text":"<pre><code>fmt_h5_path(head: str, tail: str) -&gt; str\n</code></pre> <p>Format function for HDF5-path-strings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fmt_h5_path(\"foo\", \"bar\")\n'/foo/bar'\n</code></pre>"},{"location":"libs/h5/h5.api/#h5.groups","title":"groups","text":"<pre><code>groups(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Group]]\n</code></pre> <p>Return a generator that yields tuples with: (HDF5-path, h5py.Group)</p>"},{"location":"libs/h5/h5.api/#h5.groups_gen","title":"groups_gen","text":"<pre><code>groups_gen(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Group]]\n</code></pre> <p>Return a generator that yields tuples with: (HDF5-path, h5py.Group)</p>"},{"location":"libs/h5/h5.api/#h5.groups_gen_from_fspath","title":"groups_gen_from_fspath","text":"<pre><code>groups_gen_from_fspath(\n    fspath: FsPath, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Group]]\n</code></pre> <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, Group]]</code>           \u2013            <p>Generator that yields tuples of the form (h5-path, h5py.AttributeManager) tuples</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.groups_gen_from_fspath(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to h5 format file</p>"},{"location":"libs/h5/h5.api/#h5.groups_gen_from_fspath(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>h5 path to start from. Defaults to \"\".</p>"},{"location":"libs/h5/h5.api/#h5.h5_attrs_dict","title":"h5_attrs_dict","text":"<pre><code>h5_attrs_dict(\n    fspath: str, h5_path: str = \"\"\n) -&gt; dict[str, H5pyAttributesDict]\n</code></pre> <p>Alias for h5.attrs_dict</p>"},{"location":"libs/h5/h5.api/#h5.h5_attrs_gen","title":"h5_attrs_gen","text":"<pre><code>h5_attrs_gen(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, AttributeManager]]\n</code></pre> <p>Alias for h5.datasets_gen</p>"},{"location":"libs/h5/h5.api/#h5.h5_attrs_gen_from_fspath","title":"h5_attrs_gen_from_fspath","text":"<pre><code>h5_attrs_gen_from_fspath(\n    fspath: FsPath, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, AttributeManager]]\n</code></pre> <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, AttributeManager]]</code>           \u2013            <p>Generator that yields tuples of the form (h5-path, h5py.AttributeManager) tuples</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5_attrs_gen_from_fspath(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to h5 format file</p>"},{"location":"libs/h5/h5.api/#h5.h5_attrs_gen_from_fspath(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>h5 path to start from. Defaults to \"\".</p>"},{"location":"libs/h5/h5.api/#h5.h5_datasets_dict","title":"h5_datasets_dict","text":"<pre><code>h5_datasets_dict(\n    fspath: str, h5_path: str = \"\"\n) -&gt; dict[str, NDArray[Any] | int8 | float64]\n</code></pre> <p>Alias for h5.datasets_dict</p>"},{"location":"libs/h5/h5.api/#h5.h5_datasets_gen","title":"h5_datasets_gen","text":"<pre><code>h5_datasets_gen(\n    h5_obj: FsPath | File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Dataset]]\n</code></pre> <p>Alias for h5.datasets_gen</p>"},{"location":"libs/h5/h5.api/#h5.h5_datasets_gen_from_fspath","title":"h5_datasets_gen_from_fspath","text":"<pre><code>h5_datasets_gen_from_fspath(\n    fspath: str, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Dataset]]\n</code></pre> <p>Given a fspath to an h5, yield (h5-path, h5py.Dataset) tuples</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, Dataset]]</code>           \u2013            <p>Generator that yields tuples of the form (h5-path, h5py.Dataset) tuples</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5_datasets_gen_from_fspath(fspath)","title":"<code>fspath</code>","text":"(<code>str</code>)           \u2013            <p>fspath to h5 format file</p>"},{"location":"libs/h5/h5.api/#h5.h5_datasets_gen_from_fspath(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>h5 path to start from. Defaults to \"\".</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_attrs_gen","title":"h5py_obj_attrs_gen","text":"<pre><code>h5py_obj_attrs_gen(\n    h5py_obj: File | Group,\n    h5_path: str = \"\",\n    *,\n    root: bool = True,\n) -&gt; Iterable[tuple[str, AttributeManager]]\n</code></pre> <p>Recursive h5py.AttributeManager generator.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, AttributeManager]]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.AttributeManager)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_attrs_gen(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_attrs_gen(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>path so far (Default value = \"\")</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_attrs_gen(root)","title":"<code>root</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, yield the root path (Default value = True)</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_dataset_gen","title":"h5py_obj_dataset_gen","text":"<pre><code>h5py_obj_dataset_gen(\n    h5py_obj: File | Group, h5_path: str = \"\"\n) -&gt; Iterable[tuple[str, Dataset]]\n</code></pre> <p>Recursive h5 dataset generator.</p> <p>Given an h5 group, which is what one gets after loading an h5 file via h5py, this function yields tuples containing (1.) a path (h5_path) to a dataset in the group, and (2.) the dataset itself as a numpy array.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, Dataset]]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.Dataset)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_dataset_gen(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_dataset_gen(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>path so far (Default value = \"\")</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_gen","title":"h5py_obj_gen","text":"<pre><code>h5py_obj_gen(\n    h5py_obj: File | Group,\n    h5_path: str = \"\",\n    *,\n    root: bool = True,\n) -&gt; Iterable[tuple[str, Dataset | Group | File]]\n</code></pre> <p>Recursive h5 dataset/group generator.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, Dataset | Group | File]]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.AttributeManager)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_gen(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_gen(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>path so far (Default value = \"\")</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_gen(root)","title":"<code>root</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, yield the root path (Default value = True)</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_groups_gen","title":"h5py_obj_groups_gen","text":"<pre><code>h5py_obj_groups_gen(\n    h5py_obj: File | Group,\n    h5_path: str = \"\",\n    *,\n    root: bool = True,\n) -&gt; Iterable[tuple[str, Group]]\n</code></pre> <p>Recursive h5 groups generator.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, Group]]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.AttributeManager)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_groups_gen(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_groups_gen(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>path so far (Default value = \"\")</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_groups_gen(root)","title":"<code>root</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, yield the root path (Default value = True)</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_keys_gen","title":"h5py_obj_keys_gen","text":"<pre><code>h5py_obj_keys_gen(\n    h5py_obj: File | Group,\n    h5_path: str = \"\",\n    *,\n    root: bool = True,\n) -&gt; Iterable[str]\n</code></pre> <p>Recursive h5 dataset generator.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[str]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.AttributeManager)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_keys_gen(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_keys_gen(h5_path)","title":"<code>h5_path</code>","text":"(<code>str</code>, default:                   <code>''</code> )           \u2013            <p>path so far (Default value = \"\")</p>"},{"location":"libs/h5/h5.api/#h5.h5py_obj_keys_gen(root)","title":"<code>root</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>if True, yield the root path (Default value = True)</p>"},{"location":"libs/h5/h5.api/#h5.is_dataset","title":"is_dataset","text":"<pre><code>is_dataset(obj: Any) -&gt; TypeGuard[Dataset]\n</code></pre> <p>h5py.Dataset type guard</p>"},{"location":"libs/h5/h5.api/#h5.is_file","title":"is_file","text":"<pre><code>is_file(obj: Any) -&gt; TypeGuard[File]\n</code></pre> <p>h5py.File type guard</p>"},{"location":"libs/h5/h5.api/#h5.is_group","title":"is_group","text":"<pre><code>is_group(obj: Any) -&gt; TypeGuard[Group]\n</code></pre> <p>h5py.Group type guard</p>"},{"location":"libs/h5/h5.api/#h5.is_h5py_dataset","title":"is_h5py_dataset","text":"<pre><code>is_h5py_dataset(obj: Any) -&gt; TypeGuard[Dataset]\n</code></pre> <p>h5py.Dataset type guard</p>"},{"location":"libs/h5/h5.api/#h5.is_h5py_file","title":"is_h5py_file","text":"<pre><code>is_h5py_file(obj: Any) -&gt; TypeGuard[File]\n</code></pre> <p>h5py.File type guard</p>"},{"location":"libs/h5/h5.api/#h5.is_h5py_group","title":"is_h5py_group","text":"<pre><code>is_h5py_group(obj: Any) -&gt; TypeGuard[Group]\n</code></pre> <p>h5py.Group type guard</p>"},{"location":"libs/h5/h5.api/#h5.is_hdf5","title":"is_hdf5","text":"<pre><code>is_hdf5(path: FsPath) -&gt; bool\n</code></pre> <p>Check if a file is an HDF5 file</p>"},{"location":"libs/h5/h5.api/#h5.keys_list","title":"keys_list","text":"<pre><code>keys_list(h5py_obj: File | Group | FsPath) -&gt; list[str]\n</code></pre> <p>Return a list of all keys/paths for an h5py object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>Generator that yields tuples; (h5-path, h5py.Dataset)</p> </li> </ul>"},{"location":"libs/h5/h5.api/#h5.keys_list(h5py_obj)","title":"<code>h5py_obj</code>","text":"(<code>File | Group | FsPath</code>)           \u2013            <p>h5-h5py group object</p>"},{"location":"libs/jsonbourne/","title":"jsonbourne","text":"In\u00a0[1]: Copied! <pre># Importing JSON:\n\n# or\nimport JSON\n\n# Importing jsonbourne:\nfrom jsonbourne import JSON\n</pre> # Importing JSON:  # or import JSON  # Importing jsonbourne: from jsonbourne import JSON <p>JSON basics:</p> In\u00a0[2]: Copied! <pre>string_stringify = JSON.stringify({\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": 3,\n})  # '{\"a\": 1, \"b\": 2, \"c\": 3}'\nstring_dumps = JSON.dumps({\"a\": 1, \"b\": 2, \"c\": 3})  # '{\"a\": 1, \"b\": 2, \"c\": 3}'\nstring_dumps\n</pre> string_stringify = JSON.stringify({     \"a\": 1,     \"b\": 2,     \"c\": 3, })  # '{\"a\": 1, \"b\": 2, \"c\": 3}' string_dumps = JSON.dumps({\"a\": 1, \"b\": 2, \"c\": 3})  # '{\"a\": 1, \"b\": 2, \"c\": 3}' string_dumps Out[2]: <pre>'{\"a\":1,\"b\":2,\"c\":3}'</pre> In\u00a0[3]: Copied! <pre>string_dumps = JSON.stringify(\n    {\"b\": 2, \"a\": 1, \"c\": 3}, pretty=True\n)  # '{\"a\": 1, \"b\": 2, \"c\": 3}'\nprint(string_dumps)\n</pre> string_dumps = JSON.stringify(     {\"b\": 2, \"a\": 1, \"c\": 3}, pretty=True )  # '{\"a\": 1, \"b\": 2, \"c\": 3}' print(string_dumps) <pre>{\n  \"b\": 2,\n  \"a\": 1,\n  \"c\": 3\n}\n</pre> <p>sort_keys:</p> In\u00a0[4]: Copied! <pre>string_dumps = JSON.stringify(\n    {\"b\": 2, \"a\": 1, \"c\": 3}, pretty=True, sort_keys=True\n)  # '{\"a\": 1, \"b\": 2, \"c\": 3}'\nprint(string_dumps)\n</pre> string_dumps = JSON.stringify(     {\"b\": 2, \"a\": 1, \"c\": 3}, pretty=True, sort_keys=True )  # '{\"a\": 1, \"b\": 2, \"c\": 3}' print(string_dumps) <pre>{\n  \"a\": 1,\n  \"b\": 2,\n  \"c\": 3\n}\n</pre> In\u00a0[5]: Copied! <pre>import datetime\n\ndata = {\n    \"key\": \"value\",\n    \"list\": [1, 2, 3, 4, 5],\n    \"dt\": datetime.datetime(1970, 1, 1, 0, 0, 0, 1),\n    \"sub\": {\n        \"b\": 3,\n        \"key\": \"val\",\n        \"a\": 1,\n    },\n    \"timedelta\": datetime.timedelta(days=2),\n}\n\nJSON(data)\n</pre> import datetime  data = {     \"key\": \"value\",     \"list\": [1, 2, 3, 4, 5],     \"dt\": datetime.datetime(1970, 1, 1, 0, 0, 0, 1),     \"sub\": {         \"b\": 3,         \"key\": \"val\",         \"a\": 1,     },     \"timedelta\": datetime.timedelta(days=2), }  JSON(data) Out[5]: <pre>JsonObj(**{\n    'dt': datetime.datetime(1970, 1, 1, 0, 0, 0, 1),\n    'key': 'value',\n    'list': [1, 2, 3, 4, 5],\n    'sub': {'a': 1, 'b': 3, 'key': 'val'},\n    'timedelta': datetime.timedelta(days=2)\n})</pre> In\u00a0[6]: Copied! <pre>JSON(data).sub.b\n</pre> JSON(data).sub.b Out[6]: <pre>3</pre> In\u00a0[7]: Copied! <pre>stringified_data = JSON(data).stringify(pretty=True)\nprint(stringified_data)\n</pre> stringified_data = JSON(data).stringify(pretty=True) print(stringified_data) <pre>{\n  \"key\": \"value\",\n  \"list\": [\n    1,\n    2,\n    3,\n    4,\n    5\n  ],\n  \"dt\": \"1970-01-01T00:00:00.000001\",\n  \"sub\": {\n    \"b\": 3,\n    \"key\": \"val\",\n    \"a\": 1\n  },\n  \"timedelta\": 172800.0\n}\n</pre> In\u00a0[8]: Copied! <pre>parsed_data = JSON(stringified_data)\nparsed_data\n</pre> parsed_data = JSON(stringified_data) parsed_data Out[8]: <pre>JsonObj(**{\n    'dt': '1970-01-01T00:00:00.000001',\n    'key': 'value',\n    'list': [1, 2, 3, 4, 5],\n    'sub': {'a': 1, 'b': 3, 'key': 'val'},\n    'timedelta': 172800.0\n})</pre> In\u00a0[9]: Copied! <pre>list(parsed_data.keys())\n</pre> list(parsed_data.keys()) Out[9]: <pre>['key', 'list', 'dt', 'sub', 'timedelta']</pre> In\u00a0[10]: Copied! <pre>list(parsed_data.items())\n</pre> list(parsed_data.items()) Out[10]: <pre>[('key', 'value'),\n ('list', [1, 2, 3, 4, 5]),\n ('dt', '1970-01-01T00:00:00.000001'),\n ('sub', JsonObj(**{'b': 3, 'key': 'val', 'a': 1})),\n ('timedelta', 172800.0)]</pre> In\u00a0[11]: Copied! <pre>list(parsed_data.dot_keys())\n</pre> list(parsed_data.dot_keys()) Out[11]: <pre>[('key',),\n ('list',),\n ('dt',),\n ('sub', 'b'),\n ('sub', 'key'),\n ('sub', 'a'),\n ('timedelta',)]</pre> In\u00a0[12]: Copied! <pre>list(parsed_data.dot_items())\n</pre> list(parsed_data.dot_items()) Out[12]: <pre>[(('key',), 'value'),\n (('list',), [1, 2, 3, 4, 5]),\n (('dt',), '1970-01-01T00:00:00.000001'),\n (('sub', 'b'), 3),\n (('sub', 'key'), 'val'),\n (('sub', 'a'), 1),\n (('timedelta',), 172800.0)]</pre> In\u00a0[13]: Copied! <pre>parsed_data[(\"sub\", \"key\")]\n</pre> parsed_data[(\"sub\", \"key\")] Out[13]: <pre>'val'</pre> In\u00a0[14]: Copied! <pre>parsed_data.dot_lookup(\"sub.key\")\n</pre> parsed_data.dot_lookup(\"sub.key\") Out[14]: <pre>'val'</pre> In\u00a0[15]: Copied! <pre>{**parsed_data}\n</pre> {**parsed_data} Out[15]: <pre>{'key': 'value',\n 'list': [1, 2, 3, 4, 5],\n 'dt': '1970-01-01T00:00:00.000001',\n 'sub': JsonObj(**{'b': 3, 'key': 'val', 'a': 1}),\n 'timedelta': 172800.0}</pre> In\u00a0[16]: Copied! <pre># fully eject\nparsed_data.eject()\n</pre> # fully eject parsed_data.eject() Out[16]: <pre>{'key': 'value',\n 'list': [1, 2, 3, 4, 5],\n 'dt': '1970-01-01T00:00:00.000001',\n 'sub': {'b': 3, 'key': 'val', 'a': 1},\n 'timedelta': 172800.0}</pre> In\u00a0[17]: Copied! <pre>from jsonbourne import JSON\n\nj = JSON()\nj.key = \"value\"\ntry:  # CANNOT set 'items' using dot-access\n    j.items = [1, 2, 3, 4]\nexcept ValueError:\n    pass\n# CAN set 'items' through key/item access\nj[\"items\"] = [1, 2, 3, 4]\nprint(j.__dict__)\nprint(j)\nj_items = j.items\nprint(\"items\", j_items)\n# Getting 'items' through dot-access returns the `items()` method\nassert j.items != [1, 2, 3, 4]\n# Getting 'items' with key-access returns the stored value\nassert j[\"items\"] == [1, 2, 3, 4]\n</pre> from jsonbourne import JSON  j = JSON() j.key = \"value\" try:  # CANNOT set 'items' using dot-access     j.items = [1, 2, 3, 4] except ValueError:     pass # CAN set 'items' through key/item access j[\"items\"] = [1, 2, 3, 4] print(j.__dict__) print(j) j_items = j.items print(\"items\", j_items) # Getting 'items' through dot-access returns the `items()` method assert j.items != [1, 2, 3, 4] # Getting 'items' with key-access returns the stored value assert j[\"items\"] == [1, 2, 3, 4] <pre>{'_data': {'key': 'value', 'items': [1, 2, 3, 4]}}\nJsonObj(**{\n    'items': [1, 2, 3, 4], 'key': 'value'\n})\nitems &lt;bound method JsonObj.items of JsonObj(**{'key': 'value', 'items': [1, 2, 3, 4]})&gt;\n</pre> In\u00a0[18]: Copied! <pre>from jsonbourne import JsonObj\nfrom jsonbourne.pydantic import JsonBaseModel\n\n\nclass JsonSubObj(JsonBaseModel):\n    herm: int\n\n    def to_dict(self):\n        return self.dict()\n\n    def to_json(self, *args, **kwargs):\n        return self.json()\n\n    @classmethod\n    def from_json(cls, json_string: str):\n        return JsonSubObj(json.loads(json_string))\n\n\nclass JsonObjModel(JsonBaseModel):\n    a: int\n    b: int\n    c: str\n    d: JsonObj\n    e: JsonSubObj\n\n    #\n    @property\n    def a_property(self) -&gt; str:\n        return \"prop_value\"\n\n    def to_json(self, *args, **kwargs):\n        return self.json()\n\n    @classmethod\n    def from_json(cls, json_string: str):\n        return cls(**json.loads(json_string))\n\n\nobj = JsonObjModel(**{\n    \"a\": 1,\n    \"b\": 2,\n    \"c\": \"herm\",\n    \"d\": {\"nested\": \"nestedval\"},\n    \"e\": {\"herm\": 2},\n})\nobj\n</pre> from jsonbourne import JsonObj from jsonbourne.pydantic import JsonBaseModel   class JsonSubObj(JsonBaseModel):     herm: int      def to_dict(self):         return self.dict()      def to_json(self, *args, **kwargs):         return self.json()      @classmethod     def from_json(cls, json_string: str):         return JsonSubObj(json.loads(json_string))   class JsonObjModel(JsonBaseModel):     a: int     b: int     c: str     d: JsonObj     e: JsonSubObj      #     @property     def a_property(self) -&gt; str:         return \"prop_value\"      def to_json(self, *args, **kwargs):         return self.json()      @classmethod     def from_json(cls, json_string: str):         return cls(**json.loads(json_string))   obj = JsonObjModel(**{     \"a\": 1,     \"b\": 2,     \"c\": \"herm\",     \"d\": {\"nested\": \"nestedval\"},     \"e\": {\"herm\": 2}, }) obj Out[18]: <pre>JsonObjModel(**{\n    'a': 1, 'b': 2, 'c': 'herm', 'd': JsonObj(**{'nested': 'nestedval'}), 'e': {'herm': 2}\n})</pre> In\u00a0[19]: Copied! <pre># respects properties (which I don't think pydantic does(currently))\nobj.a_property\n</pre> # respects properties (which I don't think pydantic does(currently)) obj.a_property Out[19]: <pre>'prop_value'</pre> In\u00a0[20]: Copied! <pre>from jsonbourne import import_json\n\njson = import_json((\"rapidjson\", \"orjson\"))  # prefer rapidjson over orjson\nstring = json.dumps({\"a\": 1, \"b\": 2, \"c\": 3})\nprint(json)\nprint(string)\n</pre> from jsonbourne import import_json  json = import_json((\"rapidjson\", \"orjson\"))  # prefer rapidjson over orjson string = json.dumps({\"a\": 1, \"b\": 2, \"c\": 3}) print(json) print(string) <pre>&lt;class 'jsonbourne.jsonlib._rapidjson.RAPIDJSON'&gt;\n{\"a\":1,\"b\":2,\"c\":3}\n</pre>"},{"location":"libs/jsonbourne/#jsonbourne","title":"jsonbourne\u00b6","text":"<p>Install: <code>pip install jsonbourne</code></p> <ul> <li>Python json lib/pkg that makes json feel like the JSON module in javascript/typescript:<ul> <li><code>from jsonbourne import JSON; JSON.parse(JSON.stringify({\"key\": \"value\"}))</code></li> <li>Automatically uses best json-lib-backend available (<code>orjson</code>/<code>python-rapidjson</code>) ~ can be configured</li> </ul> </li> <li>Hybrid dict/class object (<code>jsonbourne.JsonObj</code>):<ul> <li>Dot-notation getting/setting (featuring protected attributes!)</li> <li>All your favorite python dictionary methods (<code>items</code>, <code>keys</code>, <code>update</code>, <code>values</code>) and more!</li> <li>Works with <code>pydantic</code> and <code>attrs</code></li> </ul> </li> <li>FastAPI:<ul> <li>JSONBOURNEResponse ~ auto use the best</li> </ul> </li> <li>No hard dependencies ~ works with python-stdlib-json as well as <code>orjson</code> and <code>python-rapidjson</code></li> <li><code>jsonbourne.JsonObj</code> uses list/dict comprehensions (some are recursive) everywhere because 'why not?' and it is a bit faster</li> </ul>"},{"location":"libs/jsonbourne/#usage","title":"Usage:\u00b6","text":""},{"location":"libs/jsonbourne/#json-from-jsonbourne-import-json","title":"JSON ~ <code>from jsonbourne import JSON</code>\u00b6","text":"<p>Importing:</p>"},{"location":"libs/jsonbourne/#json-option-kwargs-pretty-sort_keys","title":"JSON option kwargs ~ <code>pretty</code> &amp; <code>sort_keys</code>\u00b6","text":"<p>pretty:</p>"},{"location":"libs/jsonbourne/#jsonobj-json","title":"JsonObj &amp; JSON\u00b6","text":"<ul> <li>Python dictionary/object with dot access</li> <li>Protections against setting class/obj attributes</li> <li>Is as javascript-y as possible (keys have to be strings -- ints/floats will be converted to strings)</li> <li>Create a <code>jsonbourne.JsonObj</code> with <code>jsonbourne.JSON</code></li> <li>Recursive jsonification</li> <li>Allows for kwarging (<code>**json_obj</code>)</li> <li>Works with <code>pydantic</code> and <code>attrs</code></li> </ul>"},{"location":"libs/jsonbourne/#make-an-empty-jsonobj","title":"Make an empty JsonObj\u00b6","text":"<p>The following 3 examples all produce the same thing</p> <pre>from jsonbourne import JSON\nj = JSON()  # j =&gt; JsonObj(**{})\n# OR\nimport JSON\nj = JSON()  # j =&gt; JsonObj(**{})\n# OR\nfrom jsonbourne import JsonObj\nj = JsonObj()  # j =&gt; JsonObj(**{})\n</pre>"},{"location":"libs/jsonbourne/#from-a-dictionary-o-data","title":"From a dictionary o data\u00b6","text":""},{"location":"libs/jsonbourne/#dot-access","title":"Dot access\u00b6","text":""},{"location":"libs/jsonbourne/#protected-keys","title":"Protected keys\u00b6","text":"<p><code>jsonbourne.JsonObj</code> protects against setting attributes like <code>'items'</code> through dot-notation.</p>"},{"location":"libs/jsonbourne/#pydantic-jsonbourne","title":"pydantic &amp; jsonbourne\u00b6","text":"<ul> <li><code>from jsonbourne.pydantic import JsonBaseModel</code></li> <li>Allows for aliases when getting/setting attribute(s)</li> <li>Supports <code>__post_init__</code> (like dataclasses)</li> </ul>"},{"location":"libs/jsonbourne/#basic-usage","title":"Basic usage:\u00b6","text":""},{"location":"libs/jsonbourne/#json-backendlib","title":"JSON backend/lib\u00b6","text":"<p><code>jsonbourne</code> finds the best json-lib (python-rapidjson/orjson) it can! On import <code>jsonbourne</code> gets to work spying on your python env. <code>jsonbourne</code>, the most highly qualified json-CIA-agent, will import the best python-json library it can find; if <code>jsonbourne</code>'s cover is blown (meaning: the only json library found is the python stdlib json), <code>jsonbourne</code> will fallback to the python stdlib json.</p> <p><code>jsonbourne</code> will look for the following json-packages in the following order:</p> <ol> <li><code>rapidjson</code></li> <li><code>orjson</code></li> </ol>"},{"location":"libs/jsonbourne/#custom-lib-preferences","title":"Custom lib preferences\u00b6","text":""},{"location":"libs/jsonbourne/#installing-better-json-lib","title":"Installing better JSON lib:\u00b6","text":"<ul> <li><code>pip install orjson</code> [pip]</li> <li><code>pip install python-rapidjson</code> [pip]</li> <li><code>conda install -c anaconda python-rapidjson</code> [conda anaconda/defaults]</li> <li><code>conda install -c conda-forge python-rapidjson</code> [conda-forge]</li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/","title":"jsonbourne","text":""},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule","title":"JsonModule","text":"<pre><code>JsonModule()\n</code></pre> <p>JSON class meant to mimic the js/ts-JSON</p> <p>Methods:</p> <ul> <li> <code>binify</code>             \u2013              <p>Return JSON string bytes for given data</p> </li> <li> <code>dumpb</code>             \u2013              <p>Return JSON string bytes for given data</p> </li> <li> <code>dumps</code>             \u2013              <p>Return JSON stringified/dumps-ed data</p> </li> <li> <code>json_lib</code>             \u2013              <p>Return the name of the JSON library being used as a backend</p> </li> <li> <code>jsonify</code>             \u2013              <p>Alias for jsonbourne.core.jsonify</p> </li> <li> <code>loads</code>             \u2013              <p>Parse JSON string/bytes and return raw representation</p> </li> <li> <code>parse</code>             \u2013              <p>Parse JSON string/bytes</p> </li> <li> <code>rjson</code>             \u2013              <p>Read JSON file and return raw representation</p> </li> <li> <code>stringify</code>             \u2013              <p>Return JSON stringified/dumps-ed data</p> </li> <li> <code>unjsonify</code>             \u2013              <p>Alias for jsonbourne.core.unjsonify</p> </li> <li> <code>which</code>             \u2013              <p>Return the name of the JSON library being used as a backend</p> </li> <li> <code>wjson</code>             \u2013              <p>Write JSON file</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.binify","title":"binify  <code>staticmethod</code>","text":"<pre><code>binify(\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; bytes\n</code></pre> <p>Return JSON string bytes for given data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.dumpb","title":"dumpb  <code>staticmethod</code>","text":"<pre><code>dumpb(\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; bytes\n</code></pre> <p>Return JSON string bytes for given data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.dumps","title":"dumps  <code>staticmethod</code>","text":"<pre><code>dumps(\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON stringified/dumps-ed data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.json_lib","title":"json_lib  <code>staticmethod</code>","text":"<pre><code>json_lib() -&gt; str\n</code></pre> <p>Return the name of the JSON library being used as a backend</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.jsonify","title":"jsonify  <code>staticmethod</code>","text":"<pre><code>jsonify(value: Any) -&gt; Any\n</code></pre> <p>Alias for jsonbourne.core.jsonify</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.loads","title":"loads  <code>staticmethod</code>","text":"<pre><code>loads(\n    string: bytes | str,\n    *,\n    obj: bool = False,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Parse JSON string/bytes and return raw representation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.parse","title":"parse  <code>staticmethod</code>","text":"<pre><code>parse(\n    string: bytes | str,\n    *,\n    obj: bool = False,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Parse JSON string/bytes</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.rjson","title":"rjson  <code>staticmethod</code>","text":"<pre><code>rjson(\n    fspath: Path | str,\n    *,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n    **kwargs: Any,\n) -&gt; Any\n</code></pre> <p>Read JSON file and return raw representation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.stringify","title":"stringify  <code>staticmethod</code>","text":"<pre><code>stringify(\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON stringified/dumps-ed data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.unjsonify","title":"unjsonify  <code>staticmethod</code>","text":"<pre><code>unjsonify(value: Any) -&gt; Any\n</code></pre> <p>Alias for jsonbourne.core.unjsonify</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.which","title":"which  <code>staticmethod</code>","text":"<pre><code>which() -&gt; str\n</code></pre> <p>Return the name of the JSON library being used as a backend</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.core.JsonModule.wjson","title":"wjson  <code>staticmethod</code>","text":"<pre><code>wjson(\n    fspath: Path | str,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Write JSON file</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne","title":"jsonbourne","text":"<p>jsonbourne the best undercover json lib</p> <p>Dynamic Graphics Python</p> <p>Modules:</p> <ul> <li> <code>core</code>           \u2013            <p>Json Bourne -- EZ-PZ-JSON with lots o goodies</p> </li> <li> <code>dev</code>           \u2013            <p>jsonbourne.dev</p> </li> <li> <code>fastapi</code>           \u2013            </li> <li> <code>helpers</code>           \u2013            <p>JSONBourne helper funks and utils</p> </li> <li> <code>httpx</code>           \u2013            <p>Jsonbourne wrapper around httpx clients -- lets you do response.JSON()</p> </li> <li> <code>json_arr</code>           \u2013            </li> <li> <code>jsonlib</code>           \u2013            <p>jsonbourne jsonlib api</p> </li> <li> <code>pydantic</code>           \u2013            <p>JSONBourne + Pydantic</p> </li> <li> <code>trydantic</code>           \u2013            <p>trydantic = try + pydantic</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>JsonDict</code>           \u2013            <p>Alias for JsonObj</p> </li> <li> <code>JsonObj</code>           \u2013            <p>JSON friendly python dictionary with dot notation and string only keys</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>rm_js_comments</code>             \u2013              <p>Rejects/regex that removes js/ts/json style comments</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict","title":"JsonDict","text":"<pre><code>JsonDict(*args: dict[_KT, _VT])\n</code></pre><pre><code>JsonDict(*args: dict[_KT, _VT], **kwargs: _VT)\n</code></pre><pre><code>JsonDict(*args: Mapping[_KT, _VT])\n</code></pre><pre><code>JsonDict(*args: Mapping[_KT, _VT], **kwargs: _VT)\n</code></pre> <pre><code>JsonDict(*args: Any, **kwargs: _VT)\n</code></pre> <p>               Bases: <code>JsonObj[_VT]</code>, <code>Generic[_VT]</code></p> <p>Alias for JsonObj</p> <p>Methods:</p> <ul> <li> <code>JSON</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>asdict</code>             \u2013              <p>Return the JsonObj object (and children) as a python dictionary</p> </li> <li> <code>dot_items</code>             \u2013              <p>Yield tuples of the form (dot-key, value)</p> </li> <li> <code>dot_items_list</code>             \u2013              <p>Return list of tuples of the form (dot-key, value)</p> </li> <li> <code>dot_keys</code>             \u2013              <p>Yield the JsonObj's dot-notation keys</p> </li> <li> <code>dot_keys_list</code>             \u2013              <p>Return a list of the JsonObj's dot-notation friendly keys</p> </li> <li> <code>dot_keys_set</code>             \u2013              <p>Return a set of the JsonObj's dot-notation friendly keys</p> </li> <li> <code>dot_lookup</code>             \u2013              <p>Look up JsonObj keys using dot notation as a string</p> </li> <li> <code>eject</code>             \u2013              <p>Eject to python-builtin dictionary object</p> </li> <li> <code>entries</code>             \u2013              <p>Alias for items</p> </li> <li> <code>filter_false</code>             \u2013              <p>Filter key-values where the value is false-y</p> </li> <li> <code>filter_none</code>             \u2013              <p>Filter key-values where the value is <code>None</code> but not false-y</p> </li> <li> <code>from_dict</code>             \u2013              <p>Return a JsonObj object from a dictionary of data</p> </li> <li> <code>from_json</code>             \u2013              <p>Return a JsonObj object from a json string</p> </li> <li> <code>items</code>             \u2013              <p>Return an items view of the JsonObj object</p> </li> <li> <code>keys</code>             \u2013              <p>Return the keys view of the JsonObj object</p> </li> <li> <code>recurse</code>             \u2013              <p>Recursively convert all sub dictionaries to JsonObj objects</p> </li> <li> <code>stringify</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>to_dict</code>             \u2013              <p>Return the JsonObj object (and children) as a python dictionary</p> </li> <li> <code>to_json</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>to_str</code>             \u2013              <p>Return a string representation of the JsonObj object</p> </li> <li> <code>validate_type</code>             \u2013              <p>Validate and convert a value to a JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON","title":"JSON","text":"<pre><code>JSON(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.JSON(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict[_KT, Any]\n</code></pre> <p>Return the JsonObj object (and children) as a python dictionary</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_items","title":"dot_items","text":"<pre><code>dot_items() -&gt; Iterator[tuple[tuple[str, ...], _VT]]\n</code></pre> <p>Yield tuples of the form (dot-key, value)</p> OG-version <p>def dot_items(self) -&gt; Iterator[tuple[str, Any]]:     return ((dk, self.dot_lookup(dk)) for dk in self.dot_keys())</p> Readable-version <p>for k, value in self.items():     value = jsonify(value)     if isinstance(value, JsonObj) or hasattr(value, 'dot_items'):         yield from ((f\"{k}.{dk}\", dv) for dk, dv in value.dot_items())     else:         yield k, value</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_items_list","title":"dot_items_list","text":"<pre><code>dot_items_list() -&gt; list[tuple[tuple[str, ...], Any]]\n</code></pre> <p>Return list of tuples of the form (dot-key, value)</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_keys","title":"dot_keys","text":"<pre><code>dot_keys() -&gt; Iterable[tuple[str, ...]]\n</code></pre> <p>Yield the JsonObj's dot-notation keys</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, ...]]</code>           \u2013            <p>Iterable[str]: List of the dot-notation friendly keys</p> </li> </ul> <p>The Non-chain version (shown below) is very slightly slower than the <code>itertools.chain</code> version.</p> <p>NON-CHAIN VERSION:</p> <p>for k, value in self.items():     value = jsonify(value)     if isinstance(value, JsonObj):         yield from (f\"{k}.{dk}\" for dk in value.dot_keys())     else:         yield k</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_keys_list","title":"dot_keys_list","text":"<pre><code>dot_keys_list(\n    *, sort_keys: bool = False\n) -&gt; list[tuple[str, ...]]\n</code></pre> <p>Return a list of the JsonObj's dot-notation friendly keys</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[str, ...]]</code>           \u2013            <p>list[str]: List of the dot-notation friendly keys</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_keys_list(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to have the dot-keys be returned sorted</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_keys_set","title":"dot_keys_set","text":"<pre><code>dot_keys_set() -&gt; set[tuple[str, ...]]\n</code></pre> <p>Return a set of the JsonObj's dot-notation friendly keys</p> <p>Returns:</p> <ul> <li> <code>set[tuple[str, ...]]</code>           \u2013            <p>set[str]: List of the dot-notation friendly keys</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_lookup","title":"dot_lookup","text":"<pre><code>dot_lookup(key: str | tuple[str, ...] | list[str]) -&gt; Any\n</code></pre> <p>Look up JsonObj keys using dot notation as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The result of the dot-notation key look up</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>Raised if the dot-key is not in in the object</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raised if key is not a str/Tuple[str, ...]/list[str]</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.dot_lookup(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>dot-notation key to look up ('key1.key2.third_key')</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.eject","title":"eject","text":"<pre><code>eject() -&gt; dict[_KT, _VT]\n</code></pre> <p>Eject to python-builtin dictionary object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = JsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; plain_ol_dict = d.eject()\n&gt;&gt;&gt; plain_ol_dict\n{'uno': 'ONE', 'tres': 3, 'dos': 2}\n&gt;&gt;&gt; type(plain_ol_dict)\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.entries","title":"entries","text":"<pre><code>entries() -&gt; ItemsView[_KT, _VT]\n</code></pre> <p>Alias for items</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.filter_false","title":"filter_false","text":"<pre><code>filter_false(*, recursive: bool = False) -&gt; JsonObj[_VT]\n</code></pre> <p>Filter key-values where the value is false-y</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObj[_VT]</code>           \u2013            <p>JsonObj that has been filtered</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\n...     'falsey_dict': {},\n...     'falsey_list': [],\n...     'falsey_string': '',\n...     'is_false': False,\n...     'a': None,\n...     'b': 2,\n...     'c': {\n...         'd': 'herm',\n...         'e': None,\n...         'falsey_dict': {},\n...         'falsey_list': [],\n...         'falsey_string': '',\n...         'is_false': False,\n...     },\n...     }\n...\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; print(d)\nJsonObj(**{\n    'a': None,\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; print(d.filter_false())\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False}\n})\n&gt;&gt;&gt; print(d.filter_false(recursive=True))\nJsonObj(**{\n    'b': 2, 'c': {'d': 'herm'}\n})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.filter_false(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recurse into sub JsonObjs and dictionaries</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.filter_none","title":"filter_none","text":"<pre><code>filter_none(*, recursive: bool = False) -&gt; JsonObj[_VT]\n</code></pre> <p>Filter key-values where the value is <code>None</code> but not false-y</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObj[_VT]</code>           \u2013            <p>JsonObj that has been filtered of None values</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\n...     'falsey_dict': {},\n...     'falsey_list': [],\n...     'falsey_string': '',\n...     'is_false': False,\n...     'a': None,\n...     'b': 2,\n...     'c': {\n...         'd': 'herm',\n...         'e': None,\n...         'falsey_dict': {},\n...         'falsey_list': [],\n...         'falsey_string': '',\n...         'is_false': False,\n...     },\n...     }\n...\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; print(d)\nJsonObj(**{\n    'a': None,\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; print(d.filter_none())\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; print(d.filter_none(recursive=True))\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.filter_none(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively filter out None values</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[_KT, _VT]) -&gt; JsonObj[_VT]\n</code></pre> <p>Return a JsonObj object from a dictionary of data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: bytes | str) -&gt; JsonObj[_VT]\n</code></pre> <p>Return a JsonObj object from a json string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObjT</code> (              <code>JsonObj[_VT]</code> )          \u2013            <p>JsonObj object for the given JSON string</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.from_json(json_string)","title":"<code>json_string</code>","text":"(<code>str</code>)           \u2013            <p>JSON string to convert to a JsonObj</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.items","title":"items","text":"<pre><code>items() -&gt; ItemsView[_KT, _VT]\n</code></pre> <p>Return an items view of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.keys","title":"keys","text":"<pre><code>keys() -&gt; KeysView[_KT]\n</code></pre> <p>Return the keys view of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.recurse","title":"recurse","text":"<pre><code>recurse() -&gt; None\n</code></pre> <p>Recursively convert all sub dictionaries to JsonObj objects</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify","title":"stringify","text":"<pre><code>stringify(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.stringify(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[_KT, Any]\n</code></pre> <p>Return the JsonObj object (and children) as a python dictionary</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json","title":"to_json","text":"<pre><code>to_json(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_json(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.to_str","title":"to_str","text":"<pre><code>to_str(\n    *, minify: bool = False, width: int | None = None\n) -&gt; str\n</code></pre> <p>Return a string representation of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonDict.validate_type","title":"validate_type  <code>classmethod</code>","text":"<pre><code>validate_type(val: Any) -&gt; JsonObj[_VT]\n</code></pre> <p>Validate and convert a value to a JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj","title":"JsonObj","text":"<pre><code>JsonObj(*args: dict[_KT, _VT])\n</code></pre><pre><code>JsonObj(*args: dict[_KT, _VT], **kwargs: _VT)\n</code></pre><pre><code>JsonObj(*args: Mapping[_KT, _VT])\n</code></pre><pre><code>JsonObj(*args: Mapping[_KT, _VT], **kwargs: _VT)\n</code></pre> <pre><code>JsonObj(*args: Any, **kwargs: _VT)\n</code></pre> <p>               Bases: <code>MutableMapping[str, _VT]</code>, <code>Generic[_VT]</code></p> <p>JSON friendly python dictionary with dot notation and string only keys</p> <p>JsonObj(foo='bar')['foo'] == JsonObj(foo='bar').foo</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; print(JsonObj())\nJsonObj(**{})\n&gt;&gt;&gt; d = {\"uno\": 1, \"dos\": 2, \"tres\": 3}\n&gt;&gt;&gt; d\n{'uno': 1, 'dos': 2, 'tres': 3}\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 1, 'dos': 2, 'tres': 3})\n&gt;&gt;&gt; list(d.keys())\n['uno', 'dos', 'tres']\n&gt;&gt;&gt; list(d.dot_keys())\n[('uno',), ('dos',), ('tres',)]\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 1, 'dos': 2, 'tres': 3})\n&gt;&gt;&gt; d['uno']\n1\n&gt;&gt;&gt; d.uno\n1\n&gt;&gt;&gt; d['uno'] == d.uno\nTrue\n&gt;&gt;&gt; d.uno = \"ONE\"\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'dos': 2, 'tres': 3})\n&gt;&gt;&gt; d['uno'] == d.uno\nTrue\n&gt;&gt;&gt; 'uno' in d\nTrue\n&gt;&gt;&gt; 'not_in_d' in d\nFalse\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'dos': 2, 'tres': 3})\n&gt;&gt;&gt; del d['dos']\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'tres': 3})\n&gt;&gt;&gt; d.tres\n3\n&gt;&gt;&gt; del d.tres\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE'})\n&gt;&gt;&gt; d = {\"uno\": 1, \"dos\": 2, \"tres\": {\"a\": 1, \"b\": [3, 4, 5, 6]}}\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 1, 'dos': 2, 'tres': {'a': 1, 'b': [3, 4, 5, 6]}})\n&gt;&gt;&gt; d.tres\nJsonObj(**{'a': 1, 'b': [3, 4, 5, 6]})\n&gt;&gt;&gt; d.tres.a\n1\n&gt;&gt;&gt; d.tres.a = \"new-val\"\n&gt;&gt;&gt; d.tres.a\n'new-val'\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 1, 'dos': 2, 'tres': {'a': 'new-val', 'b': [3, 4, 5, 6]}})\n&gt;&gt;&gt; jd = JsonObj({\"a\":1, \"b\": 'herm', 'alist':[{'sub': 123}]})\n</code></pre> <p>It does lists!? oh my</p> <pre><code>&gt;&gt;&gt; jd\nJsonObj(**{'a': 1, 'b': 'herm', 'alist': [{'sub': 123}]})\n&gt;&gt;&gt; jd.alist[0]\nJsonObj(**{'sub': 123})\n&gt;&gt;&gt; jd.eject()\n{'a': 1, 'b': 'herm', 'alist': [{'sub': 123}]}\n</code></pre> <p>Methods:</p> <ul> <li> <code>JSON</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>asdict</code>             \u2013              <p>Return the JsonObj object (and children) as a python dictionary</p> </li> <li> <code>dot_items</code>             \u2013              <p>Yield tuples of the form (dot-key, value)</p> </li> <li> <code>dot_items_list</code>             \u2013              <p>Return list of tuples of the form (dot-key, value)</p> </li> <li> <code>dot_keys</code>             \u2013              <p>Yield the JsonObj's dot-notation keys</p> </li> <li> <code>dot_keys_list</code>             \u2013              <p>Return a list of the JsonObj's dot-notation friendly keys</p> </li> <li> <code>dot_keys_set</code>             \u2013              <p>Return a set of the JsonObj's dot-notation friendly keys</p> </li> <li> <code>dot_lookup</code>             \u2013              <p>Look up JsonObj keys using dot notation as a string</p> </li> <li> <code>eject</code>             \u2013              <p>Eject to python-builtin dictionary object</p> </li> <li> <code>entries</code>             \u2013              <p>Alias for items</p> </li> <li> <code>filter_false</code>             \u2013              <p>Filter key-values where the value is false-y</p> </li> <li> <code>filter_none</code>             \u2013              <p>Filter key-values where the value is <code>None</code> but not false-y</p> </li> <li> <code>from_dict</code>             \u2013              <p>Return a JsonObj object from a dictionary of data</p> </li> <li> <code>from_json</code>             \u2013              <p>Return a JsonObj object from a json string</p> </li> <li> <code>items</code>             \u2013              <p>Return an items view of the JsonObj object</p> </li> <li> <code>keys</code>             \u2013              <p>Return the keys view of the JsonObj object</p> </li> <li> <code>recurse</code>             \u2013              <p>Recursively convert all sub dictionaries to JsonObj objects</p> </li> <li> <code>stringify</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>to_dict</code>             \u2013              <p>Return the JsonObj object (and children) as a python dictionary</p> </li> <li> <code>to_json</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>to_str</code>             \u2013              <p>Return a string representation of the JsonObj object</p> </li> <li> <code>validate_type</code>             \u2013              <p>Validate and convert a value to a JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON","title":"JSON","text":"<pre><code>JSON(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.JSON(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict[_KT, Any]\n</code></pre> <p>Return the JsonObj object (and children) as a python dictionary</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_items","title":"dot_items","text":"<pre><code>dot_items() -&gt; Iterator[tuple[tuple[str, ...], _VT]]\n</code></pre> <p>Yield tuples of the form (dot-key, value)</p> OG-version <p>def dot_items(self) -&gt; Iterator[tuple[str, Any]]:     return ((dk, self.dot_lookup(dk)) for dk in self.dot_keys())</p> Readable-version <p>for k, value in self.items():     value = jsonify(value)     if isinstance(value, JsonObj) or hasattr(value, 'dot_items'):         yield from ((f\"{k}.{dk}\", dv) for dk, dv in value.dot_items())     else:         yield k, value</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_items_list","title":"dot_items_list","text":"<pre><code>dot_items_list() -&gt; list[tuple[tuple[str, ...], Any]]\n</code></pre> <p>Return list of tuples of the form (dot-key, value)</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_keys","title":"dot_keys","text":"<pre><code>dot_keys() -&gt; Iterable[tuple[str, ...]]\n</code></pre> <p>Yield the JsonObj's dot-notation keys</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, ...]]</code>           \u2013            <p>Iterable[str]: List of the dot-notation friendly keys</p> </li> </ul> <p>The Non-chain version (shown below) is very slightly slower than the <code>itertools.chain</code> version.</p> <p>NON-CHAIN VERSION:</p> <p>for k, value in self.items():     value = jsonify(value)     if isinstance(value, JsonObj):         yield from (f\"{k}.{dk}\" for dk in value.dot_keys())     else:         yield k</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_keys_list","title":"dot_keys_list","text":"<pre><code>dot_keys_list(\n    *, sort_keys: bool = False\n) -&gt; list[tuple[str, ...]]\n</code></pre> <p>Return a list of the JsonObj's dot-notation friendly keys</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[str, ...]]</code>           \u2013            <p>list[str]: List of the dot-notation friendly keys</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_keys_list(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to have the dot-keys be returned sorted</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_keys_set","title":"dot_keys_set","text":"<pre><code>dot_keys_set() -&gt; set[tuple[str, ...]]\n</code></pre> <p>Return a set of the JsonObj's dot-notation friendly keys</p> <p>Returns:</p> <ul> <li> <code>set[tuple[str, ...]]</code>           \u2013            <p>set[str]: List of the dot-notation friendly keys</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_lookup","title":"dot_lookup","text":"<pre><code>dot_lookup(key: str | tuple[str, ...] | list[str]) -&gt; Any\n</code></pre> <p>Look up JsonObj keys using dot notation as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The result of the dot-notation key look up</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>Raised if the dot-key is not in in the object</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raised if key is not a str/Tuple[str, ...]/list[str]</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.dot_lookup(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>dot-notation key to look up ('key1.key2.third_key')</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.eject","title":"eject","text":"<pre><code>eject() -&gt; dict[_KT, _VT]\n</code></pre> <p>Eject to python-builtin dictionary object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = JsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; plain_ol_dict = d.eject()\n&gt;&gt;&gt; plain_ol_dict\n{'uno': 'ONE', 'tres': 3, 'dos': 2}\n&gt;&gt;&gt; type(plain_ol_dict)\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.entries","title":"entries","text":"<pre><code>entries() -&gt; ItemsView[_KT, _VT]\n</code></pre> <p>Alias for items</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.filter_false","title":"filter_false","text":"<pre><code>filter_false(*, recursive: bool = False) -&gt; JsonObj[_VT]\n</code></pre> <p>Filter key-values where the value is false-y</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObj[_VT]</code>           \u2013            <p>JsonObj that has been filtered</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\n...     'falsey_dict': {},\n...     'falsey_list': [],\n...     'falsey_string': '',\n...     'is_false': False,\n...     'a': None,\n...     'b': 2,\n...     'c': {\n...         'd': 'herm',\n...         'e': None,\n...         'falsey_dict': {},\n...         'falsey_list': [],\n...         'falsey_string': '',\n...         'is_false': False,\n...     },\n...     }\n...\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; print(d)\nJsonObj(**{\n    'a': None,\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; print(d.filter_false())\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False}\n})\n&gt;&gt;&gt; print(d.filter_false(recursive=True))\nJsonObj(**{\n    'b': 2, 'c': {'d': 'herm'}\n})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.filter_false(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recurse into sub JsonObjs and dictionaries</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.filter_none","title":"filter_none","text":"<pre><code>filter_none(*, recursive: bool = False) -&gt; JsonObj[_VT]\n</code></pre> <p>Filter key-values where the value is <code>None</code> but not false-y</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObj[_VT]</code>           \u2013            <p>JsonObj that has been filtered of None values</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\n...     'falsey_dict': {},\n...     'falsey_list': [],\n...     'falsey_string': '',\n...     'is_false': False,\n...     'a': None,\n...     'b': 2,\n...     'c': {\n...         'd': 'herm',\n...         'e': None,\n...         'falsey_dict': {},\n...         'falsey_list': [],\n...         'falsey_string': '',\n...         'is_false': False,\n...     },\n...     }\n...\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; print(d)\nJsonObj(**{\n    'a': None,\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; print(d.filter_none())\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; print(d.filter_none(recursive=True))\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.filter_none(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively filter out None values</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[_KT, _VT]) -&gt; JsonObj[_VT]\n</code></pre> <p>Return a JsonObj object from a dictionary of data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: bytes | str) -&gt; JsonObj[_VT]\n</code></pre> <p>Return a JsonObj object from a json string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObjT</code> (              <code>JsonObj[_VT]</code> )          \u2013            <p>JsonObj object for the given JSON string</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.from_json(json_string)","title":"<code>json_string</code>","text":"(<code>str</code>)           \u2013            <p>JSON string to convert to a JsonObj</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.items","title":"items","text":"<pre><code>items() -&gt; ItemsView[_KT, _VT]\n</code></pre> <p>Return an items view of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.keys","title":"keys","text":"<pre><code>keys() -&gt; KeysView[_KT]\n</code></pre> <p>Return the keys view of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.recurse","title":"recurse","text":"<pre><code>recurse() -&gt; None\n</code></pre> <p>Recursively convert all sub dictionaries to JsonObj objects</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify","title":"stringify","text":"<pre><code>stringify(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.stringify(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[_KT, Any]\n</code></pre> <p>Return the JsonObj object (and children) as a python dictionary</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json","title":"to_json","text":"<pre><code>to_json(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_json(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.to_str","title":"to_str","text":"<pre><code>to_str(\n    *, minify: bool = False, width: int | None = None\n) -&gt; str\n</code></pre> <p>Return a string representation of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.JsonObj.validate_type","title":"validate_type  <code>classmethod</code>","text":"<pre><code>validate_type(val: Any) -&gt; JsonObj[_VT]\n</code></pre> <p>Validate and convert a value to a JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.rm_js_comments","title":"rm_js_comments","text":"<pre><code>rm_js_comments(string: str) -&gt; str\n</code></pre> <p>Rejects/regex that removes js/ts/json style comments</p> <p>Source (stackoverflow):     https://stackoverflow.com/a/18381470</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic","title":"pydantic","text":"<p>JSONBourne + Pydantic</p> <p>Classes:</p> <ul> <li> <code>JsonBaseConfig</code>           \u2013            <p>Pydantic v1 model config class for JsonBaseModel; can be overridden</p> </li> <li> <code>JsonBaseModel</code>           \u2013            <p>Hybrid <code>pydantic.BaseModel</code> and <code>jsonbourne.JsonObj</code></p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseConfig","title":"JsonBaseConfig","text":"<p>Pydantic v1 model config class for JsonBaseModel; can be overridden</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel","title":"JsonBaseModel","text":"<pre><code>JsonBaseModel(*args: dict[_KT, _VT])\n</code></pre><pre><code>JsonBaseModel(*args: dict[_KT, _VT], **kwargs: _VT)\n</code></pre><pre><code>JsonBaseModel(*args: Mapping[_KT, _VT])\n</code></pre><pre><code>JsonBaseModel(*args: Mapping[_KT, _VT], **kwargs: _VT)\n</code></pre> <pre><code>JsonBaseModel(*args: Any, **kwargs: _VT)\n</code></pre> <p>               Bases: <code>BaseModel</code>, <code>JsonObj</code>, <code>MutableMapping</code></p> <p>Hybrid <code>pydantic.BaseModel</code> and <code>jsonbourne.JsonObj</code></p> <p>Methods:</p> <ul> <li> <code>asdict</code>             \u2013              <p>Return the JsonObj object (and children) as a python dictionary</p> </li> <li> <code>defaults_dict</code>             \u2013              <p>Return a dictionary of non-required keys -&gt; default value(s)</p> </li> <li> <code>dict</code>             \u2013              <p>Alias for <code>model_dump</code></p> </li> <li> <code>dot_items</code>             \u2013              <p>Yield tuples of the form (dot-key, value)</p> </li> <li> <code>dot_items_list</code>             \u2013              <p>Return list of tuples of the form (dot-key, value)</p> </li> <li> <code>dot_keys</code>             \u2013              <p>Yield the JsonObj's dot-notation keys</p> </li> <li> <code>dot_keys_list</code>             \u2013              <p>Return a list of the JsonObj's dot-notation friendly keys</p> </li> <li> <code>dot_keys_set</code>             \u2013              <p>Return a set of the JsonObj's dot-notation friendly keys</p> </li> <li> <code>dot_lookup</code>             \u2013              <p>Look up JsonObj keys using dot notation as a string</p> </li> <li> <code>eject</code>             \u2013              <p>Eject to python-builtin dictionary object</p> </li> <li> <code>entries</code>             \u2013              <p>Alias for items</p> </li> <li> <code>filter_false</code>             \u2013              <p>Filter key-values where the value is false-y</p> </li> <li> <code>filter_none</code>             \u2013              <p>Filter key-values where the value is <code>None</code> but not false-y</p> </li> <li> <code>from_dict</code>             \u2013              <p>Return a JsonObj object from a dictionary of data</p> </li> <li> <code>from_dict_filtered</code>             \u2013              <p>Create class from dict filtering keys not in (sub)class' fields</p> </li> <li> <code>from_json</code>             \u2013              <p>Return a JsonObj object from a json string</p> </li> <li> <code>has_required_fields</code>             \u2013              <p>Return True/False if the (sub)class has any fields that are required</p> </li> <li> <code>is_default</code>             \u2013              <p>Check if the object is equal to the default value for its fields</p> </li> <li> <code>items</code>             \u2013              <p>Return an items view of the JsonObj object</p> </li> <li> <code>json</code>             \u2013              <p>Alias for <code>model_dumps</code></p> </li> <li> <code>keys</code>             \u2013              <p>Return the keys view of the JsonObj object</p> </li> <li> <code>recurse</code>             \u2013              <p>Recursively convert all sub dictionaries to JsonObj objects</p> </li> <li> <code>stringify</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>to_dict</code>             \u2013              <p>Eject and return object as plain jane dictionary</p> </li> <li> <code>to_dict_filter_defaults</code>             \u2013              <p>Eject object and filter key-values equal to (sub)class' default</p> </li> <li> <code>to_dict_filter_none</code>             \u2013              <p>Eject object and filter key-values equal to (sub)class' default</p> </li> <li> <code>to_json</code>             \u2013              <p>Return JSON string of the JsonObj object (and children)</p> </li> <li> <code>to_json_dict</code>             \u2013              <p>Eject object and sub-objects to <code>jsonbourne.JsonObj</code></p> </li> <li> <code>to_json_obj</code>             \u2013              <p>Eject object and sub-objects to <code>jsonbourne.JsonObj</code></p> </li> <li> <code>to_json_obj_filter_defaults</code>             \u2013              <p>Eject to JsonObj and filter key-values equal to (sub)class' default</p> </li> <li> <code>to_json_obj_filter_none</code>             \u2013              <p>Eject to JsonObj and filter key-values where the value is None</p> </li> <li> <code>validate_type</code>             \u2013              <p>Validate and convert a value to a JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.asdict","title":"asdict","text":"<pre><code>asdict() -&gt; dict[_KT, Any]\n</code></pre> <p>Return the JsonObj object (and children) as a python dictionary</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.defaults_dict","title":"defaults_dict  <code>classmethod</code>","text":"<pre><code>defaults_dict() -&gt; dict[str, Any]\n</code></pre> <p>Return a dictionary of non-required keys -&gt; default value(s)</p> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: Dictionary of non-required keys -&gt; default value</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Thing(JsonBaseModel):\n...     a: int = 1\n...     b: str = \"herm\"\n...\n&gt;&gt;&gt; t = Thing()\n&gt;&gt;&gt; t\nThing(a=1, b='herm')\n&gt;&gt;&gt; t.to_dict_filter_defaults()\n{}\n&gt;&gt;&gt; t.to_json_obj_filter_defaults()\nJsonObj(**{})\n&gt;&gt;&gt; t = Thing(a=123)\n&gt;&gt;&gt; t\nThing(a=123, b='herm')\n&gt;&gt;&gt; t.to_dict_filter_defaults()\n{'a': 123}\n&gt;&gt;&gt; t.to_json_obj_filter_defaults()\nJsonObj(**{'a': 123})\n&gt;&gt;&gt; t.defaults_dict()\n{'a': 1, 'b': 'herm'}\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dict","title":"dict","text":"<pre><code>dict(*args: Any, **kwargs: Any) -&gt; dict[str, Any]\n</code></pre> <p>Alias for <code>model_dump</code></p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_items","title":"dot_items","text":"<pre><code>dot_items() -&gt; Iterator[tuple[tuple[str, ...], _VT]]\n</code></pre> <p>Yield tuples of the form (dot-key, value)</p> OG-version <p>def dot_items(self) -&gt; Iterator[tuple[str, Any]]:     return ((dk, self.dot_lookup(dk)) for dk in self.dot_keys())</p> Readable-version <p>for k, value in self.items():     value = jsonify(value)     if isinstance(value, JsonObj) or hasattr(value, 'dot_items'):         yield from ((f\"{k}.{dk}\", dv) for dk, dv in value.dot_items())     else:         yield k, value</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_items_list","title":"dot_items_list","text":"<pre><code>dot_items_list() -&gt; list[tuple[tuple[str, ...], Any]]\n</code></pre> <p>Return list of tuples of the form (dot-key, value)</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_keys","title":"dot_keys","text":"<pre><code>dot_keys() -&gt; Iterable[tuple[str, ...]]\n</code></pre> <p>Yield the JsonObj's dot-notation keys</p> <p>Returns:</p> <ul> <li> <code>Iterable[tuple[str, ...]]</code>           \u2013            <p>Iterable[str]: List of the dot-notation friendly keys</p> </li> </ul> <p>The Non-chain version (shown below) is very slightly slower than the <code>itertools.chain</code> version.</p> <p>NON-CHAIN VERSION:</p> <p>for k, value in self.items():     value = jsonify(value)     if isinstance(value, JsonObj):         yield from (f\"{k}.{dk}\" for dk in value.dot_keys())     else:         yield k</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_keys_list","title":"dot_keys_list","text":"<pre><code>dot_keys_list(\n    *, sort_keys: bool = False\n) -&gt; list[tuple[str, ...]]\n</code></pre> <p>Return a list of the JsonObj's dot-notation friendly keys</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[str, ...]]</code>           \u2013            <p>list[str]: List of the dot-notation friendly keys</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_keys_list(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to have the dot-keys be returned sorted</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_keys_set","title":"dot_keys_set","text":"<pre><code>dot_keys_set() -&gt; set[tuple[str, ...]]\n</code></pre> <p>Return a set of the JsonObj's dot-notation friendly keys</p> <p>Returns:</p> <ul> <li> <code>set[tuple[str, ...]]</code>           \u2013            <p>set[str]: List of the dot-notation friendly keys</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_lookup","title":"dot_lookup","text":"<pre><code>dot_lookup(key: str | tuple[str, ...] | list[str]) -&gt; Any\n</code></pre> <p>Look up JsonObj keys using dot notation as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The result of the dot-notation key look up</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>Raised if the dot-key is not in in the object</p> </li> <li> <code>ValueError</code>             \u2013            <p>Raised if key is not a str/Tuple[str, ...]/list[str]</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.dot_lookup(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>dot-notation key to look up ('key1.key2.third_key')</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.eject","title":"eject","text":"<pre><code>eject() -&gt; dict[_KT, _VT]\n</code></pre> <p>Eject to python-builtin dictionary object</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = JsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; plain_ol_dict = d.eject()\n&gt;&gt;&gt; plain_ol_dict\n{'uno': 'ONE', 'tres': 3, 'dos': 2}\n&gt;&gt;&gt; type(plain_ol_dict)\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.entries","title":"entries","text":"<pre><code>entries() -&gt; ItemsView[_KT, _VT]\n</code></pre> <p>Alias for items</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.filter_false","title":"filter_false","text":"<pre><code>filter_false(*, recursive: bool = False) -&gt; JsonObj[_VT]\n</code></pre> <p>Filter key-values where the value is false-y</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObj[_VT]</code>           \u2013            <p>JsonObj that has been filtered</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\n...     'falsey_dict': {},\n...     'falsey_list': [],\n...     'falsey_string': '',\n...     'is_false': False,\n...     'a': None,\n...     'b': 2,\n...     'c': {\n...         'd': 'herm',\n...         'e': None,\n...         'falsey_dict': {},\n...         'falsey_list': [],\n...         'falsey_string': '',\n...         'is_false': False,\n...     },\n...     }\n...\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; print(d)\nJsonObj(**{\n    'a': None,\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; print(d.filter_false())\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False}\n})\n&gt;&gt;&gt; print(d.filter_false(recursive=True))\nJsonObj(**{\n    'b': 2, 'c': {'d': 'herm'}\n})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.filter_false(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recurse into sub JsonObjs and dictionaries</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.filter_none","title":"filter_none","text":"<pre><code>filter_none(*, recursive: bool = False) -&gt; JsonObj[_VT]\n</code></pre> <p>Filter key-values where the value is <code>None</code> but not false-y</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObj[_VT]</code>           \u2013            <p>JsonObj that has been filtered of None values</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = {\n...     'falsey_dict': {},\n...     'falsey_list': [],\n...     'falsey_string': '',\n...     'is_false': False,\n...     'a': None,\n...     'b': 2,\n...     'c': {\n...         'd': 'herm',\n...         'e': None,\n...         'falsey_dict': {},\n...         'falsey_list': [],\n...         'falsey_string': '',\n...         'is_false': False,\n...     },\n...     }\n...\n&gt;&gt;&gt; d = JsonObj(d)\n&gt;&gt;&gt; print(d)\nJsonObj(**{\n    'a': None,\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; print(d.filter_none())\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'e': None,\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; print(d.filter_none(recursive=True))\nJsonObj(**{\n    'b': 2,\n    'c': {'d': 'herm',\n          'falsey_dict': {},\n          'falsey_list': [],\n          'falsey_string': '',\n          'is_false': False},\n    'falsey_dict': {},\n    'falsey_list': [],\n    'falsey_string': '',\n    'is_false': False\n})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.filter_none(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively filter out None values</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(data: dict[_KT, _VT]) -&gt; JsonObj[_VT]\n</code></pre> <p>Return a JsonObj object from a dictionary of data</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.from_dict_filtered","title":"from_dict_filtered  <code>classmethod</code>","text":"<pre><code>from_dict_filtered(\n    dictionary: dict[str, Any],\n) -&gt; JsonBaseModelT\n</code></pre> <p>Create class from dict filtering keys not in (sub)class' fields</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json_string: bytes | str) -&gt; JsonObj[_VT]\n</code></pre> <p>Return a JsonObj object from a json string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>JsonObjT</code> (              <code>JsonObj[_VT]</code> )          \u2013            <p>JsonObj object for the given JSON string</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.from_json(json_string)","title":"<code>json_string</code>","text":"(<code>str</code>)           \u2013            <p>JSON string to convert to a JsonObj</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.has_required_fields","title":"has_required_fields  <code>classmethod</code>","text":"<pre><code>has_required_fields() -&gt; bool\n</code></pre> <p>Return True/False if the (sub)class has any fields that are required</p> <p>Returns:</p> <ul> <li> <code>bool</code> (              <code>bool</code> )          \u2013            <p>True if any fields for a (sub)class are required</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.is_default","title":"is_default","text":"<pre><code>is_default() -&gt; bool\n</code></pre> <p>Check if the object is equal to the default value for its fields</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if object is equal to the default value for all fields; False otherwise</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Thing(JsonBaseModel):\n...    a: int = 1\n...    b: str = 'b'\n...\n&gt;&gt;&gt; t = Thing()\n&gt;&gt;&gt; t.is_default()\nTrue\n&gt;&gt;&gt; t = Thing(a=2)\n&gt;&gt;&gt; t.is_default()\nFalse\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.items","title":"items","text":"<pre><code>items() -&gt; ItemsView[_KT, _VT]\n</code></pre> <p>Return an items view of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.json","title":"json","text":"<pre><code>json(*args: Any, **kwargs: Any) -&gt; str\n</code></pre> <p>Alias for <code>model_dumps</code></p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.keys","title":"keys","text":"<pre><code>keys() -&gt; KeysView[_KT]\n</code></pre> <p>Return the keys view of the JsonObj object</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.recurse","title":"recurse","text":"<pre><code>recurse() -&gt; None\n</code></pre> <p>Recursively convert all sub dictionaries to JsonObj objects</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify","title":"stringify","text":"<pre><code>stringify(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.stringify(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_dict","title":"to_dict","text":"<pre><code>to_dict() -&gt; dict[str, Any]\n</code></pre> <p>Eject and return object as plain jane dictionary</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_dict_filter_defaults","title":"to_dict_filter_defaults","text":"<pre><code>to_dict_filter_defaults() -&gt; dict[str, Any]\n</code></pre> <p>Eject object and filter key-values equal to (sub)class' default</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class Thing(JsonBaseModel):\n...     a: int = 1\n...     b: str = \"herm\"\n...\n&gt;&gt;&gt; t = Thing()\n&gt;&gt;&gt; t\nThing(a=1, b='herm')\n&gt;&gt;&gt; t.to_dict_filter_defaults()\n{}\n&gt;&gt;&gt; t.to_json_obj_filter_defaults()\nJsonObj(**{})\n&gt;&gt;&gt; t = Thing(a=123)\n&gt;&gt;&gt; t\nThing(a=123, b='herm')\n&gt;&gt;&gt; t.to_dict_filter_defaults()\n{'a': 123}\n&gt;&gt;&gt; t.to_json_obj_filter_defaults()\nJsonObj(**{'a': 123})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_dict_filter_none","title":"to_dict_filter_none","text":"<pre><code>to_dict_filter_none() -&gt; dict[str, Any]\n</code></pre> <p>Eject object and filter key-values equal to (sub)class' default</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from typing import Optional\n&gt;&gt;&gt; class Thing(JsonBaseModel):\n...     a: int = 1\n...     b: str = \"herm\"\n...     c: Optional[str] = None\n...\n&gt;&gt;&gt; t = Thing()\n&gt;&gt;&gt; t\nThing(a=1, b='herm', c=None)\n&gt;&gt;&gt; t.to_dict_filter_none()\n{'a': 1, 'b': 'herm'}\n&gt;&gt;&gt; t.to_json_obj_filter_none()\nJsonObj(**{'a': 1, 'b': 'herm'})\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json","title":"to_json","text":"<pre><code>to_json(\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    **kwargs: Any,\n) -&gt; str\n</code></pre> <p>Return JSON string of the JsonObj object (and children)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>JSON string of the JsonObj object</p> </li> </ul>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return a JSON string with newlines and indentation</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort dictionary keys if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline 'n' to JSON string if True</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook for JSON serialization</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional kwargs to be passed down to jsonlib.dumps</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json_dict","title":"to_json_dict","text":"<pre><code>to_json_dict() -&gt; JsonObj[Any]\n</code></pre> <p>Eject object and sub-objects to <code>jsonbourne.JsonObj</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = JsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; plain_ol_dict = d.eject()\n&gt;&gt;&gt; plain_ol_dict\n{'uno': 'ONE', 'tres': 3, 'dos': 2}\n&gt;&gt;&gt; type(plain_ol_dict)\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json_obj","title":"to_json_obj","text":"<pre><code>to_json_obj() -&gt; JsonObj[Any]\n</code></pre> <p>Eject object and sub-objects to <code>jsonbourne.JsonObj</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = JsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; d\nJsonObj(**{'uno': 'ONE', 'tres': 3, 'dos': 2})\n&gt;&gt;&gt; plain_ol_dict = d.eject()\n&gt;&gt;&gt; plain_ol_dict\n{'uno': 'ONE', 'tres': 3, 'dos': 2}\n&gt;&gt;&gt; type(plain_ol_dict)\n&lt;class 'dict'&gt;\n</code></pre>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json_obj_filter_defaults","title":"to_json_obj_filter_defaults","text":"<pre><code>to_json_obj_filter_defaults() -&gt; JsonObj[Any]\n</code></pre> <p>Eject to JsonObj and filter key-values equal to (sub)class' default</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.to_json_obj_filter_none","title":"to_json_obj_filter_none","text":"<pre><code>to_json_obj_filter_none() -&gt; JsonObj[Any]\n</code></pre> <p>Eject to JsonObj and filter key-values where the value is None</p>"},{"location":"libs/jsonbourne/jsonbourne.api/#jsonbourne.pydantic.JsonBaseModel.validate_type","title":"validate_type  <code>classmethod</code>","text":"<pre><code>validate_type(val: Any) -&gt; JsonObj[_VT]\n</code></pre> <p>Validate and convert a value to a JsonObj object</p>"},{"location":"libs/lager/","title":"lager","text":"In\u00a0[1]: Copied! <pre>from lager import LOG  # All the same object\n\nLOG.info(\"info\")\n</pre> from lager import LOG  # All the same object  LOG.info(\"info\") <pre>2020-07-09 16:57:10.653 | INFO     | __main__:&lt;module&gt;:2 - info\n2020-07-09 16:57:10.655 | INFO     | __main__:&lt;module&gt;:3 - info\n</pre>"},{"location":"libs/lager/#lager","title":"lager\u00b6","text":"<p>Install: <code>pip install lager</code></p> <p>Logging library based off of loguru (<code>pip install loguru</code>).</p> <p>Why not just use loguru?</p> <ul> <li>Lager is a better pun</li> <li>Lager is really a utility pack for loguru</li> </ul> <p>BTW: Loguru is an amazing lib. Check it out: https://github.com/Delgan/loguru</p>"},{"location":"libs/lager/#usage","title":"Usage:\u00b6","text":""},{"location":"libs/listless/listless.api/","title":"listless","text":""},{"location":"libs/listless/listless.api/#listless","title":"listless","text":"<p>Listless = generators, iterators, and async iterators, Oh My!</p> <p>Functions:</p> <ul> <li> <code>aiterable</code>             \u2013              <p>Convert any-iterable to an async iterator</p> </li> <li> <code>chunk</code>             \u2013              <p>Yield chunks of size n from an iterable/sequence/collection</p> </li> <li> <code>chunks</code>             \u2013              <p>Yield chunks of something slice-able with length &lt;= chunk_size</p> </li> <li> <code>chunkseq</code>             \u2013              <p>Yield chunks of size n from a Sequence</p> </li> <li> <code>chunkstr</code>             \u2013              <p>Yield chunks of size n from a string</p> </li> <li> <code>enumerate_async</code>             \u2013              <p>Enumerate (async) over any iterable</p> </li> <li> <code>exhaust</code>             \u2013              <p>Exhaust an iterable; useful for evaluating a map object.</p> </li> <li> <code>filter_is_none</code>             \u2013              <p>Filter values that <code>is None</code>; checkout filter_none for false-y filtering</p> </li> <li> <code>filter_none</code>             \u2013              <p>Filter <code>None</code> values from an iterable</p> </li> <li> <code>flatten</code>             \u2013              <p>Flatten possibly nested iterables of sequences to a flat list</p> </li> <li> <code>flatten_seq</code>             \u2013              <p>Flatten possibly nested iterables of sequences to a flat list</p> </li> <li> <code>flatten_strings</code>             \u2013              <p>Flatten possibly nested iterables of sequences to a list of strings</p> </li> <li> <code>is_sequence</code>             \u2013              <p>Check if an object is a sequence</p> </li> <li> <code>it_product</code>             \u2013              <p>Product of all the elements in an iterable of numbers</p> </li> <li> <code>itlen</code>             \u2013              <p>Return the length/num-items in an iterable</p> </li> <li> <code>list_async</code>             \u2013              <p>Consume any iterable (async/sync) and return as a list</p> </li> <li> <code>next_async</code>             \u2013              <p>Return the next item of any iterator/iterable (sync or async</p> </li> <li> <code>nyield</code>             \u2013              <p>Yield the first n items of an iterable</p> </li> <li> <code>pairs</code>             \u2013              <p>Yield pairs of adjacent elements</p> </li> <li> <code>partition</code>             \u2013              <p>Partition an iterable into chunks of size n</p> </li> <li> <code>set_async</code>             \u2013              <p>Consume any iterable (async/sync) and return as a list</p> </li> <li> <code>spliterable</code>             \u2013              <p>1 generator + True/False-function =&gt; 2 generators (True-gen, False-gen)</p> </li> <li> <code>unique</code>             \u2013              <p>Alias for unique_gen</p> </li> <li> <code>unique_gen</code>             \u2013              <p>Yield unique values (ordered) from an iterable</p> </li> <li> <code>xmap</code>             \u2013              <p>Apply a function to each element of an iterable immediately</p> </li> <li> <code>zip_async</code>             \u2013              <p>Async version of builtin zip function</p> </li> </ul>"},{"location":"libs/listless/listless.api/#listless.aiterable","title":"aiterable","text":"<pre><code>aiterable(\n    it: Iterable[_T] | AsyncIterable[_T],\n) -&gt; AsyncIterator[_T]\n</code></pre> <p>Convert any-iterable to an async iterator</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; plain_jane_list = list(range(10))\n&gt;&gt;&gt; async def consume_aiterable(it):\n...     stuff = []\n...     async for el in aiterable(it):\n...         stuff.append(el)\n...     return stuff\n&gt;&gt;&gt; run(consume_aiterable(plain_jane_list))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; async def async_gen():\n...     for b in range(10):\n...        yield b\n&gt;&gt;&gt; run(consume_aiterable(async_gen()))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(consume_aiterable(AsyncIterable()))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.chunk","title":"chunk","text":"<pre><code>chunk(\n    it: Sequence[_T] | Collection[_T], n: int\n) -&gt; Iterable[Sequence[_T] | Collection[_T] | str]\n</code></pre> <p>Yield chunks of size n from an iterable/sequence/collection</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(chunk([1, 2, 3, 4, 5, 6], 3))\n[[1, 2, 3], [4, 5, 6]]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.chunks","title":"chunks","text":"<pre><code>chunks(it: str, chunk_size: int) -&gt; Iterable[str]\n</code></pre><pre><code>chunks(it: list[_T], chunk_size: int) -&gt; Iterable[list[_T]]\n</code></pre><pre><code>chunks(\n    it: Sequence[_T], chunk_size: int\n) -&gt; Iterable[Sequence[_T]]\n</code></pre><pre><code>chunks(\n    it: Collection[_T], chunk_size: int\n) -&gt; Iterable[Collection[_T]]\n</code></pre> <pre><code>chunks(\n    it: Sequence[_T] | Collection[_T], chunk_size: int\n) -&gt; Iterable[Sequence[_T] | Collection[_T] | str]\n</code></pre> <p>Yield chunks of something slice-able with length &lt;= chunk_size</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[Sequence[_T] | Collection[_T] | str]</code>           \u2013            <p>Iterable of the chunks</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(chunks([1, 2, 3, 4, 5, 6], 3))\n[[1, 2, 3], [4, 5, 6]]\n&gt;&gt;&gt; list(chunks([1, 2, 3, 4, 5, 6], 2))\n[[1, 2], [3, 4], [5, 6]]\n&gt;&gt;&gt; list(chunks('abcdefghijklmnopqrstuvwxyz', 13))\n['abcdefghijklm', 'nopqrstuvwxyz']\n</code></pre> <p>Can chunk where it length is not divisible by chunk_size</p> <pre><code>&gt;&gt;&gt; list(chunks('abcdefghijklmnopqrstuvwxyz', 4))\n['abcd', 'efgh', 'ijkl', 'mnop', 'qrst', 'uvwx', 'yz']\n</code></pre> <pre><code>&gt;&gt;&gt; list(chunks((el for el in range(10)), 4))\n[(0, 1, 2, 3), (4, 5, 6, 7), (8, 9)]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.chunks(it)","title":"<code>it</code>","text":"(<code>Iterable[Any]</code>)           \u2013            <p>Iterable to chunk</p>"},{"location":"libs/listless/listless.api/#listless.chunks(chunk_size)","title":"<code>chunk_size</code>","text":"(<code>int</code>)           \u2013            <p>Size of the chunks</p>"},{"location":"libs/listless/listless.api/#listless.chunkseq","title":"chunkseq","text":"<pre><code>chunkseq(\n    it: Sequence[_T], n: int\n) -&gt; Iterable[Sequence[_T]]\n</code></pre> <p>Yield chunks of size n from a Sequence</p>"},{"location":"libs/listless/listless.api/#listless.chunkstr","title":"chunkstr","text":"<pre><code>chunkstr(string: str, n: int) -&gt; Iterable[str]\n</code></pre> <p>Yield chunks of size n from a string</p>"},{"location":"libs/listless/listless.api/#listless.enumerate_async","title":"enumerate_async  <code>async</code>","text":"<pre><code>enumerate_async(\n    it: AnyIterable[_T], start: int = 0\n) -&gt; AsyncIterator[tuple[int, _T]]\n</code></pre> <p>Enumerate (async) over any iterable</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def t():\n...     return [item async for item in enumerate_async('abcde')]\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; aiorun(t())\n[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e')]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.exhaust","title":"exhaust","text":"<pre><code>exhaust(\n    it: Iterable[_T], *, maxlen: int | None = 0\n) -&gt; deque[_T]\n</code></pre> <p>Exhaust an iterable; useful for evaluating a map object.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; a_map = map(lambda x: x*2, a)\n&gt;&gt;&gt; a_exhausted = exhaust(a_map)\n&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]\n&gt;&gt;&gt; b = []\n&gt;&gt;&gt; def square_and_append_to_b(n):\n...     b.append(n**2)\n&gt;&gt;&gt; a_map = map(square_and_append_to_b, a)\n&gt;&gt;&gt; a_exhausted = exhaust(a_map)\n&gt;&gt;&gt; a_exhausted\ndeque([], maxlen=0)\n&gt;&gt;&gt; b\n[1, 4, 9, 16, 25, 36]\n&gt;&gt;&gt; another_map = map(lambda x: x*2, a)\n&gt;&gt;&gt; another_exhausted = exhaust(another_map, maxlen=2)\n&gt;&gt;&gt; another_exhausted\ndeque([10, 12], maxlen=2)\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.exhaust(it)","title":"<code>it</code>","text":"(<code>Iterable[_T]</code>)           \u2013            <p>Iterable to exhaust</p>"},{"location":"libs/listless/listless.api/#listless.exhaust(maxlen)","title":"<code>maxlen</code>","text":"(<code>int | None</code>, default:                   <code>0</code> )           \u2013            <p>Maximum length of the deque; if 0, deque is unbounded</p>"},{"location":"libs/listless/listless.api/#listless.filter_is_none","title":"filter_is_none","text":"<pre><code>filter_is_none(it: Iterable[_T | None]) -&gt; Iterable[_T]\n</code></pre> <p>Filter values that <code>is None</code>; checkout filter_none for false-y filtering</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[_T]</code>           \u2013            <p>filter object with None values excluded</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(filter_is_none([1, 2, None, 3, 4, None, 5, \"a_string???\"]))\n[1, 2, 3, 4, 5, 'a_string???']\n&gt;&gt;&gt; list(filter_is_none([-1, 0, 1, '', 's', None, [], ['s'], {}]))\n[-1, 0, 1, '', 's', [], ['s'], {}]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.filter_is_none(it)","title":"<code>it</code>","text":"(<code>Iterable[_T | None]</code>)           \u2013            <p>Iterable possibly containing None/False-y values</p>"},{"location":"libs/listless/listless.api/#listless.filter_none","title":"filter_none","text":"<pre><code>filter_none(it: Iterable[_T | None]) -&gt; Iterable[_T]\n</code></pre> <p>Filter <code>None</code> values from an iterable</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[_T]</code>           \u2013            <p>filter object with None values excluded</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(filter_none([1, 2, None, 3, 4, None, 5, \"a_string???\"]))\n[1, 2, 3, 4, 5, 'a_string???']\n&gt;&gt;&gt; list(filter_none([1, 2, '', 3, 4, None, 5, \"a_string???\", []]))\n[1, 2, 3, 4, 5, 'a_string???']\n&gt;&gt;&gt; list(filter_none([-1, 0, 1, '', 's', None, [], ['s'], {}]))\n[-1, 1, 's', ['s']]\n</code></pre> <p>This function is p simple and importing it and calling it might actually be more characters to type than just using <code>filter(None, ya_iterable)</code> but it is a fire thing to know and you can totally show off with this, also outperforms the list/gen comprehension equivalent, by quite a bit::</p> <pre><code>import random\nres = [random.randrange(1, 300, 1) for i in range(1000)]\n\nlists = [\n    res\n]\nfor i in range(40):\n    random.shuffle(res)\n    lists.append(res)\n\ndef filter_one(it):\n    return (i for i in it if i is not None)\n\ndef filter_two(it):\n    return filter(None, it)\n</code></pre> <p>Timing the first function (generator comprehension)::</p> <pre><code>%%timeit\nfor i in range(100):\n    for l in lists:\n        a = list(filter_one(l))\n\n180 ms +/- 184 \u03bcs/loop (mean +/- std. dev. of 7 runs, 10 loops each)\n</code></pre> <p>Timing the second function (filter)::</p> <pre><code>%%timeit\nfor i in range(100):\n    for l in lists:\n        a = list(filter_two(l))\n\n42.5 ms +/- 112 \u03bcs/loop (mean +/- std. dev. of 7 runs, 10 loops each)\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.filter_none(it)","title":"<code>it</code>","text":"(<code>Iterable[_T | None]</code>)           \u2013            <p>Iterable possibly containing None values</p>"},{"location":"libs/listless/listless.api/#listless.flatten","title":"flatten","text":"<pre><code>flatten(*args: _T | Iterable[_T]) -&gt; Iterable[_T]\n</code></pre> <p>Flatten possibly nested iterables of sequences to a flat list</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(flatten(\"cmd\", [\"uno\", \"dos\", \"tres\"]))\n['cmd', 'uno', 'dos', 'tres']\n&gt;&gt;&gt; list(flatten(\"cmd\", [\"uno\", \"dos\", \"tres\", [\"4444\", \"five\"]]))\n['cmd', 'uno', 'dos', 'tres', '4444', 'five']\n&gt;&gt;&gt; list(flatten(\"cmd\", [\"uno\", \"dos\", \"tres\", [\"4444\", \"five\", 123]]))\n['cmd', 'uno', 'dos', 'tres', '4444', 'five', 123]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.flatten_seq","title":"flatten_seq","text":"<pre><code>flatten_seq(\n    *args: _T | Sequence[_T], anystr: bool = False\n) -&gt; Iterable[_T]\n</code></pre> <p>Flatten possibly nested iterables of sequences to a flat list</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(flatten_seq(\"cmd\", [\"uno\", \"dos\", \"tres\"]))\n['cmd', 'uno', 'dos', 'tres']\n&gt;&gt;&gt; list(flatten_seq(\"cmd\", [\"uno\", \"dos\", \"tres\", [\"4444\", \"five\"]]))\n['cmd', 'uno', 'dos', 'tres', '4444', 'five']\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.flatten_strings","title":"flatten_strings","text":"<pre><code>flatten_strings(\n    *args: Any | Iterable[Any],\n) -&gt; Iterable[str]\n</code></pre> <p>Flatten possibly nested iterables of sequences to a list of strings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from listless import flatten_strings\n&gt;&gt;&gt; list(flatten_strings(\"cmd\", [\"uno\", \"dos\", \"tres\"]))\n['cmd', 'uno', 'dos', 'tres']\n&gt;&gt;&gt; list(flatten_strings(\"cmd\", [\"uno\", \"dos\", \"tres\", [\"4444\", \"five\", 123]]))\n['cmd', 'uno', 'dos', 'tres', '4444', 'five', '123']\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.is_sequence","title":"is_sequence","text":"<pre><code>is_sequence(seq: Any) -&gt; bool\n</code></pre> <p>Check if an object is a sequence</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_sequence([1, 2, 3])\nTrue\n&gt;&gt;&gt; is_sequence('abc')\nFalse\n&gt;&gt;&gt; is_sequence(1)\nFalse\n&gt;&gt;&gt; is_sequence(None)\nFalse\n&gt;&gt;&gt; is_sequence(True)\nFalse\n&gt;&gt;&gt; is_sequence((1, 2, 3))\nTrue\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.is_subscriptable","title":"is_subscriptable","text":"<pre><code>is_subscriptable(obj: Any) -&gt; bool\n</code></pre> <p>Check if an object is subscriptable</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_subscriptable([1, 2, 3])\nTrue\n&gt;&gt;&gt; is_subscriptable('abc')\nTrue\n&gt;&gt;&gt; is_subscriptable(1)\nFalse\n&gt;&gt;&gt; is_subscriptable(None)\nFalse\n&gt;&gt;&gt; is_subscriptable(True)\nFalse\n&gt;&gt;&gt; is_subscriptable((1, 2, 3))\nTrue\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.it_product","title":"it_product","text":"<pre><code>it_product(it: Iterable[int | float]) -&gt; int | float\n</code></pre> <p>Product of all the elements in an iterable of numbers</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | float</code>           \u2013            <p>The product of all the numbers in the iterable</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; it_product([1, 2, 3, 4])\n24\n&gt;&gt;&gt; it_product(tuple([1, 2, 3, 4]))\n24\n&gt;&gt;&gt; it_product([-1, -2, -3, 4])\n-24\n&gt;&gt;&gt; it_product([-1, -2, 3, 4, 0.5])\n12.0\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.it_product(it)","title":"<code>it</code>","text":"(<code>Iterable[int | float]</code>)           \u2013            <p>Iterable of numbers</p>"},{"location":"libs/listless/listless.api/#listless.itlen","title":"itlen","text":"<pre><code>itlen(\n    iterable: Iterable[Any], *, unique: bool = False\n) -&gt; int\n</code></pre> <p>Return the length/num-items in an iterable</p> <p>This consumes the iterable.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Length of an iterable</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; itlen(range(10))\n10\n&gt;&gt;&gt; itlen(x for x in range(1000000) if x % 3 == 0)\n333334\n&gt;&gt;&gt; l = [x for x in range(1000000) if x % 3 == 0]\n&gt;&gt;&gt; itlen(l + l, unique=True)\n333334\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.itlen(iterable)","title":"<code>iterable</code>","text":"(<code>Iterable[Any]</code>)           \u2013            <p>Iterable</p>"},{"location":"libs/listless/listless.api/#listless.itlen(unique)","title":"<code>unique</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Count unique values</p>"},{"location":"libs/listless/listless.api/#listless.list_async","title":"list_async  <code>async</code>","text":"<pre><code>list_async(itr: AnyIterable[_T]) -&gt; list[_T]\n</code></pre> <p>Consume any iterable (async/sync) and return as a list</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def t():\n...     return await list_async(range(5))\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; aiorun(t())\n[0, 1, 2, 3, 4]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.next_async","title":"next_async  <code>async</code>","text":"<pre><code>next_async(it: AnyIterator[_T]) -&gt; _T\n</code></pre> <p>Return the next item of any iterator/iterable (sync or async</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; async def async_gen():\n...     for b in range(10):\n...        yield b\n&gt;&gt;&gt; gen = async_gen()\n&gt;&gt;&gt; async def fn(gen):\n...     first = await next_async(gen)\n...     second = await next_async(gen)\n...     return first, second\n&gt;&gt;&gt; aiorun(fn(gen))\n(0, 1)\n&gt;&gt;&gt; aiorun(fn(iter(range(2))))\n(0, 1)\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.nyield","title":"nyield","text":"<pre><code>nyield(it: Sequence[_T], n: int) -&gt; Iterable[_T]\n</code></pre> <p>Yield the first n items of an iterable</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(nyield([1, 2, 3, 4, 5, 6], 3))\n[1, 2, 3]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.pairs","title":"pairs","text":"<pre><code>pairs(it: Iterable[_T]) -&gt; Iterable[tuple[_T, _T]]\n</code></pre> <p>Yield pairs of adjacent elements</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(pairs([1, 2, 3, 4]))\n[(1, 2), (2, 3), (3, 4)]\n&gt;&gt;&gt; list(pairs(['a', 'b', 'c']))\n[('a', 'b'), ('b', 'c')]\n&gt;&gt;&gt; list(pairs('abc'))\n[('a', 'b'), ('b', 'c')]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.partition","title":"partition","text":"<pre><code>partition(\n    it: Sequence[_T],\n    n: int,\n    *,\n    pad: bool = False,\n    padval: Any = None,\n) -&gt; Iterable[Sequence[_T]]\n</code></pre> <p>Partition an iterable into chunks of size n</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[Sequence[_T]]</code>           \u2013            <p>Iterable of the partitioned chunks</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(partition([1, 2, 3, 4, 5, 6], 3))\n[(1, 2, 3), (4, 5, 6)]\n&gt;&gt;&gt; list(partition([1, 2, 3, 4, 5, 6], 2))\n[(1, 2), (3, 4), (5, 6)]\n&gt;&gt;&gt; for part in partition('abcdefghijklmnopqrstuvwxyz', 13):\n...    print(part)\n('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm')\n('n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z')\n&gt;&gt;&gt; for part in partition('abcdefghijklmnopqrstuvwxyz', 4):\n...    print(part)\n('a', 'b', 'c', 'd')\n('e', 'f', 'g', 'h')\n('i', 'j', 'k', 'l')\n('m', 'n', 'o', 'p')\n('q', 'r', 's', 't')\n('u', 'v', 'w', 'x')\n&gt;&gt;&gt; for part in partition('abcdefghijklmnopqrstuvwxyz', 4, pad=True):\n...    print(part)\n('a', 'b', 'c', 'd')\n('e', 'f', 'g', 'h')\n('i', 'j', 'k', 'l')\n('m', 'n', 'o', 'p')\n('q', 'r', 's', 't')\n('u', 'v', 'w', 'x')\n('y', 'z', None, None)\n&gt;&gt;&gt; for part in partition('abcdefghijklmnopqrstuvwxyz', 4, pad=True, padval=...):\n...   print(part)\n('a', 'b', 'c', 'd')\n('e', 'f', 'g', 'h')\n('i', 'j', 'k', 'l')\n('m', 'n', 'o', 'p')\n('q', 'r', 's', 't')\n('u', 'v', 'w', 'x')\n('y', 'z', Ellipsis, Ellipsis)\n</code></pre> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>If <code>n</code> is not and int</p> </li> <li> <code>ValueError</code>             \u2013            <p>if <code>n</code> is less than 1</p> </li> </ul>"},{"location":"libs/listless/listless.api/#listless.partition(it)","title":"<code>it</code>","text":"(<code>Sequence[_T]</code>)           \u2013            <p>Iterable to partition</p>"},{"location":"libs/listless/listless.api/#listless.partition(n)","title":"<code>n</code>","text":"(<code>int</code>)           \u2013            <p>Size of the partition chunks</p>"},{"location":"libs/listless/listless.api/#listless.partition(pad)","title":"<code>pad</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Pad parts with padval if True, else do not pad</p>"},{"location":"libs/listless/listless.api/#listless.partition(padval)","title":"<code>padval</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>Value to pad with</p>"},{"location":"libs/listless/listless.api/#listless.set_async","title":"set_async  <code>async</code>","text":"<pre><code>set_async(itr: AnyIterable[_T]) -&gt; set[_T]\n</code></pre> <p>Consume any iterable (async/sync) and return as a list</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async def t():\n...     return await set_async(range(5))\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; aiorun(t())\n{0, 1, 2, 3, 4}\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.spliterable","title":"spliterable","text":"<pre><code>spliterable(\n    it: Iterable[_T], fn: Callable[[_T], bool]\n) -&gt; tuple[Iterable[_T], Iterable[_T]]\n</code></pre> <p>1 generator + True/False-function =&gt; 2 generators (True-gen, False-gen)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Iterable[_T], Iterable[_T]]</code>           \u2013            <p>tuple of generators: (gen_predicate_true, gen_predicate_false)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_even = lambda n: n % 2 == 0\n&gt;&gt;&gt; a, b = spliterable(range(10), is_even)\n&gt;&gt;&gt; list(a)\n[0, 2, 4, 6, 8]\n&gt;&gt;&gt; list(b)\n[1, 3, 5, 7, 9]\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.spliterable(it)","title":"<code>it</code>","text":"(<code>Iterable[_T]</code>)           \u2013            <p>iterable to split</p>"},{"location":"libs/listless/listless.api/#listless.spliterable(fn)","title":"<code>fn</code>","text":"(<code>Callable[[_T], bool]</code>)           \u2013            <p>Function to evaluate iterable elements and returns True or False</p>"},{"location":"libs/listless/listless.api/#listless.unique","title":"unique","text":"<pre><code>unique(\n    it: Iterable[_T], key: Callable[[_T], _K] | None = None\n) -&gt; Iterable[_T]\n</code></pre> <p>Alias for unique_gen</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; l = [*range(10), *range(10)]\n&gt;&gt;&gt; list(unique(l))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; tuple(unique(['cat', 'mouse', 'dog', 'hen'], key=len))\n('cat', 'mouse')\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.unique_gen","title":"unique_gen","text":"<pre><code>unique_gen(\n    it: Iterable[_T], key: Callable[[_T], _K] | None = None\n) -&gt; Iterable[_T]\n</code></pre> <p>Yield unique values (ordered) from an iterable</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[_T]</code>           \u2013            <p>Generator that yields unique values as they appear</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; l = [*range(10), *range(10)]\n&gt;&gt;&gt; list(unique_gen(l))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n&gt;&gt;&gt; tuple(unique_gen(['cat', 'mouse', 'dog', 'hen'], key=len))\n('cat', 'mouse')\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.unique_gen(it)","title":"<code>it</code>","text":"(<code>Iterable[_T]</code>)           \u2013            <p>Iterable</p>"},{"location":"libs/listless/listless.api/#listless.unique_gen(key)","title":"<code>key</code>","text":"(<code>Callable[[_T], _K] | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional callable to use to get the key to use for uniqueness</p>"},{"location":"libs/listless/listless.api/#listless.xmap","title":"xmap","text":"<pre><code>xmap(\n    func: Callable[[_T], _R],\n    it: Iterable[_T],\n    *,\n    maxlen: int | None = 0,\n) -&gt; deque[_R]\n</code></pre> <p>Apply a function to each element of an iterable immediately</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>deque[_R]</code>           \u2013            <p>Deque of the possible results if maxlen is greater than 0</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; xmap(lambda x: x*2, list(range(1, 7)))\ndeque([], maxlen=0)\n&gt;&gt;&gt; xmap(lambda x: x*2, list(range(1, 7)), maxlen=2)\ndeque([10, 12], maxlen=2)\n&gt;&gt;&gt; xmap(lambda x: x*2, list(range(1, 7)), maxlen=None)\ndeque([2, 4, 6, 8, 10, 12])\n</code></pre>"},{"location":"libs/listless/listless.api/#listless.xmap(func)","title":"<code>func</code>","text":"(<code>Callable[[_T], _R]</code>)           \u2013            <p>Function to apply to each element</p>"},{"location":"libs/listless/listless.api/#listless.xmap(it)","title":"<code>it</code>","text":"(<code>Iterable[_T]</code>)           \u2013            <p>iterable to apply func to</p>"},{"location":"libs/listless/listless.api/#listless.xmap(maxlen)","title":"<code>maxlen</code>","text":"(<code>int | None</code>, default:                   <code>0</code> )           \u2013            <p>Maximum length of the deque; if 0, deque is unbounded</p>"},{"location":"libs/listless/listless.api/#listless.zip_async","title":"zip_async  <code>async</code>","text":"<pre><code>zip_async(\n    *iterables: AnyIterable[Any],\n) -&gt; AsyncIterator[tuple[Any, ...]]\n</code></pre> <p>Async version of builtin zip function</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; from listless import zip_async\n&gt;&gt;&gt; from listless import list_async, iter_async  # for fake async iters\n&gt;&gt;&gt; a, b, c = iter_async(range(4)), iter_async(range(6)), iter_async(range(5))\n&gt;&gt;&gt; aiorun(list_async(zip_async(a, b, c)))\n[(0, 0, 0), (1, 1, 1), (2, 2, 2), (3, 3, 3)]\n</code></pre>"},{"location":"libs/requires/","title":"requires","text":"In\u00a0[1]: Copied! <pre># This will fail\ndef uno():\n    return json.dumps({\"a\": 1, \"b\": 2})\n\n\ntry:\n    uno()\nexcept NameError as ne:\n    print(\"Error:\", ne)\n</pre> # This will fail def uno():     return json.dumps({\"a\": 1, \"b\": 2})   try:     uno() except NameError as ne:     print(\"Error:\", ne) <pre>Error: name 'json' is not defined\n</pre> In\u00a0[2]: Copied! <pre># This will not fail\nimport requires  # Module is callable! (checkout funkify for more info -- `pip install funkify`)\n\n\n@requires(\"json\")\ndef uno():\n    return json.dumps({\"a\": 1, \"b\": 2})\n\n\nuno()\n</pre> # This will not fail import requires  # Module is callable! (checkout funkify for more info -- `pip install funkify`)   @requires(\"json\") def uno():     return json.dumps({\"a\": 1, \"b\": 2})   uno() Out[2]: <pre>'{\"a\": 1, \"b\": 2}'</pre> In\u00a0[3]: Copied! <pre>import requires\n\n\n@requires(\"from json import dumps\")\ndef uno():\n    return dumps({\"a\": 1, \"b\": 2})\n\n\nuno()\n</pre> import requires   @requires(\"from json import dumps\") def uno():     return dumps({\"a\": 1, \"b\": 2})   uno() Out[3]: <pre>'{\"a\": 1, \"b\": 2}'</pre> In\u00a0[4]: Copied! <pre>def dos():\n    return dumps({\"a\": 1, \"b\": 2})\n\n\ndos()\n</pre> def dos():     return dumps({\"a\": 1, \"b\": 2})   dos() Out[4]: <pre>'{\"a\": 1, \"b\": 2}'</pre> In\u00a0[5]: Copied! <pre>import requires\n\n\n@requires(_from=\"json\", _import=\"dumps\")\ndef dos():\n    return dumps({\"a\": 1, \"b\": 2})\n\n\ndos()\n</pre> import requires   @requires(_from=\"json\", _import=\"dumps\") def dos():     return dumps({\"a\": 1, \"b\": 2})   dos() Out[5]: <pre>'{\"a\": 1, \"b\": 2}'</pre> In\u00a0[6]: Copied! <pre>import requires\n\n\n@requires(_import=\"rapidjson\", pip=\"python-rapidjson\", conda_forge=\"python-rapidjson\")\ndef tres():\n    return rapidjson.dumps({\"a\": 1, \"b\": 2})\n\n\ntres()  # Will err if not install with where to install instructions\n</pre> import requires   @requires(_import=\"rapidjson\", pip=\"python-rapidjson\", conda_forge=\"python-rapidjson\") def tres():     return rapidjson.dumps({\"a\": 1, \"b\": 2})   tres()  # Will err if not install with where to install instructions Out[6]: <pre>'{\"a\":1,\"b\":2}'</pre> In\u00a0[7]: Copied! <pre># should error\ndef quatro():\n    return path.join(\"a\", \"b\")\n\n\ntry:\n    quatro()\nexcept NameError as ne:\n    print(\"ERROR:\", ne)\n</pre> # should error def quatro():     return path.join(\"a\", \"b\")   try:     quatro() except NameError as ne:     print(\"ERROR:\", ne) <pre>ERROR: name 'path' is not defined\n</pre> In\u00a0[10]: Copied! <pre>from requires import Requirement\n\nos_path_req = Requirement(_import=\"path\", _from=\"os\")\n\n\n@os_path_req\ndef quatro():\n    return path.join(\"a\", \"b\")\n\n\nassert isinstance(quatro(), str)\n</pre> from requires import Requirement  os_path_req = Requirement(_import=\"path\", _from=\"os\")   @os_path_req def quatro():     return path.join(\"a\", \"b\")   assert isinstance(quatro(), str) In\u00a0[18]: Copied! <pre>import requires\n\ntry:\n    import alibrary\nexcept ModuleNotFoundError:\n    requirement = requires.Requirement(\n        _import=\"alibrary\",\n        pip=True,\n        conda_forge=\"alibrary-conda-listing\",\n        details=\"Install details\",\n    )\ntry:\n    requirement.raise_error()\nexcept requires.RequirementError as err:\n    print(\"ERROR:\")\n    print(err)\n</pre> import requires  try:     import alibrary except ModuleNotFoundError:     requirement = requires.Requirement(         _import=\"alibrary\",         pip=True,         conda_forge=\"alibrary-conda-listing\",         details=\"Install details\",     ) try:     requirement.raise_error() except requires.RequirementError as err:     print(\"ERROR:\")     print(err) <pre>ERROR:\nModule/Package(s) not found/installed; could not import: `import alibrary`\n    pip install alibrary\n    conda install -c conda-forge alibrary-conda-listing\n    Install details\n</pre>"},{"location":"libs/requires/#requires","title":"requires\u00b6","text":"<p>Install: <code>pip install requires</code></p> <p>Decorate that lets you Require/Import dependencies at runtime.</p> <p>Python dependency management can be mind bottlingly complex. Optional dependencies are pretty common. Why not require the dependency at run time if a function requires said dependency?</p> <p>This package has come in handy in lambda-land where you only get 250mb (on aws)!</p>"},{"location":"libs/requires/#usage","title":"Usage:\u00b6","text":""},{"location":"libs/requires/#enforcing-requirements","title":"Enforcing requirements\u00b6","text":""},{"location":"libs/requires/#less-verbose-version","title":"Less verbose version:\u00b6","text":"<pre>import requires\n\ntry:\n    import alibrary\nexcept ModuleNotFoundError:\n    requires.Requirement(\n        _import='alibrary',\n        pip=True,\n        conda_forge='alibrary-conda-listing',\n        details=\"Install details\"\n    ).raise_error()\n</pre>"},{"location":"libs/requires/#future-ideas","title":"Future ideas?\u00b6","text":"<ul> <li>Adding support for requiring particular package versions?</li> <li>Auto install?</li> <li>Allow non pip/conda/conda-forge locations?</li> </ul>"},{"location":"libs/requires/requires.api/","title":"requires","text":""},{"location":"libs/requires/requires.api/#requires","title":"requires","text":"<p><code>requires</code> ~ dependency utils</p> <p>Modules:</p> <ul> <li> <code>core</code>           \u2013            <p>Core for requires</p> </li> <li> <code>shed</code>           \u2013            <p>Pre-fab requirements</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Requirement</code>           \u2013            <p>Requirement class to specify a package or module requirement</p> </li> <li> <code>RequirementAttributeError</code>           \u2013            <p>Requirement attribute error</p> </li> <li> <code>RequirementDict</code>           \u2013            <p>Requirement dict</p> </li> <li> <code>RequirementError</code>           \u2013            <p>Exception for requires</p> </li> <li> <code>RequirementProxy</code>           \u2013            <p>Proxy for a requirement that raises an error when called or accessed</p> </li> <li> <code>RequirementWarning</code>           \u2013            <p>Warning for requires</p> </li> <li> <code>RequirementsMeta</code>           \u2013            </li> </ul> <p>Functions:</p> <ul> <li> <code>preflight_check</code>             \u2013              <p>Scan and check calling module scope for objs/fns wrapped with requirements.</p> </li> <li> <code>requires</code>             \u2013              <p>Decorator to specify the packages a function or class requires</p> </li> <li> <code>requires_python</code>             \u2013              <p>Decorator to specify the python version a function or class requires</p> </li> <li> <code>scope_requirements</code>             \u2013              <p>Scan and check calling module scope for objs/fns wrapped with requirements.</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.Requirement","title":"Requirement  <code>dataclass</code>","text":"<pre><code>Requirement(\n    _import: str,\n    _from: str | None = None,\n    _as: str | None = None,\n    pip: str | bool | None = None,\n    conda: str | bool | None = None,\n    conda_forge: str | bool | None = None,\n    details: str | list[str] | None = None,\n    lazy: bool = True,\n)\n</code></pre> <p>Requirement class to specify a package or module requirement</p> <p>Methods:</p> <ul> <li> <code>import_requirement</code>             \u2013              <p>Import and return the requirement</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.Requirement.import_requirement","title":"import_requirement","text":"<pre><code>import_requirement() -&gt; Any\n</code></pre> <p>Import and return the requirement</p>"},{"location":"libs/requires/requires.api/#requires.RequirementAttributeError","title":"RequirementAttributeError","text":"<p>               Bases: <code>AttributeError</code></p> <p>Requirement attribute error</p>"},{"location":"libs/requires/requires.api/#requires.RequirementDict","title":"RequirementDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>Requirement dict</p>"},{"location":"libs/requires/requires.api/#requires.RequirementError","title":"RequirementError","text":"<p>               Bases: <code>ModuleNotFoundError</code></p> <p>Exception for requires</p>"},{"location":"libs/requires/requires.api/#requires.RequirementProxy","title":"RequirementProxy","text":"<pre><code>RequirementProxy(req: Requirement)\n</code></pre> <p>Proxy for a requirement that raises an error when called or accessed</p>"},{"location":"libs/requires/requires.api/#requires.RequirementWarning","title":"RequirementWarning","text":"<p>               Bases: <code>UserWarning</code></p> <p>Warning for requires</p>"},{"location":"libs/requires/requires.api/#requires.RequirementsMeta","title":"RequirementsMeta  <code>dataclass</code>","text":"<pre><code>RequirementsMeta(requirements: set[Requirement] = set())\n</code></pre> <p>Methods:</p> <ul> <li> <code>preflight_check</code>             \u2013              <p>Check if requirements are met</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.RequirementsMeta.preflight_check","title":"preflight_check","text":"<pre><code>preflight_check(\n    *,\n    warn: bool = False,\n    on_missing: Callable[[set[Requirement]], None] | None,\n) -&gt; set[Requirement]\n</code></pre> <p>Check if requirements are met</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>set[Requirement]</code>           \u2013            <p>Set[Requirement]: A set of missing requirements</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.RequirementsMeta.preflight_check(warn)","title":"<code>warn</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, issues warnings for missing requirements.</p>"},{"location":"libs/requires/requires.api/#requires.RequirementsMeta.preflight_check(on_missing)","title":"<code>on_missing</code>","text":"(<code>Optional[Callable[[Set[Requirement]], None]]</code>)           \u2013            <p>Callback to do something on missing requirements.</p>"},{"location":"libs/requires/requires.api/#requires.preflight_check","title":"preflight_check","text":"<pre><code>preflight_check(\n    *,\n    warn: bool = False,\n    on_missing: Callable[[set[Requirement]], None]\n    | None = None,\n) -&gt; RequirementsMeta\n</code></pre> <p>Scan and check calling module scope for objs/fns wrapped with requirements.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RequirementsMeta</code> (              <code>RequirementsMeta</code> )          \u2013            <p>A RequirementsMeta instance with the requirements found during the check.</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.preflight_check(warn)","title":"<code>warn</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, issues warnings for missing requirements.</p>"},{"location":"libs/requires/requires.api/#requires.preflight_check(on_missing)","title":"<code>on_missing</code>","text":"(<code>Optional[Callable[[set[Requirement]], None]]</code>, default:                   <code>None</code> )           \u2013            <p>Callback to do something on missing requirements.</p>"},{"location":"libs/requires/requires.api/#requires.requires","title":"requires","text":"<pre><code>requires(\n    *requirements: str | TRequirementDict | Requirement,\n    _import: str | None = None,\n    _as: str | None = None,\n    _from: str | None = None,\n    pip: str | bool | None = None,\n    conda: str | bool | None = None,\n    conda_forge: str | bool | None = None,\n    details: str | None = None,\n    lazy: bool | None = None,\n) -&gt; Callable[[Callable[P, R]], Callable[P, R]]\n</code></pre> <p>Decorator to specify the packages a function or class requires</p> <p>The decorator will not do anything unless a NameError is thrown. If a NameError is thrown then the required package is likely not installed and a <code>RequirementError</code> will be thrown with instructions on how to install the required packages.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Callable[[Callable[P, R]], Callable[P, R]]</code>           \u2013            <p>Function wrapped such that in the event of a <code>NameError</code> a helpful</p> </li> <li> <code>Callable[[Callable[P, R]], Callable[P, R]]</code>           \u2013            <p>error is raised.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If requirements or kwargs are given</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.requires(*requirements)","title":"<code>*requirements</code>","text":"(<code>str | TRequirementDict | Requirement</code>, default:                   <code>()</code> )           \u2013            <p>Any number of required package names as strings</p>"},{"location":"libs/requires/requires.api/#requires.requires(_import)","title":"<code>_import</code>","text":"(<code>'str'</code>, default:                   <code>None</code> )           \u2013            <p><code>IMPORT</code> part of <code>from {FROM} import {IMPORT} as {AS}</code></p>"},{"location":"libs/requires/requires.api/#requires.requires(_as)","title":"<code>_as</code>","text":"(<code>'str'</code>, default:                   <code>None</code> )           \u2013            <p><code>AS</code> part of <code>from {FROM} import {IMPORT} as {AS}</code></p>"},{"location":"libs/requires/requires.api/#requires.requires(_from)","title":"<code>_from</code>","text":"(<code>'str'</code>, default:                   <code>None</code> )           \u2013            <p><code>FROM</code> part of <code>from {FROM} import {IMPORT} as {AS}</code></p>"},{"location":"libs/requires/requires.api/#requires.requires(pip)","title":"<code>pip</code>","text":"(<code>Optional[Union[str, bool]]</code>, default:                   <code>None</code> )           \u2013            <p>pip install name</p>"},{"location":"libs/requires/requires.api/#requires.requires(conda)","title":"<code>conda</code>","text":"(<code>Optional[Union[str, bool]]</code>, default:                   <code>None</code> )           \u2013            <p>conda install name</p>"},{"location":"libs/requires/requires.api/#requires.requires(conda_forge)","title":"<code>conda_forge</code>","text":"(<code>Optional[Union[str, bool]]</code>, default:                   <code>None</code> )           \u2013            <p>conda-forge install name</p>"},{"location":"libs/requires/requires.api/#requires.requires(details)","title":"<code>details</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>details to be displayed in the error message</p>"},{"location":"libs/requires/requires.api/#requires.requires(lazy)","title":"<code>lazy</code>","text":"(<code>bool</code>, default:                   <code>None</code> )           \u2013            <p>If True, the requirement is loaded lazily</p>"},{"location":"libs/requires/requires.api/#requires.requires_python","title":"requires_python","text":"<pre><code>requires_python(version: str) -&gt; None\n</code></pre> <p>Decorator to specify the python version a function or class requires</p>"},{"location":"libs/requires/requires.api/#requires.scope_requirements","title":"scope_requirements","text":"<pre><code>scope_requirements(\n    *, debug: bool = False\n) -&gt; RequirementsMeta\n</code></pre> <p>Scan and check calling module scope for objs/fns wrapped with requirements.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>RequirementsMeta</code> (              <code>RequirementsMeta</code> )          \u2013            <p>A RequirementsMeta instance with the requirements found during the check.</p> </li> </ul>"},{"location":"libs/requires/requires.api/#requires.scope_requirements(debug)","title":"<code>debug</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, log debug info.</p>"},{"location":"libs/shellfish/shellfish.api/","title":"shellfish","text":""},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_dir","title":"is_dir","text":"<pre><code>is_dir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish","title":"shellfish","text":"<p>shellfish ~ shell and file-system utils</p> <p>Modules:</p> <ul> <li> <code>aios</code>           \u2013            <p>aios = asyncio + os</p> </li> <li> <code>aioshutil</code>           \u2013            <p>aios = asyncio + shutil</p> </li> <li> <code>batman</code>           \u2013            <p>batman = bat/cmd windows utils</p> </li> <li> <code>const</code>           \u2013            <p>Constants</p> </li> <li> <code>dev</code>           \u2013            <p>UNDER CONSTRUCTION</p> </li> <li> <code>done</code>           \u2013            </li> <li> <code>dotenv</code>           \u2013            <p>dot.env utils</p> </li> <li> <code>echo</code>           \u2013            <p>Echo/Print</p> </li> <li> <code>exe</code>           \u2013            <p>Exes/commands</p> </li> <li> <code>fs</code>           \u2013            <p>file-system utils</p> </li> <li> <code>libhash</code>           \u2013            </li> <li> <code>libsh</code>           \u2013            <p>shellfish internals</p> </li> <li> <code>osfs</code>           \u2013            <p>Os specific filesystem utils/operations</p> </li> <li> <code>process</code>           \u2013            <p>Current running process info</p> </li> <li> <code>psu</code>           \u2013            <p>psutils-utils</p> </li> <li> <code>sh</code>           \u2013            <p>shell utils</p> </li> <li> <code>sp</code>           \u2013            </li> <li> <code>stdio</code>           \u2013            <p>stdio utils</p> </li> <li> <code>testing</code>           \u2013            </li> <li> <code>tests</code>           \u2013            <p>shellfish dist tests</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Done</code>           \u2013            <p>Completed subprocess</p> </li> <li> <code>DoneError</code>           \u2013            <p>Error raised when a process returns a non-zero/ok exit status</p> </li> <li> <code>Flag</code>           \u2013            <p>Flag obj</p> </li> <li> <code>FlagMeta</code>           \u2013            <p>Meta class</p> </li> <li> <code>HrTime</code>           \u2013            <p>High resolution time</p> </li> <li> <code>LIN</code>           \u2013            <p>Linux (and Mac) shell commands/methods container</p> </li> <li> <code>Stdio</code>           \u2013            <p>Standard-io enum object</p> </li> <li> <code>WIN</code>           \u2013            <p>Windows shell commands/methods container</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>basename</code>             \u2013              <p>Return the basename of given path; alias of os.path.dirname</p> </li> <li> <code>cd</code>             \u2013              <p>Change directory to given dirpath; alias for <code>os.chdir</code></p> </li> <li> <code>chmod</code>             \u2013              <p>Change the access permissions of a file</p> </li> <li> <code>copy_file</code>             \u2013              <p>Copy a file given a source-path and a destination-path</p> </li> <li> <code>cp</code>             \u2013              <p>Copy the directory/file src to the directory/file dest</p> </li> <li> <code>decode_stdio_bytes</code>             \u2013              <p>Return Stdio bytes from stdout/stderr as a string</p> </li> <li> <code>dir_exists</code>             \u2013              <p>Return True if the given path exists; False otherwise; alias for isdir</p> </li> <li> <code>dir_exists_async</code>             \u2013              <p>Return True if the directory exists; False otherwise</p> </li> <li> <code>dirname</code>             \u2013              <p>Return dirname/parent-dir of given path; alias of os.path.dirname</p> </li> <li> <code>dirpath_gen</code>             \u2013              <p>Yield all dirpaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>dirs_gen</code>             \u2013              <p>Yield directory-paths beneath a dirpath (defaults to os.getcwd())</p> </li> <li> <code>do</code>             \u2013              <p>Run a subprocess synchronously</p> </li> <li> <code>do_async</code>             \u2013              <p>Run a subprocess and await its completion</p> </li> <li> <code>doa</code>             \u2013              <p>Run a subprocess and await its completion</p> </li> <li> <code>exists</code>             \u2013              <p>Return True if the given path exists; False otherwise</p> </li> <li> <code>export</code>             \u2013              <p>Export/Set an environment variable</p> </li> <li> <code>extension</code>             \u2013              <p>Return the extension for a fspath</p> </li> <li> <code>file_exists</code>             \u2013              <p>Return True if the given path exists; False otherwise; alias for isfile</p> </li> <li> <code>file_exists_async</code>             \u2013              <p>Return True if the file exists; False otherwise</p> </li> <li> <code>file_lines_gen</code>             \u2013              <p>Yield lines from a given fspath</p> </li> <li> <code>filecmp</code>             \u2013              <p>Compare 2 files for equality given their filepaths</p> </li> <li> <code>filepath_gen</code>             \u2013              <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>filepath_mtimedelta_sec</code>             \u2013              <p>Return the seconds since the file(path) was last modified</p> </li> <li> <code>files_dirs_gen</code>             \u2013              <p>Return a files_gen() and a dirs_gen() in one swell-foop</p> </li> <li> <code>files_gen</code>             \u2013              <p>Yield file-paths beneath a given dirpath (defaults to os.getcwd())</p> </li> <li> <code>filesize</code>             \u2013              <p>Return the size of the given file(path) in bytes</p> </li> <li> <code>filesize_async</code>             \u2013              <p>Return the size of the file at the given fspath</p> </li> <li> <code>flatten_args</code>             \u2013              <p>Flatten possibly nested iterables of sequences to a list of strings</p> </li> <li> <code>fspath</code>             \u2013              <p>Alias for os._fspath; returns fspath string for any type of path</p> </li> <li> <code>is_dir</code>             \u2013              <p>Return True if the given path is a directory; alias for isdir</p> </li> <li> <code>is_dir_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>is_file</code>             \u2013              <p>Return True if the given path is a file; alias for isfile</p> </li> <li> <code>is_file_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>is_link</code>             \u2013              <p>Return True if the given path is a link; alias for islink</p> </li> <li> <code>is_link_async</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>isdir</code>             \u2013              <p>Return True if the given path is a directory; False otherwise</p> </li> <li> <code>isdir_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>isfile</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>isfile_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>islink</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>islink_async</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>listdir_async</code>             \u2013              <p>Async version of <code>os.listdir</code></p> </li> <li> <code>listdir_gen</code>             \u2013              <p>Return an iterator of strings from DirEntries</p> </li> <li> <code>ls</code>             \u2013              <p>List files and dirs given a dirpath (defaults to pwd)</p> </li> <li> <code>ls_dirs</code>             \u2013              <p>List the directories in a given directory path</p> </li> <li> <code>ls_files</code>             \u2013              <p>List the files in a given directory path</p> </li> <li> <code>ls_files_dirs</code>             \u2013              <p>List the files and directories given directory path</p> </li> <li> <code>lstat_async</code>             \u2013              <p>Async version of <code>os.lstat</code></p> </li> <li> <code>mkdir</code>             \u2013              <p>Make directory at given fspath</p> </li> <li> <code>mkdirp</code>             \u2013              <p>Make directory and parents</p> </li> <li> <code>move</code>             \u2013              <p>Move file(s) like on the command line</p> </li> <li> <code>mv</code>             \u2013              <p>Move file(s) like on the command line</p> </li> <li> <code>path_gen</code>             \u2013              <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>pwd</code>             \u2013              <p>Return present-working-directory path string; alias for os.getcwd</p> </li> <li> <code>q</code>             \u2013              <p>Typed alias for shlex.quote</p> </li> <li> <code>quote</code>             \u2013              <p>Typed alias for shlex.quote</p> </li> <li> <code>read_bytes</code>             \u2013              <p>Read bytes from a fspath</p> </li> <li> <code>read_bytes_async</code>             \u2013              <p>(ASYNC) Load/Read bytes from a fspath</p> </li> <li> <code>read_bytes_gen</code>             \u2013              <p>Yield bytes from a given fspath</p> </li> <li> <code>read_bytes_gen_async</code>             \u2013              <p>Yield (asynchronously) bytes from a given fspath</p> </li> <li> <code>read_json</code>             \u2013              <p>Load/Read-&amp;-parse json data given a fspath</p> </li> <li> <code>read_json_async</code>             \u2013              <p>Load/Read-&amp;-parse json data given a fspath</p> </li> <li> <code>read_str</code>             \u2013              <p>Load/Read a string given a fspath</p> </li> <li> <code>read_str_async</code>             \u2013              <p>(ASYNC) Load/Read a string given a fspath</p> </li> <li> <code>rm</code>             \u2013              <p>Remove files &amp; directories in the style of the shell</p> </li> <li> <code>rm_gen</code>             \u2013              <p>Remove files &amp; directories in the style of the shell</p> </li> <li> <code>rmdir</code>             \u2013              <p>Remove directory at given fspath</p> </li> <li> <code>rmfile</code>             \u2013              <p>Remove a file at given fspath</p> </li> <li> <code>safepath</code>             \u2013              <p>Check if a file/dir path is save/unused; returns an unused path.</p> </li> <li> <code>scandir</code>             \u2013              <p>Typed version of os.scandir</p> </li> <li> <code>scandir_gen</code>             \u2013              <p>Return an iterator of os.DirEntry objects</p> </li> <li> <code>scandir_list</code>             \u2013              <p>Return a list of os.DirEntry objects</p> </li> <li> <code>sep_join</code>             \u2013              <p>Join iterable of strings on the current platform os.path.sep value</p> </li> <li> <code>sep_lstrip</code>             \u2013              <p>Left-strip a string of the current platform's os.path.sep value</p> </li> <li> <code>sep_rstrip</code>             \u2013              <p>Right-strip a string of the current platform's os.path.sep value</p> </li> <li> <code>sep_split</code>             \u2013              <p>Split a string on the current platform os.path.sep value</p> </li> <li> <code>sep_strip</code>             \u2013              <p>Strip a string of the current platform's os.path.sep value</p> </li> <li> <code>setenv</code>             \u2013              <p>Export/Set an environment variable</p> </li> <li> <code>shebang</code>             \u2013              <p>Get the shebang string given a fspath; Returns None if no shebang</p> </li> <li> <code>shell</code>             \u2013              <p>Run a subprocess synchronously in current shell</p> </li> <li> <code>shplit</code>             \u2013              <p>Typed alias for shlex.split</p> </li> <li> <code>source</code>             \u2013              <p>Execute/run a python file given a fspath and put globals in globasl</p> </li> <li> <code>stat</code>             \u2013              <p>Return the os.stat_result object for a given fspath</p> </li> <li> <code>stat_async</code>             \u2013              <p>Async version of <code>os.stat</code></p> </li> <li> <code>touch</code>             \u2013              <p>Create an empty file given a fspath</p> </li> <li> <code>tree</code>             \u2013              <p>Create a directory tree string given a directory path</p> </li> <li> <code>walk_gen</code>             \u2013              <p>Yield all paths beneath a given dirpath (defaults to os.getcwd())</p> </li> <li> <code>where</code>             \u2013              <p>Return the result of <code>shutil.which</code>; alias of shellfish.sh.which</p> </li> <li> <code>which</code>             \u2013              <p>Return the result of <code>shutil.which</code></p> </li> <li> <code>which_lru</code>             \u2013              <p>Return the result of <code>shutil.which</code> and cache the results</p> </li> <li> <code>write_bytes</code>             \u2013              <p>Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_async</code>             \u2013              <p>(ASYNC) Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_gen</code>             \u2013              <p>Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_gen_async</code>             \u2013              <p>Write/save bytes to a filepath from an (async)iterable/iterator of bytes</p> </li> <li> <code>write_json</code>             \u2013              <p>Save/Write json-serial-ize-able data to a fspath</p> </li> <li> <code>write_json_async</code>             \u2013              <p>Save/Write json-serial-ize-able data to a fspath</p> </li> <li> <code>write_str</code>             \u2013              <p>Save/Write a string to fspath</p> </li> <li> <code>write_str_async</code>             \u2013              <p>(ASYNC) Save/Write a string to fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done","title":"Done","text":"<p>               Bases: <code>_ShellfishBaseModel</code></p> <p>Completed subprocess</p> <p>Methods:</p> <ul> <li> <code>check</code>             \u2013              <p>Check returncode and stderr</p> </li> <li> <code>completed_process</code>             \u2013              <p>Return subprocess.CompletedProcess object</p> </li> <li> <code>done_dict</code>             \u2013              <p>Return Done object as typed-dict</p> </li> <li> <code>grep</code>             \u2013              <p>Return lines in stdout that have</p> </li> <li> <code>json_parse</code>             \u2013              <p>Return json parsed stdout</p> </li> <li> <code>json_parse_stderr</code>             \u2013              <p>Return json parsed stderr</p> </li> <li> <code>json_parse_stdout</code>             \u2013              <p>Return json parsed stdout</p> </li> <li> <code>parse_json</code>             \u2013              <p>Return json parsed stdout (alias bc I keep flip-flopping the fn name)</p> </li> <li> <code>sys_print</code>             \u2013              <p>Write self.stdout to sys.stdout and self.stderr to sys.stderr</p> </li> <li> <code>write_stderr</code>             \u2013              <p>Write stderr as a string to a fspath</p> </li> <li> <code>write_stdout</code>             \u2013              <p>Write stdout as a string to a fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.check","title":"check","text":"<pre><code>check(\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n) -&gt; None\n</code></pre> <p>Check returncode and stderr</p> <p>Raises:</p> <ul> <li> <code>DoneError</code>             \u2013            <p>If return code is non-zero and stderr is not None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.completed_process","title":"completed_process","text":"<pre><code>completed_process() -&gt; CompletedProcess[str]\n</code></pre> <p>Return subprocess.CompletedProcess object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.done_dict","title":"done_dict","text":"<pre><code>done_dict() -&gt; DoneDict\n</code></pre> <p>Return Done object as typed-dict</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.grep","title":"grep","text":"<pre><code>grep(string: str) -&gt; list[str]\n</code></pre> <p>Return lines in stdout that have</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of strings of stdout lines containing the given search string</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.grep(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to search for</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.json_parse","title":"json_parse","text":"<pre><code>json_parse(\n    *,\n    stderr: bool = False,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stdout</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.json_parse_stderr","title":"json_parse_stderr","text":"<pre><code>json_parse_stderr(\n    *,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.json_parse_stdout","title":"json_parse_stdout","text":"<pre><code>json_parse_stdout(\n    *,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stdout</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.parse_json","title":"parse_json","text":"<pre><code>parse_json(\n    *,\n    stderr: bool = False,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stdout (alias bc I keep flip-flopping the fn name)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.sys_print","title":"sys_print","text":"<pre><code>sys_print() -&gt; None\n</code></pre> <p>Write self.stdout to sys.stdout and self.stderr to sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.write_stderr","title":"write_stderr","text":"<pre><code>write_stderr(\n    filepath: FsPath, *, append: bool = False\n) -&gt; None\n</code></pre> <p>Write stderr as a string to a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.write_stderr(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath of location to write stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.write_stderr(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file or plain write to file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.write_stdout","title":"write_stdout","text":"<pre><code>write_stdout(\n    filepath: FsPath, *, append: bool = False\n) -&gt; None\n</code></pre> <p>Write stdout as a string to a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.write_stdout(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to write stdout to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Done.write_stdout(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file or plain write to file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.DoneError","title":"DoneError","text":"<pre><code>DoneError(done: Done)\n</code></pre> <p>               Bases: <code>SubprocessError</code></p> <p>Error raised when a process returns a non-zero/ok exit status</p> <p>Attributes:</p> <ul> <li> <code>cmd</code>               (<code>str</code>)           \u2013            <p>command that was run</p> </li> <li> <code>returncode</code>               (<code>int</code>)           \u2013            <p>exit status of the process</p> </li> <li> <code>stdout</code>               (<code>str</code>)           \u2013            <p>standard output (stdout) of the process</p> </li> <li> <code>stderr</code>               (<code>str</code>)           \u2013            <p>standard error (stderr) of the process</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Flag","title":"Flag","text":"<p>Flag obj</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Flag.__help\n'--help'\n&gt;&gt;&gt; Flag._v\n'-v'\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.FlagMeta","title":"FlagMeta","text":"<p>               Bases: <code>type</code></p> <p>Meta class</p> <p>Methods:</p> <ul> <li> <code>attr2flag</code>             \u2013              <p>Convert and return attr to string</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.FlagMeta.attr2flag","title":"attr2flag  <code>cached</code> <code>staticmethod</code>","text":"<pre><code>attr2flag(string: str) -&gt; str\n</code></pre> <p>Convert and return attr to string</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.HrTime","title":"HrTime","text":"<p>               Bases: <code>_ShellfishBaseModel</code></p> <p>High resolution time</p> <p>Methods:</p> <ul> <li> <code>from_seconds</code>             \u2013              <p>Return HrTime object from seconds</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.HrTime.from_seconds","title":"from_seconds  <code>classmethod</code>","text":"<pre><code>from_seconds(seconds: float) -&gt; HrTime\n</code></pre> <p>Return HrTime object from seconds</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>HrTime</code>           \u2013            <p>HrTime object</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.HrTime.from_seconds(seconds)","title":"<code>seconds</code>","text":"(<code>float</code>)           \u2013            <p>number of seconds</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN","title":"LIN","text":"<p>               Bases: <code>LIN</code></p> <p>Linux (and Mac) shell commands/methods container</p> <p>Methods:</p> <ul> <li> <code>link_dir</code>             \u2013              <p>Make a directory symlink</p> </li> <li> <code>link_dirs</code>             \u2013              <p>Make multiple directory symlinks</p> </li> <li> <code>link_file</code>             \u2013              <p>Make a file symlink</p> </li> <li> <code>link_files</code>             \u2013              <p>Make multiple file symlinks</p> </li> <li> <code>rsync</code>             \u2013              <p>Run an <code>rsync</code> subprocess</p> </li> <li> <code>rsync_args</code>             \u2013              <p>Return args for rsync command on linux/mac</p> </li> <li> <code>unlink_dir</code>             \u2013              <p>Unlink a directory symlink given a path to the symlink</p> </li> <li> <code>unlink_dirs</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> <li> <code>unlink_file</code>             \u2013              <p>Unlink a file symlink given a path to the symlink</p> </li> <li> <code>unlink_files</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dir","title":"link_dir  <code>staticmethod</code>","text":"<pre><code>link_dir(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a directory symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dir(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dir(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>str</code>, default:                   <code>False</code> )           \u2013            <p>Allow link to exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dirs","title":"link_dirs  <code>staticmethod</code>","text":"<pre><code>link_dirs(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple directory symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dirs(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_dirs(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow link to exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_file","title":"link_file  <code>staticmethod</code>","text":"<pre><code>link_file(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a file symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_file(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_file(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_file(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow links to already exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_files","title":"link_files  <code>staticmethod</code>","text":"<pre><code>link_files(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple file symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_files(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow links to already exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.link_files(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync","title":"rsync  <code>staticmethod</code>","text":"<pre><code>rsync(\n    src: str,\n    dest: str,\n    *,\n    delete: bool = False,\n    mkdirs: bool = False,\n    dry_run: bool = False,\n    exclude: Iterable[str] | None = None,\n    include: Iterable[str] | None = None,\n) -&gt; Done\n</code></pre> <p>Run an <code>rsync</code> subprocess</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code> (              <code>Done</code> )          \u2013            <p>Done object containing the info for the rsync run</p> </li> </ul> <p>Rsync return codes::</p> <pre><code>- 0 == Success\n- 1 == Syntax or usage error\n- 2 == Protocol incompatibility\n- 3 == Errors selecting input/output files, dirs\n- 4 == Requested  action not supported: an attempt was made to\n  manipulate 64-bit files on a platform that cannot support them;\n  or an option was specified that is supported by the client and\n  not the server.\n- 5 == Error starting client-server protocol\n- 6 == Daemon unable to append to log-file\n- 10 == Error in socket I/O\n- 11 == Error in file I/O\n- 12 == Error in rsync protocol data stream\n- 13 == Errors with program diagnostics\n- 14 == Error in IPC code\n- 20 == Received SIGUSR1 or SIGINT\n- 21 == Some error returned by waitpid()\n- 22 == Error allocating core memory buffers\n- 23 == Partial transfer due to error\n- 24 == Partial transfer due to vanished source files\n- 25 == The --max-delete limit stopped deletions\n- 30 == Timeout in data send2viewserver/receive\n- 35 == Timeout waiting for daemon connection\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(mkdirs)","title":"<code>mkdirs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make destination directories if they do not already exist; defaults to False.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source directory path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>Destination directory path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Delete files/directories in destination if they do exist in source</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(exclude)","title":"<code>exclude</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to exclude</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(include)","title":"<code>include</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to include</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Perform operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args","title":"rsync_args  <code>staticmethod</code>","text":"<pre><code>rsync_args(\n    src: str,\n    dest: str,\n    *,\n    delete: bool = False,\n    dry_run: bool = False,\n    exclude: Iterable[str] | None = None,\n    include: Iterable[str] | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return args for rsync command on linux/mac</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>subprocess return code from rsync</p> </li> </ul> <p>Rsync return codes::</p> <pre><code>- 0 == Success\n- 1 == Syntax or usage error\n- 2 == Protocol incompatibility\n- 3 == Errors selecting input/output files, dirs\n- 4 == Requested  action not supported: an attempt was made to\n  manipulate 64-bit files on a platform that cannot support them;\n  or an option was specified that is supported by the client and\n  not the server.\n- 5 == Error starting client-server protocol\n- 6 == Daemon unable to append to log-file\n- 10 == Error in socket I/O\n- 11 == Error in file I/O\n- 12 == Error in rsync protocol data stream\n- 13 == Errors with program diagnostics\n- 14 == Error in IPC code\n- 20 == Received SIGUSR1 or SIGINT\n- 21 == Some error returned by waitpid()\n- 22 == Error allocating core memory buffers\n- 23 == Partial transfer due to error\n- 24 == Partial transfer due to vanished source files\n- 25 == The --max-delete limit stopped deletions\n- 30 == Timeout in data send2viewserver/receive\n- 35 == Timeout waiting for daemon connection\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>path to remote (raid) tdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>path to local tdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag that will do a 'hard sync'</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args(exclude)","title":"<code>exclude</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to exclude</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args(include)","title":"<code>include</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to include</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.rsync_args(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Perform operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_dir","title":"unlink_dir  <code>staticmethod</code>","text":"<pre><code>unlink_dir(link: str) -&gt; None\n</code></pre> <p>Unlink a directory symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_dir(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_dirs","title":"unlink_dirs  <code>staticmethod</code>","text":"<pre><code>unlink_dirs(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_dirs(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_file","title":"unlink_file  <code>staticmethod</code>","text":"<pre><code>unlink_file(link: str) -&gt; None\n</code></pre> <p>Unlink a file symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_file(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_files","title":"unlink_files  <code>staticmethod</code>","text":"<pre><code>unlink_files(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.LIN.unlink_files(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.Stdio","title":"Stdio","text":"<p>               Bases: <code>IntEnum</code></p> <p>Standard-io enum object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN","title":"WIN","text":"<p>               Bases: <code>WIN</code></p> <p>Windows shell commands/methods container</p> <p>Methods:</p> <ul> <li> <code>link_dir</code>             \u2013              <p>Make a directory symlink</p> </li> <li> <code>link_dirs</code>             \u2013              <p>Make multiple directory symlinks</p> </li> <li> <code>link_file</code>             \u2013              <p>Make a file symlink</p> </li> <li> <code>link_files</code>             \u2013              <p>Make multiple file symlinks</p> </li> <li> <code>robocopy</code>             \u2013              <p>Robocopy wrapper function (crude in that it opens a subprocess)</p> </li> <li> <code>robocopy_args</code>             \u2013              <p>Return list of robocopy command args</p> </li> <li> <code>unlink_dir</code>             \u2013              <p>Unlink a directory symlink given a path to the symlink</p> </li> <li> <code>unlink_dirs</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> <li> <code>unlink_file</code>             \u2013              <p>Unlink a file symlink given a path to the symlink</p> </li> <li> <code>unlink_files</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dir","title":"link_dir  <code>staticmethod</code>","text":"<pre><code>link_dir(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a directory symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dir(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dir(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an exception if the link exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dirs","title":"link_dirs  <code>staticmethod</code>","text":"<pre><code>link_dirs(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple directory symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dirs(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_dirs(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an exception if the link(s) exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_file","title":"link_file  <code>staticmethod</code>","text":"<pre><code>link_file(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a file symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_file(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_file(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_file(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, don't raise an exception if the link exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_files","title":"link_files  <code>staticmethod</code>","text":"<pre><code>link_files(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple file symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_files(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.link_files(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, don't raise an exception if the link exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy","title":"robocopy  <code>staticmethod</code>","text":"<pre><code>robocopy(\n    src: str,\n    dest: str,\n    *,\n    mkdirs: bool = True,\n    delete: bool = False,\n    exclude_files: Iterable[str] | None = None,\n    exclude_dirs: Iterable[str] | None = None,\n    dry_run: bool = False,\n) -&gt; Done\n</code></pre> <p>Robocopy wrapper function (crude in that it opens a subprocess)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>subprocess return code from robocopy</p> </li> </ul> <p>Robocopy return codes::</p> <pre><code>0. No files were copied. No failure was encountered. No files were\n   mismatched. The files already exist in the destination\n   directory; therefore, the copy operation was skipped.\n1. All files were copied successfully.\n2. There are some additional files in the destination directory\n   that are not present in the source directory. No files were\n   copied.\n3. Some files were copied. Additional files were present. No\n   failure was encountered.\n5. Some files were copied. Some files were mismatched. No failure\n   was encountered.\n6. Additional files and mismatched files exist. No files were\n   copied and no failures were encountered. This means that the\n   files already exist in the destination directory.\n7. Files were copied, a file mismatch was present, and additional\n   files were present.\n8. Several files did not copy.\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>path to source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>path to destination directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Delete files in the destination directory if they do not exist in the source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(exclude_files)","title":"<code>exclude_files</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(exclude_dirs)","title":"<code>exclude_dirs</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do the operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy(mkdirs)","title":"<code>mkdirs</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to make destinaation directories if they do not already exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args","title":"robocopy_args  <code>staticmethod</code>","text":"<pre><code>robocopy_args(\n    src: str,\n    dest: str,\n    *,\n    delete: bool = False,\n    exclude_files: list[str] | None = None,\n    exclude_dirs: list[str] | None = None,\n    dry_run: bool = False,\n) -&gt; list[str]\n</code></pre> <p>Return list of robocopy command args</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>subprocess return code from robocopy</p> </li> </ul> <p>Robocopy return codes::</p> <pre><code>0. No files were copied. No failure was encountered. No files were\n   mismatched. The files already exist in the destination\n   directory; therefore, the copy operation was skipped.\n1. All files were copied successfully.\n2. There are some additional files in the destination directory\n   that are not present in the source directory. No files were\n   copied.\n3. Some files were copied. Additional files were present. No\n   failure was encountered.\n5. Some files were copied. Some files were mismatched. No failure\n   was encountered.\n6. Additional files and mismatched files exist. No files were\n   copied and no failures were encountered. This means that the\n   files already exist in the destination directory.\n7. Files were copied, a file mismatch was present, and additional\n   files were present.\n8. Several files did not copy.\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>path to source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>path to destination directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Delete files in the destination directory if they do not exist in the source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args(exclude_files)","title":"<code>exclude_files</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args(exclude_dirs)","title":"<code>exclude_dirs</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.robocopy_args(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do the operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_dir","title":"unlink_dir  <code>staticmethod</code>","text":"<pre><code>unlink_dir(link: str) -&gt; None\n</code></pre> <p>Unlink a directory symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_dir(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_dirs","title":"unlink_dirs  <code>staticmethod</code>","text":"<pre><code>unlink_dirs(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_dirs(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_file","title":"unlink_file  <code>staticmethod</code>","text":"<pre><code>unlink_file(link: str) -&gt; None\n</code></pre> <p>Unlink a file symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_file(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_files","title":"unlink_files  <code>staticmethod</code>","text":"<pre><code>unlink_files(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.WIN.unlink_files(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.basename","title":"basename","text":"<pre><code>basename(fspath: FsPath) -&gt; str\n</code></pre> <p>Return the basename of given path; alias of os.path.dirname</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>basename of path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.basename(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cd","title":"cd","text":"<pre><code>cd(dirpath: FsPath) -&gt; None\n</code></pre> <p>Change directory to given dirpath; alias for <code>os.chdir</code></p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cd(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.chmod","title":"chmod","text":"<pre><code>chmod(fspath: FsPath, mode: int) -&gt; None\n</code></pre> <p>Change the access permissions of a file</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.chmod(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file to chmod</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.chmod(mode)","title":"<code>mode</code>","text":"(<code>int</code>)           \u2013            <p>Permissions mode as an int</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.copy_file","title":"copy_file","text":"<pre><code>copy_file(\n    src: FsPath,\n    dest: FsPath,\n    *,\n    dryrun: bool = False,\n    mkdirp: bool = False,\n) -&gt; tuple[str, str]\n</code></pre> <p>Copy a file given a source-path and a destination-path</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.copy_file(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.copy_file(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>Destination fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.copy_file(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not copy file if True just return the src and dest</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.copy_file(mkdirp)","title":"<code>mkdirp</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create parent directories if they do not exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp","title":"cp","text":"<pre><code>cp(\n    src: FsPath,\n    dest: FsPath,\n    *,\n    force: bool = True,\n    recursive: bool = False,\n    r: bool = False,\n    f: bool = True,\n) -&gt; None\n</code></pre> <p>Copy the directory/file src to the directory/file dest</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If src is a directory and recursive and r are both <code>False</code></p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source directory/file to copy</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>Destination directory/file to copy</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force the copy (like -f flag for cp in shell)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursive copy (like -r flag for cp in shell)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for recursive</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.cp(f)","title":"<code>f</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>alias for force</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.decode_stdio_bytes","title":"decode_stdio_bytes","text":"<pre><code>decode_stdio_bytes(\n    stdio_bytes: str | bytes, *, lf: bool = True\n) -&gt; str\n</code></pre> <p>Return Stdio bytes from stdout/stderr as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>decoded stdio bytes</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.decode_stdio_bytes(stdio_bytes)","title":"<code>stdio_bytes</code>","text":"(<code>bytes</code>)           \u2013            <p>STDOUT/STDERR bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.decode_stdio_bytes(lf)","title":"<code>lf</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Replace <code>\\r\\n</code> line endings with <code>\\n</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dir_exists","title":"dir_exists","text":"<pre><code>dir_exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dir_exists_async","title":"dir_exists_async  <code>async</code>","text":"<pre><code>dir_exists_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the directory exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirname","title":"dirname","text":"<pre><code>dirname(fspath: FsPath) -&gt; str\n</code></pre> <p>Return dirname/parent-dir of given path; alias of os.path.dirname</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>basename of path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirname(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirpath_gen","title":"dirpath_gen","text":"<pre><code>dirpath_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all dirpaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen","title":"dirs_gen","text":"<pre><code>dirs_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield directory-paths beneath a dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields directory paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'dirs_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = list(sorted(set(expected_dirs)))\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in expected_dirs]\n&gt;&gt;&gt; pprint(expected_dirs)\n['dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; _files = list(files_gen(tmpdir))\n&gt;&gt;&gt; _dirs = list(dirs_gen(tmpdir))\n&gt;&gt;&gt; files_n_dirs_list = list(sorted(_files + _dirs))\n&gt;&gt;&gt; files_n_dirs_list = [el.replace('\\\\', '/') for el in files_n_dirs_list]\n&gt;&gt;&gt; pprint(files_n_dirs_list)\n['dirs_gen.doctest',\n 'dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt',\n 'dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; expected = [el.replace('\\\\', '/') for el in expected]\n&gt;&gt;&gt; pprint(expected)\n['dirs_gen.doctest',\n 'dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt',\n 'dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; files_n_dirs_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.dirs_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that dir exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do","title":"do","text":"<pre><code>do(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: FsPath | None = None,\n    shell: bool = False,\n    check: bool = False,\n    tee: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    timeout: float | int | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess synchronously</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if args and *popenargs are both given</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend the environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(cwd)","title":"<code>cwd</code>","text":"(<code>FsPath | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Run in shell or sub-shell</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the outputs (generally useless)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(tee)","title":"<code>tee</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to tee the subprocess stdout and stderr to sys.stdout/stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) to check against</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Don't run the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async","title":"do_async  <code>async</code>","text":"<pre><code>do_async(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: str | None = None,\n    shell: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    check: bool = False,\n    timeout: float | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess and await its completion</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both *popenargs and args are given</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the result returncode</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(cwd)","title":"<code>cwd</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Run in shell or sub-shell</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) that are considered OK (Default value = 0)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.do_async(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to not run the subprocess but return a Done object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa","title":"doa  <code>async</code>","text":"<pre><code>doa(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: str | None = None,\n    shell: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    check: bool = False,\n    timeout: float | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess and await its completion</p> <p>Alias for sh.do_async</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the result returncode</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(cwd)","title":"<code>cwd</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Run in shell or sub-shell</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) that are considered OK (Default value = 0)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to not run the subprocess but return a Done object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.doa(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.exists","title":"exists","text":"<pre><code>exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.export","title":"export","text":"<pre><code>export(key: str, val: str | None = None) -&gt; tuple[str, str]\n</code></pre> <p>Export/Set an environment variable</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if unable to parse key/val</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.export(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>environment variable name/key</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.export(val)","title":"<code>val</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>environment variable value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.extension","title":"extension","text":"<pre><code>extension(fspath: str, *, period: bool = False) -&gt; str\n</code></pre> <p>Return the extension for a fspath</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import extension\n&gt;&gt;&gt; extension(\"foo.bar\")\n'bar'\n&gt;&gt;&gt; extension(\"foo.tar.gz\")\n'tar.gz'\n&gt;&gt;&gt; extension(\"foo.tar.gz\", period=True)\n'.tar.gz'\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.file_exists","title":"file_exists","text":"<pre><code>file_exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise; alias for isfile</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.file_exists_async","title":"file_exists_async  <code>async</code>","text":"<pre><code>file_exists_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the file exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.file_lines_gen","title":"file_lines_gen","text":"<pre><code>file_lines_gen(\n    filepath: FsPath, *, keepends: bool = True\n) -&gt; Iterable[str]\n</code></pre> <p>Yield lines from a given fspath</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Iterable[str]</code>           \u2013            <p>Lines from the given fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; string = '\\n'.join(str(i) for i in range(1, 10))\n&gt;&gt;&gt; string\n'1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9'\n&gt;&gt;&gt; fspath = \"file_lines_gen.doctest.txt\"\n&gt;&gt;&gt; from shellfish.fs import write_str\n&gt;&gt;&gt; write_str(fspath, string)\n17\n&gt;&gt;&gt; for file_line in file_lines_gen(fspath):\n...     file_line\n'1\\n'\n'2\\n'\n'3\\n'\n'4\\n'\n'5\\n'\n'6\\n'\n'7\\n'\n'8\\n'\n'9'\n&gt;&gt;&gt; for file_line in file_lines_gen(fspath, keepends=False):\n...     file_line\n'1'\n'2'\n'3'\n'4'\n'5'\n'6'\n'7'\n'8'\n'9'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.file_lines_gen(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File to yield lines from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.file_lines_gen(keepends)","title":"<code>keepends</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to keep the ends of the file lines</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filecmp","title":"filecmp","text":"<pre><code>filecmp(\n    left: FsPath,\n    right: FsPath,\n    *,\n    shallow: bool = True,\n    blocksize: int = 65536,\n) -&gt; bool\n</code></pre> <p>Compare 2 files for equality given their filepaths</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if files are equal, False otherwise</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filecmp(left)","title":"<code>left</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath 1</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filecmp(right)","title":"<code>right</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath 2</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filecmp(shallow)","title":"<code>shallow</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check only size and modification time if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filecmp(blocksize)","title":"<code>blocksize</code>","text":"(<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>Chunk size to read files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filepath_gen","title":"filepath_gen","text":"<pre><code>filepath_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filepath_mtimedelta_sec","title":"filepath_mtimedelta_sec","text":"<pre><code>filepath_mtimedelta_sec(filepath: FsPath) -&gt; float\n</code></pre> <p>Return the seconds since the file(path) was last modified</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen","title":"files_dirs_gen","text":"<pre><code>files_dirs_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; tuple[Iterator[str], Iterator[str]]\n</code></pre> <p>Return a files_gen() and a dirs_gen() in one swell-foop</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Iterator[str], Iterator[str]]</code>           \u2013            <p>A tuple of two generators (files_gen(), dirs_gen())</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'files_dirs_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = list(sorted(set(expected_dirs)))\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in expected_dirs]\n&gt;&gt;&gt; pprint(expected_dirs)\n['files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; _files, _dirs = files_dirs_gen(tmpdir)\n&gt;&gt;&gt; _files = list(_files)\n&gt;&gt;&gt; _dirs = list(_dirs)\n&gt;&gt;&gt; files_n_dirs_list = list(sorted(set(_files + _dirs)))\n&gt;&gt;&gt; files_n_dirs_list = [el.replace('\\\\', '/') for el in files_n_dirs_list]\n&gt;&gt;&gt; pprint(files_n_dirs_list)\n['files_dirs_gen.doctest',\n 'files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt',\n 'files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; expected = [el.replace('\\\\', '/') for el in expected]\n&gt;&gt;&gt; pprint(expected)\n['files_dirs_gen.doctest',\n 'files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt',\n 'files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; files_n_dirs_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_dirs_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check if dirpath is a directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen","title":"files_gen","text":"<pre><code>files_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield file-paths beneath a given dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields file-paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'files_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt',\n 'files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; files_list = list(sorted(set(files_gen(tmpdir))))\n&gt;&gt;&gt; files_list = [el.replace('\\\\', '/') for el in files_list]\n&gt;&gt;&gt; pprint(files_list)\n['files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt',\n 'files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; pprint(list(sorted(set(expected_files))))\n['files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt',\n 'files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; list(sorted(set(files_list))) == list(sorted(set(expected_files)))\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.files_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that dir exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filesize","title":"filesize","text":"<pre><code>filesize(fspath: FsPath) -&gt; int\n</code></pre> <p>Return the size of the given file(path) in bytes</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>size of the fspath in bytes</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filesize(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath as a string or pathlib.Path object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.filesize_async","title":"filesize_async  <code>async</code>","text":"<pre><code>filesize_async(fspath: FsPath) -&gt; int\n</code></pre> <p>Return the size of the file at the given fspath</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from tempfile import TemporaryDirectory\n&gt;&gt;&gt; with TemporaryDirectory() as tmpdir:\n...     tmpdir = Path(tmpdir)\n...     fpath = tmpdir / \"test.txt\"\n...     written = fpath.write_text(\"hello world\")\n...     aiorun(filesize_async(fpath))\n11\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.flatten_args","title":"flatten_args","text":"<pre><code>flatten_args(*args: Any | list[Any]) -&gt; list[str]\n</code></pre> <p>Flatten possibly nested iterables of sequences to a list of strings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(flatten_args(\"cmd\", [\"uno\", \"dos\", \"tres\"]))\n['cmd', 'uno', 'dos', 'tres']\n&gt;&gt;&gt; list(flatten_args(\"cmd\", [\"uno\", \"dos\", \"tres\", [\"4444\", \"five\"]]))\n['cmd', 'uno', 'dos', 'tres', '4444', 'five']\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fspath","title":"fspath","text":"<pre><code>fspath(fspath: FsPath) -&gt; str\n</code></pre> <p>Alias for os._fspath; returns fspath string for any type of path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.is_dir","title":"is_dir","text":"<pre><code>is_dir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.is_dir_async","title":"is_dir_async  <code>async</code>","text":"<pre><code>is_dir_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.is_file","title":"is_file","text":"<pre><code>is_file(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; alias for isfile</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.is_file_async","title":"is_file_async  <code>async</code>","text":"<pre><code>is_file_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.is_link","title":"is_link","text":"<pre><code>is_link(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; alias for islink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.is_link_async","title":"is_link_async  <code>async</code>","text":"<pre><code>is_link_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.isdir","title":"isdir","text":"<pre><code>isdir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.isdir_async","title":"isdir_async  <code>async</code>","text":"<pre><code>isdir_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.isfile","title":"isfile","text":"<pre><code>isfile(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.isfile_async","title":"isfile_async  <code>async</code>","text":"<pre><code>isfile_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.islink","title":"islink","text":"<pre><code>islink(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.islink_async","title":"islink_async  <code>async</code>","text":"<pre><code>islink_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.listdir_async","title":"listdir_async  <code>async</code>","text":"<pre><code>listdir_async(fspath: FsPath) -&gt; list[str]\n</code></pre> <p>Async version of <code>os.listdir</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.listdir_gen","title":"listdir_gen","text":"<pre><code>listdir_gen(\n    fspath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    follow_symlinks: bool = True,\n    files: bool = True,\n    dirs: bool = True,\n    symlinks: bool = False,\n    files_only: bool = False,\n    dirs_only: bool = False,\n    symlinks_only: bool = False,\n) -&gt; Iterator[Path]\n</code></pre> <p>Return an iterator of strings from DirEntries</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'listdir_gen.doctest'\n&gt;&gt;&gt; from shellfish import sh\n&gt;&gt;&gt; from os import makedirs, path, chdir\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; pwd = sh.pwd()\n&gt;&gt;&gt; sh.cd(tmpdir)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"data1.json\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; dirpath = path.join(tmpdir, 'dir')\n&gt;&gt;&gt; dirpath.replace(\"\\\\\", \"/\")\n'listdir_gen.doctest/dir'\n&gt;&gt;&gt; sorted(listdir_gen(dirpath, dirs=False, symlinks=False))\n['data1.json', 'file1.txt', 'file2.txt', 'file3.txt']\n&gt;&gt;&gt; abspaths = sorted(listdir_gen(dirpath, abspath=True, dirs=False, symlinks=False))\n&gt;&gt;&gt; for abspath in [p.replace(\"\\\\\", \"/\") for p in abspaths]:\n...    print(abspath)\nlistdir_gen.doctest/dir/data1.json\nlistdir_gen.doctest/dir/file1.txt\nlistdir_gen.doctest/dir/file2.txt\nlistdir_gen.doctest/dir/file3.txt\n&gt;&gt;&gt; sh.cd(pwd)\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; if path.exists(tmpdir):\n...     rmtree(tmpdir)\n&gt;&gt;&gt; path.isdir(tmpdir)\nFalse\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls","title":"ls","text":"<pre><code>ls(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List files and dirs given a dirpath (defaults to pwd)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of the directory items</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>path-string to directory to list</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Give absolute paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_dirs","title":"ls_dirs","text":"<pre><code>ls_dirs(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List the directories in a given directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of directories as strings</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_dirs(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path for which one might want list directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_dirs(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return absolute directory paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_files","title":"ls_files","text":"<pre><code>ls_files(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List the files in a given directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of files as strings</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_files(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path for which one might want to list files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_files(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return absolute filepaths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_files_dirs","title":"ls_files_dirs","text":"<pre><code>ls_files_dirs(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; tuple[list[str], list[str]]\n</code></pre> <p>List the files and directories given directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[str], list[str]]</code>           \u2013            <p>Two lists of strings; the first is a list of the files and the second is a list of the directories</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_files_dirs(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to execute on</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.ls_files_dirs(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return absolute file/directory paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.lstat_async","title":"lstat_async  <code>async</code>","text":"<pre><code>lstat_async(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Async version of <code>os.lstat</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mkdir","title":"mkdir","text":"<pre><code>mkdir(\n    fspath: FsPath,\n    *,\n    parents: bool = False,\n    p: bool = False,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make directory at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mkdir(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory path to create</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mkdir(parents)","title":"<code>parents</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make parent dirs if True; do not make parent dirs if False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mkdir(p)","title":"<code>p</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make parent dirs if True; do not make parent dirs if False (alias of parents)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mkdir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Throw error if directory exists and exist_ok is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mkdirp","title":"mkdirp","text":"<pre><code>mkdirp(fspath: FsPath) -&gt; None\n</code></pre> <p>Make directory and parents</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.move","title":"move","text":"<pre><code>move(src: FsPath, dest: FsPath) -&gt; None\n</code></pre> <p>Move file(s) like on the command line</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.move(src)","title":"<code>src</code>","text":"(<code>FsPath</code>)           \u2013            <p>source file(s)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.move(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>destination path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mv","title":"mv","text":"<pre><code>mv(src: FsPath, dest: FsPath) -&gt; None\n</code></pre> <p>Move file(s) like on the command line</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mv(src)","title":"<code>src</code>","text":"(<code>FsPath</code>)           \u2013            <p>source file(s)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.mv(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>destination path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.path_gen","title":"path_gen","text":"<pre><code>path_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.pwd","title":"pwd","text":"<pre><code>pwd() -&gt; str\n</code></pre> <p>Return present-working-directory path string; alias for os.getcwd</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>present working directory as string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; pwd() == os.getcwd()\nTrue\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.q","title":"q","text":"<pre><code>q(string: str) -&gt; str\n</code></pre> <p>Typed alias for shlex.quote</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>quoted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; q(\"hello world\")\n\"'hello world'\"\n&gt;&gt;&gt; q(\"hello 'world'\")\n'\\'hello \\'\"\\'\"\\'world\\'\"\\'\"\\'\\''\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.q(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to quote</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.quote","title":"quote","text":"<pre><code>quote(string: str) -&gt; str\n</code></pre> <p>Typed alias for shlex.quote</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>quoted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; quote(\"hello world\")\n\"'hello world'\"\n&gt;&gt;&gt; quote(\"hello 'world'\")\n'\\'hello \\'\"\\'\"\\'world\\'\"\\'\"\\'\\''\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.quote(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to quote</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes","title":"read_bytes","text":"<pre><code>read_bytes(filepath: FsPath) -&gt; bytes\n</code></pre> <p>Read bytes from a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes from the fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"rbytes.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; write_bytes(fspath, bites_to_save)\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath read as bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes_async","title":"read_bytes_async  <code>async</code>","text":"<pre><code>read_bytes_async(filepath: FsPath) -&gt; bytes\n</code></pre> <p>(ASYNC) Load/Read bytes from a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes from the fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs._async import read_bytes_async, write_bytes_async\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; fspath = \"rbytes_async.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; aiorun(write_bytes_async(fspath, bites_to_save))\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; aiorun(read_bytes_async(fspath))\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath read as bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes_gen","title":"read_bytes_gen","text":"<pre><code>read_bytes_gen(\n    filepath: FsPath, blocksize: int = 65536\n) -&gt; Iterable[bytes]\n</code></pre> <p>Yield bytes from a given fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes_gen_async","title":"read_bytes_gen_async  <code>async</code>","text":"<pre><code>read_bytes_gen_async(\n    filepath: FsPath, blocksize: int = 65536\n) -&gt; AsyncIterable[bytes]\n</code></pre> <p>Yield (asynchronously) bytes from a given fspath</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>AsyncIterable[bytes]</code>           \u2013            <p>bytes from AsyncIterable[bytes] of the file bytes</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import write_bytes_gen_async, read_bytes_gen_async\n&gt;&gt;&gt; fspath = 'rbytes_gen_async.doctest.txt'\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; async def read():\n...     async for b in read_bytes_gen_async(fspath, blocksize=4):\n...         print(b)\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; async def async_gen():\n...     for b in bites_to_save:\n...        yield b\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, AsyncIterable()))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes_gen_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to read from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_bytes_gen_async(blocksize)","title":"<code>blocksize</code>","text":"(<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>size of the block to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_json","title":"read_json","text":"<pre><code>read_json(filepath: FsPath) -&gt; Any\n</code></pre> <p>Load/Read-&amp;-parse json data given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Parsed JSON data</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_json, write_json\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n19\n&gt;&gt;&gt; read_json(fspath)\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n25\n&gt;&gt;&gt; read_json(fspath)\n[['a', 1], ['b', 2], ['c', 3]]\n&gt;&gt;&gt; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_json(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to load/read data from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_json_async","title":"read_json_async  <code>async</code>","text":"<pre><code>read_json_async(filepath: FsPath) -&gt; Any\n</code></pre> <p>Load/Read-&amp;-parse json data given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Parsed JSON data</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import read_json_async, write_json_async\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_async_dict.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n19\n&gt;&gt;&gt; run(read_json_async(fspath))\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_async_list.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n25\n&gt;&gt;&gt; run(read_json_async(fspath))\n[['a', 1], ['b', 2], ['c', 3]]\n</code></pre> <pre><code>&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_json_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to load/read data from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_str","title":"read_str","text":"<pre><code>read_str(\n    filepath: FsPath, *, encoding: str = \"utf-8\"\n) -&gt; str\n</code></pre> <p>Load/Read a string given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>String read from given fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_str, write_str\n&gt;&gt;&gt; fspath = \"read_str.doctest.txt\"\n&gt;&gt;&gt; write_str(fspath, r'Check out this string')\n21\n&gt;&gt;&gt; read_str(fspath)\n'Check out this string'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_str(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath for file to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>Encoding to use for reading the file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_str_async","title":"read_str_async  <code>async</code>","text":"<pre><code>read_str_async(\n    filepath: FsPath, encoding: str = \"utf-8\"\n) -&gt; str\n</code></pre> <p>(ASYNC) Load/Read a string given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>String read from given fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_str_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath for file to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.read_str_async(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>File encoding (Default='utf-8')</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm","title":"rm","text":"<pre><code>rm(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n    verbose: bool = False,\n    f: bool = False,\n    r: bool = False,\n    v: bool = False,\n    dryrun: bool = False,\n) -&gt; None\n</code></pre> <p>Remove files &amp; directories in the style of the shell</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If recursive and r are <code>False</code> and fspath is a directory</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to force removal; ignore missing</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to remove recursively (like the <code>-r</code> in <code>rm -r dir</code>)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to be verbose</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(f)","title":"<code>f</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for force kwarg</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(v)","title":"<code>v</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for verbose</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for recursive kwarg</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to not actually remove anything</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm_gen","title":"rm_gen","text":"<pre><code>rm_gen(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n    dryrun: bool = False,\n) -&gt; Generator[str, Any, Any]\n</code></pre> <p>Remove files &amp; directories in the style of the shell</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If recursive and r are <code>False</code> and fspath is a directory</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm_gen(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm_gen(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force removal of files and directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm_gen(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to remove recursively (like the <code>-r</code> in <code>rm -r dir</code>)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rm_gen(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmdir","title":"rmdir","text":"<pre><code>rmdir(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n) -&gt; None\n</code></pre> <p>Remove directory at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmdir(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory path to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmdir(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force removal of files and directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmdir(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively remove all contents if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmfile","title":"rmfile","text":"<pre><code>rmfile(fspath: FsPath, *, dryrun: bool = False) -&gt; str\n</code></pre> <p>Remove a file at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmfile(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.rmfile(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.safepath","title":"safepath","text":"<pre><code>safepath(fspath: FsPath) -&gt; str\n</code></pre> <p>Check if a file/dir path is save/unused; returns an unused path.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>file/dir path that does not exist and contains the given path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.safepath(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>file-system path; file or directory path string or Path obj</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir","title":"scandir","text":"<pre><code>scandir(\n    dirpath: FsPath = \".\",\n) -&gt; Iterable[DirEntry[AnyStr]]\n</code></pre> <p>Typed version of os.scandir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen","title":"scandir_gen","text":"<pre><code>scandir_gen(\n    fspath: FsPath = \".\",\n    *,\n    recursive: bool = False,\n    follow_symlinks: bool = True,\n    files: bool = True,\n    dirs: bool = True,\n    symlinks: bool = True,\n    files_only: bool = False,\n    dirs_only: bool = False,\n    symlinks_only: bool = False,\n) -&gt; Iterator[DirEntry[str]]\n</code></pre> <p>Return an iterator of os.DirEntry objects</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[DirEntry[str]]</code>           \u2013            <p>Iterator[DirEntry]: Iterator of os.DirEntry objects</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if any of the kwargs (<code>dirs</code>, <code>files</code> and <code>symlinks</code>) are not True</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>(FsPath): dirpath to look through</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>recursively scan the directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(follow_symlinks)","title":"<code>follow_symlinks</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>follow symlinks when checking for dirs and files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(files)","title":"<code>files</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(dirs)","title":"<code>dirs</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(symlinks)","title":"<code>symlinks</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include symlinks</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(dirs_only)","title":"<code>dirs_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(files_only)","title":"<code>files_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_gen(symlinks_only)","title":"<code>symlinks_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include symlinks</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_list","title":"scandir_list","text":"<pre><code>scandir_list(\n    dirpath: FsPath = \".\",\n) -&gt; list[DirEntry[AnyStr]]\n</code></pre> <p>Return a list of os.DirEntry objects</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[DirEntry[AnyStr]]</code>           \u2013            <p>list[DirEntry]: List of os.DirEntry objects</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.scandir_list(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Dirpath to scan</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sep_join","title":"sep_join","text":"<pre><code>sep_join(path_strings: Iterator[str]) -&gt; str\n</code></pre> <p>Join iterable of strings on the current platform os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sep_lstrip","title":"sep_lstrip","text":"<pre><code>sep_lstrip(fspath: FsPath) -&gt; str\n</code></pre> <p>Left-strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sep_rstrip","title":"sep_rstrip","text":"<pre><code>sep_rstrip(fspath: FsPath) -&gt; str\n</code></pre> <p>Right-strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sep_split","title":"sep_split","text":"<pre><code>sep_split(fspath: FsPath) -&gt; tuple[str, ...]\n</code></pre> <p>Split a string on the current platform os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sep_strip","title":"sep_strip","text":"<pre><code>sep_strip(fspath: FsPath) -&gt; str\n</code></pre> <p>Strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.setenv","title":"setenv","text":"<pre><code>setenv(key: str, val: str | None = None) -&gt; tuple[str, str]\n</code></pre> <p>Export/Set an environment variable</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>tuple[str, str]: environment variable key/value pair</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.setenv(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>environment variable name/key</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.setenv(val)","title":"<code>val</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>environment variable value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shebang","title":"shebang","text":"<pre><code>shebang(fspath: FsPath) -&gt; str | None\n</code></pre> <p>Get the shebang string given a fspath; Returns None if no shebang</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: The shebang string if it exists, None otherwise</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from inspect import getabsfile\n&gt;&gt;&gt; script = 'ashellscript.sh'\n&gt;&gt;&gt; with open(script, 'w') as f:\n...     f.write('#!/bin/bash\\necho \"howdy\"\\n')\n25\n&gt;&gt;&gt; shebang(script)\n'#!/bin/bash'\n&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; remove(script)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shebang(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file that might have a shebang</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell","title":"shell","text":"<pre><code>shell(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    shell: bool = True,\n    extenv: bool = True,\n    cwd: FsPath | None = None,\n    check: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    timeout: float | int | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess synchronously in current shell</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Run in shell or sub-shell; default is True for <code>shell</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend the environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(cwd)","title":"<code>cwd</code>","text":"(<code>FsPath | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the outputs (generally useless)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) to check if ok</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shell(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Don't run the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.shplit","title":"shplit","text":"<pre><code>shplit(\n    string: str,\n    *,\n    comments: bool = False,\n    posix: bool = True,\n) -&gt; list[str]\n</code></pre> <p>Typed alias for shlex.split</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.source","title":"source","text":"<pre><code>source(filepath: FsPath, *, _globals: bool = True) -&gt; None\n</code></pre> <p>Execute/run a python file given a fspath and put globals in globasl</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.source(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to python file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.source(_globals)","title":"<code>_globals</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Exec using globals</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.stat","title":"stat","text":"<pre><code>stat(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Return the os.stat_result object for a given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>stat_result</code>           \u2013            <p>os.stat_result: stat_result object</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.stat(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.stat_async","title":"stat_async  <code>async</code>","text":"<pre><code>stat_async(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Async version of <code>os.stat</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.touch","title":"touch","text":"<pre><code>touch(fspath: FsPath, *, mkdirp: bool = True) -&gt; None\n</code></pre> <p>Create an empty file given a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.touch(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path for where to make an empty file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.touch(mkdirp)","title":"<code>mkdirp</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Make parent directories if they don't exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.tree","title":"tree","text":"<pre><code>tree(\n    dirpath: FsPath,\n    filterfn: Callable[[str], bool] | None = None,\n) -&gt; str\n</code></pre> <p>Create a directory tree string given a directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Directory-tree string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'tree.doctest'\n&gt;&gt;&gt; from os import makedirs; makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     makedirs(dirpath, exist_ok=True)\n...     Path(fspath).touch()\n&gt;&gt;&gt; print(tree(tmpdir))\ntree.doctest/\n\u2514\u2500\u2500 dir/\n    \u251c\u2500\u2500 dir2/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u251c\u2500\u2500 file2.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 dir2a/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u251c\u2500\u2500 file2.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 file1.txt\n    \u251c\u2500\u2500 file2.txt\n    \u2514\u2500\u2500 file3.txt\n&gt;&gt;&gt; print(tree(tmpdir, lambda s: _DirTree._default_filter(s) and not \"file2\" in s))\ntree.doctest/\n\u2514\u2500\u2500 dir/\n    \u251c\u2500\u2500 dir2/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 dir2a/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 file1.txt\n    \u2514\u2500\u2500 file3.txt\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.tree(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory string to make tree for</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.tree(filterfn)","title":"<code>filterfn</code>","text":"(<code>Callable[[str], bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function to filter sub-directories and sub-files with</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen","title":"walk_gen","text":"<pre><code>walk_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield all paths beneath a given dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields directory paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'walk_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f).replace('\\\\', '/')\n...     fspath = path.join(tmpdir, fspath).replace('\\\\', '/')\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in sorted(set(expected_dirs))]\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint(expected_files)\n['walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; pprint(expected_dirs)\n['walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; walk_gen_list = list(sorted(walk_gen(tmpdir)))\n&gt;&gt;&gt; walk_gen_list = [el.replace('\\\\', '/') for el in walk_gen_list]\n&gt;&gt;&gt; pprint(walk_gen_list)\n['walk_gen.doctest',\n 'walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt',\n 'walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; pprint(expected)\n['walk_gen.doctest',\n 'walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt',\n 'walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; walk_gen_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.walk_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check if dirpath exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.where","title":"where","text":"<pre><code>where(cmd: str, path: str | None = None) -&gt; str | None\n</code></pre> <p>Return the result of <code>shutil.which</code>; alias of shellfish.sh.which</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: path to command/exe</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.where(cmd)","title":"<code>cmd</code>","text":"(<code>str</code>)           \u2013            <p>Command/exe to find path of</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.where(path)","title":"<code>path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>System path to use</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.which","title":"which","text":"<pre><code>which(cmd: str, path: str | None = None) -&gt; str | None\n</code></pre> <p>Return the result of <code>shutil.which</code></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: path to command/exe</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.which(cmd)","title":"<code>cmd</code>","text":"(<code>str</code>)           \u2013            <p>Command/exe to find path of</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.which(path)","title":"<code>path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>System path to use</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.which_lru","title":"which_lru  <code>cached</code>","text":"<pre><code>which_lru(cmd: str, path: str | None = None) -&gt; str | None\n</code></pre> <p>Return the result of <code>shutil.which</code> and cache the results</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: path to command/exe</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.which_lru(cmd)","title":"<code>cmd</code>","text":"(<code>str</code>)           \u2013            <p>Command/exe to find path of</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.which_lru(path)","title":"<code>path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>System path to use</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes","title":"write_bytes","text":"<pre><code>write_bytes(\n    filepath: FsPath,\n    bites: bytes,\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/Save bytes to a fspath</p> <p>The parameter 'bites' is used instead of 'bytes' to not redefine the built-in python bytes object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"wbytes.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; write_bytes(fspath, bites_to_save)\n20\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the file after writing; default is None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_async","title":"write_bytes_async  <code>async</code>","text":"<pre><code>write_bytes_async(\n    filepath: FsPath,\n    bites: bytes,\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>(ASYNC) Write/Save bytes to a fspath</p> <p>The parameter 'bites' is used instead of 'bytes' so as to not redefine the built-in python bytes object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs._async import read_bytes_async, write_bytes_async\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; fspath = \"wbytes_async.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; aiorun(write_bytes_async(fspath, bites_to_save))\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; aiorun(read_bytes_async(fspath))\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; otherwise overwrite</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_async(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_async(chmod)","title":"<code>chmod</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath to this mode after writing</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen","title":"write_bytes_gen","text":"<pre><code>write_bytes_gen(\n    filepath: FsPath,\n    bytes_gen: Iterable[bytes],\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/Save bytes to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"wbytes_gen.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save  # they are bytes!\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; write_bytes_gen(fspath, (b for b in bites_to_save))\n35\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes... more bytes!'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen(bytes_gen)","title":"<code>bytes_gen</code>","text":"(<code>Iterable[bytes]</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the file after writing; default is None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen_async","title":"write_bytes_gen_async  <code>async</code>","text":"<pre><code>write_bytes_gen_async(\n    filepath: FsPath,\n    bytes_gen: Iterable[bytes] | AsyncIterable[bytes],\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/save bytes to a filepath from an (async)iterable/iterator of bytes</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import write_bytes_gen_async, read_bytes_gen_async\n&gt;&gt;&gt; fspath = 'wbytes_gen_async.doctest.txt'\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; async def read():\n...     async for b in read_bytes_gen_async(fspath, blocksize=4):\n...         print(b)\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; async def async_gen():\n...     for b in bites_to_save:\n...        yield b\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, AsyncIterable()))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen_async(bytes_gen)","title":"<code>bytes_gen</code>","text":"(<code>Iterable[bytes] | AsyncIterable[bytes]</code>)           \u2013            <p>AsyncIterable/Iterator of bytes to write</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; otherwise overwrite</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_bytes_gen_async(chmod)","title":"<code>chmod</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json","title":"write_json","text":"<pre><code>write_json(\n    filepath: FsPath,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    chmod: int | None = None,\n    append: bool = False,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Save/Write json-serial-ize-able data to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_json, write_json\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n19\n&gt;&gt;&gt; read_json(fspath)\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n25\n&gt;&gt;&gt; read_json(fspath)\n[['a', 1], ['b', 2], ['c', 3]]\n&gt;&gt;&gt; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(data)","title":"<code>data</code>","text":"(<code>Any</code>)           \u2013            <p>json-serial-ize-able data</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline to the end of the file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional chmod to set on file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to jsonbourne.JSON.dumpb</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async","title":"write_json_async  <code>async</code>","text":"<pre><code>write_json_async(\n    filepath: FsPath,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    append: bool = False,\n    chmod: int | None = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Save/Write json-serial-ize-able data to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import read_json_async, write_json_async\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"wjson_async_dict.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n19\n&gt;&gt;&gt; run(read_json_async(fspath))\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"wjson_async_list.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n25\n&gt;&gt;&gt; run(read_json_async(fspath))\n[['a', 1], ['b', 2], ['c', 3]]\n</code></pre> <pre><code>&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(data)","title":"<code>data</code>","text":"(<code>Any</code>)           \u2013            <p>json-serial-ize-able data</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_json_async(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to jsonbourne.JSON.dump</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str","title":"write_str","text":"<pre><code>write_str(\n    filepath: FsPath,\n    string: str,\n    *,\n    encoding: str = \"utf-8\",\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Save/Write a string to fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_str, write_str\n&gt;&gt;&gt; fspath = \"sstring.doctest.txt\"\n&gt;&gt;&gt; write_str(fspath, r'Check out this string')\n21\n&gt;&gt;&gt; read_str(fspath)\n'Check out this string'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>String encoding to write file with</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file; default = False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional chmod to set on file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str_async","title":"write_str_async  <code>async</code>","text":"<pre><code>write_str_async(\n    filepath: FsPath,\n    string: str,\n    *,\n    encoding: str = \"utf-8\",\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>(ASYNC) Save/Write a string to fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>number of bytes written</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str_async(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str_async(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>File encoding (Default='utf-8')</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.write_str_async(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs","title":"fs","text":"<p>file-system utils</p> <p>Modules:</p> <ul> <li> <code>promises</code>           \u2013            <p>shellfish.fs.promises</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>Stdio</code>           \u2013            <p>Standard-io enum object</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>chmod</code>             \u2013              <p>Change the access permissions of a file</p> </li> <li> <code>copy_file</code>             \u2013              <p>Copy a file given a source-path and a destination-path</p> </li> <li> <code>cp</code>             \u2013              <p>Copy the directory/file src to the directory/file dest</p> </li> <li> <code>dir_exists</code>             \u2013              <p>Return True if the given path exists; False otherwise; alias for isdir</p> </li> <li> <code>dir_exists_async</code>             \u2013              <p>Return True if the directory exists; False otherwise</p> </li> <li> <code>dirpath_gen</code>             \u2013              <p>Yield all dirpaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>dirs_gen</code>             \u2013              <p>Yield directory-paths beneath a dirpath (defaults to os.getcwd())</p> </li> <li> <code>exists</code>             \u2013              <p>Return True if the given path exists; False otherwise</p> </li> <li> <code>extension</code>             \u2013              <p>Return the extension for a fspath</p> </li> <li> <code>file_exists</code>             \u2013              <p>Return True if the given path exists; False otherwise; alias for isfile</p> </li> <li> <code>file_exists_async</code>             \u2013              <p>Return True if the file exists; False otherwise</p> </li> <li> <code>file_lines_gen</code>             \u2013              <p>Yield lines from a given fspath</p> </li> <li> <code>filecmp</code>             \u2013              <p>Compare 2 files for equality given their filepaths</p> </li> <li> <code>filepath_gen</code>             \u2013              <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>filepath_mtimedelta_sec</code>             \u2013              <p>Return the seconds since the file(path) was last modified</p> </li> <li> <code>files_dirs_gen</code>             \u2013              <p>Return a files_gen() and a dirs_gen() in one swell-foop</p> </li> <li> <code>files_gen</code>             \u2013              <p>Yield file-paths beneath a given dirpath (defaults to os.getcwd())</p> </li> <li> <code>filesize</code>             \u2013              <p>Return the size of the given file(path) in bytes</p> </li> <li> <code>filesize_async</code>             \u2013              <p>Return the size of the file at the given fspath</p> </li> <li> <code>fspath</code>             \u2013              <p>Alias for os._fspath; returns fspath string for any type of path</p> </li> <li> <code>glob</code>             \u2013              <p>Return an iterator of fspaths matching the given glob pattern</p> </li> <li> <code>is_dir</code>             \u2013              <p>Return True if the given path is a directory; alias for isdir</p> </li> <li> <code>is_dir_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>is_file</code>             \u2013              <p>Return True if the given path is a file; alias for isfile</p> </li> <li> <code>is_file_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>is_link</code>             \u2013              <p>Return True if the given path is a link; alias for islink</p> </li> <li> <code>is_link_async</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>isdir</code>             \u2013              <p>Return True if the given path is a directory; False otherwise</p> </li> <li> <code>isdir_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>isfile</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>isfile_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>islink</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>islink_async</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>listdir_async</code>             \u2013              <p>Async version of <code>os.listdir</code></p> </li> <li> <code>listdir_gen</code>             \u2013              <p>Return an iterator of strings from DirEntries</p> </li> <li> <code>lstat_async</code>             \u2013              <p>Async version of <code>os.lstat</code></p> </li> <li> <code>mkdir</code>             \u2013              <p>Make directory at given fspath</p> </li> <li> <code>mkdirp</code>             \u2013              <p>Make directory and parents</p> </li> <li> <code>move</code>             \u2013              <p>Move file(s) like on the command line</p> </li> <li> <code>path_gen</code>             \u2013              <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>read_bytes</code>             \u2013              <p>Read bytes from a fspath</p> </li> <li> <code>read_bytes_async</code>             \u2013              <p>(ASYNC) Load/Read bytes from a fspath</p> </li> <li> <code>read_bytes_gen</code>             \u2013              <p>Yield bytes from a given fspath</p> </li> <li> <code>read_bytes_gen_async</code>             \u2013              <p>Yield (asynchronously) bytes from a given fspath</p> </li> <li> <code>read_json</code>             \u2013              <p>Load/Read-&amp;-parse json data given a fspath</p> </li> <li> <code>read_json_async</code>             \u2013              <p>Load/Read-&amp;-parse json data given a fspath</p> </li> <li> <code>read_str</code>             \u2013              <p>Load/Read a string given a fspath</p> </li> <li> <code>read_str_async</code>             \u2013              <p>(ASYNC) Load/Read a string given a fspath</p> </li> <li> <code>rm</code>             \u2013              <p>Remove files &amp; directories in the style of the shell</p> </li> <li> <code>rm_gen</code>             \u2013              <p>Remove files &amp; directories in the style of the shell</p> </li> <li> <code>rmdir</code>             \u2013              <p>Remove directory at given fspath</p> </li> <li> <code>rmfile</code>             \u2013              <p>Remove a file at given fspath</p> </li> <li> <code>safepath</code>             \u2013              <p>Check if a file/dir path is save/unused; returns an unused path.</p> </li> <li> <code>scandir</code>             \u2013              <p>Typed version of os.scandir</p> </li> <li> <code>scandir_gen</code>             \u2013              <p>Return an iterator of os.DirEntry objects</p> </li> <li> <code>scandir_list</code>             \u2013              <p>Return a list of os.DirEntry objects</p> </li> <li> <code>sep_join</code>             \u2013              <p>Join iterable of strings on the current platform os.path.sep value</p> </li> <li> <code>sep_lstrip</code>             \u2013              <p>Left-strip a string of the current platform's os.path.sep value</p> </li> <li> <code>sep_rstrip</code>             \u2013              <p>Right-strip a string of the current platform's os.path.sep value</p> </li> <li> <code>sep_split</code>             \u2013              <p>Split a string on the current platform os.path.sep value</p> </li> <li> <code>sep_strip</code>             \u2013              <p>Strip a string of the current platform's os.path.sep value</p> </li> <li> <code>shebang</code>             \u2013              <p>Get the shebang string given a fspath; Returns None if no shebang</p> </li> <li> <code>stat</code>             \u2013              <p>Return the os.stat_result object for a given fspath</p> </li> <li> <code>stat_async</code>             \u2013              <p>Async version of <code>os.stat</code></p> </li> <li> <code>touch</code>             \u2013              <p>Create an empty file given a fspath</p> </li> <li> <code>walk_gen</code>             \u2013              <p>Yield all paths beneath a given dirpath (defaults to os.getcwd())</p> </li> <li> <code>write_bytes</code>             \u2013              <p>Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_async</code>             \u2013              <p>(ASYNC) Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_gen</code>             \u2013              <p>Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_gen_async</code>             \u2013              <p>Write/save bytes to a filepath from an (async)iterable/iterator of bytes</p> </li> <li> <code>write_json</code>             \u2013              <p>Save/Write json-serial-ize-able data to a fspath</p> </li> <li> <code>write_json_async</code>             \u2013              <p>Save/Write json-serial-ize-able data to a fspath</p> </li> <li> <code>write_str</code>             \u2013              <p>Save/Write a string to fspath</p> </li> <li> <code>write_str_async</code>             \u2013              <p>(ASYNC) Save/Write a string to fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.Stdio","title":"Stdio","text":"<p>               Bases: <code>IntEnum</code></p> <p>Standard-io enum object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.chmod","title":"chmod","text":"<pre><code>chmod(fspath: FsPath, mode: int) -&gt; None\n</code></pre> <p>Change the access permissions of a file</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.chmod(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file to chmod</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.chmod(mode)","title":"<code>mode</code>","text":"(<code>int</code>)           \u2013            <p>Permissions mode as an int</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.copy_file","title":"copy_file","text":"<pre><code>copy_file(\n    src: FsPath,\n    dest: FsPath,\n    *,\n    dryrun: bool = False,\n    mkdirp: bool = False,\n) -&gt; tuple[str, str]\n</code></pre> <p>Copy a file given a source-path and a destination-path</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.copy_file(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.copy_file(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>Destination fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.copy_file(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not copy file if True just return the src and dest</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.copy_file(mkdirp)","title":"<code>mkdirp</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create parent directories if they do not exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp","title":"cp","text":"<pre><code>cp(\n    src: FsPath,\n    dest: FsPath,\n    *,\n    force: bool = True,\n    recursive: bool = False,\n    r: bool = False,\n    f: bool = True,\n) -&gt; None\n</code></pre> <p>Copy the directory/file src to the directory/file dest</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If src is a directory and recursive and r are both <code>False</code></p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source directory/file to copy</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>Destination directory/file to copy</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force the copy (like -f flag for cp in shell)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursive copy (like -r flag for cp in shell)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for recursive</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.cp(f)","title":"<code>f</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>alias for force</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dir_exists","title":"dir_exists","text":"<pre><code>dir_exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dir_exists_async","title":"dir_exists_async  <code>async</code>","text":"<pre><code>dir_exists_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the directory exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirpath_gen","title":"dirpath_gen","text":"<pre><code>dirpath_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all dirpaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen","title":"dirs_gen","text":"<pre><code>dirs_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield directory-paths beneath a dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields directory paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'dirs_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = list(sorted(set(expected_dirs)))\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in expected_dirs]\n&gt;&gt;&gt; pprint(expected_dirs)\n['dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; _files = list(files_gen(tmpdir))\n&gt;&gt;&gt; _dirs = list(dirs_gen(tmpdir))\n&gt;&gt;&gt; files_n_dirs_list = list(sorted(_files + _dirs))\n&gt;&gt;&gt; files_n_dirs_list = [el.replace('\\\\', '/') for el in files_n_dirs_list]\n&gt;&gt;&gt; pprint(files_n_dirs_list)\n['dirs_gen.doctest',\n 'dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt',\n 'dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; expected = [el.replace('\\\\', '/') for el in expected]\n&gt;&gt;&gt; pprint(expected)\n['dirs_gen.doctest',\n 'dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt',\n 'dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; files_n_dirs_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.dirs_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that dir exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.exists","title":"exists","text":"<pre><code>exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.extension","title":"extension","text":"<pre><code>extension(fspath: str, *, period: bool = False) -&gt; str\n</code></pre> <p>Return the extension for a fspath</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import extension\n&gt;&gt;&gt; extension(\"foo.bar\")\n'bar'\n&gt;&gt;&gt; extension(\"foo.tar.gz\")\n'tar.gz'\n&gt;&gt;&gt; extension(\"foo.tar.gz\", period=True)\n'.tar.gz'\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.file_exists","title":"file_exists","text":"<pre><code>file_exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise; alias for isfile</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.file_exists_async","title":"file_exists_async  <code>async</code>","text":"<pre><code>file_exists_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the file exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.file_lines_gen","title":"file_lines_gen","text":"<pre><code>file_lines_gen(\n    filepath: FsPath, *, keepends: bool = True\n) -&gt; Iterable[str]\n</code></pre> <p>Yield lines from a given fspath</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Iterable[str]</code>           \u2013            <p>Lines from the given fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; string = '\\n'.join(str(i) for i in range(1, 10))\n&gt;&gt;&gt; string\n'1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9'\n&gt;&gt;&gt; fspath = \"file_lines_gen.doctest.txt\"\n&gt;&gt;&gt; from shellfish.fs import write_str\n&gt;&gt;&gt; write_str(fspath, string)\n17\n&gt;&gt;&gt; for file_line in file_lines_gen(fspath):\n...     file_line\n'1\\n'\n'2\\n'\n'3\\n'\n'4\\n'\n'5\\n'\n'6\\n'\n'7\\n'\n'8\\n'\n'9'\n&gt;&gt;&gt; for file_line in file_lines_gen(fspath, keepends=False):\n...     file_line\n'1'\n'2'\n'3'\n'4'\n'5'\n'6'\n'7'\n'8'\n'9'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.file_lines_gen(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File to yield lines from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.file_lines_gen(keepends)","title":"<code>keepends</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to keep the ends of the file lines</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filecmp","title":"filecmp","text":"<pre><code>filecmp(\n    left: FsPath,\n    right: FsPath,\n    *,\n    shallow: bool = True,\n    blocksize: int = 65536,\n) -&gt; bool\n</code></pre> <p>Compare 2 files for equality given their filepaths</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if files are equal, False otherwise</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filecmp(left)","title":"<code>left</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath 1</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filecmp(right)","title":"<code>right</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath 2</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filecmp(shallow)","title":"<code>shallow</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check only size and modification time if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filecmp(blocksize)","title":"<code>blocksize</code>","text":"(<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>Chunk size to read files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filepath_gen","title":"filepath_gen","text":"<pre><code>filepath_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filepath_mtimedelta_sec","title":"filepath_mtimedelta_sec","text":"<pre><code>filepath_mtimedelta_sec(filepath: FsPath) -&gt; float\n</code></pre> <p>Return the seconds since the file(path) was last modified</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen","title":"files_dirs_gen","text":"<pre><code>files_dirs_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; tuple[Iterator[str], Iterator[str]]\n</code></pre> <p>Return a files_gen() and a dirs_gen() in one swell-foop</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Iterator[str], Iterator[str]]</code>           \u2013            <p>A tuple of two generators (files_gen(), dirs_gen())</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'files_dirs_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = list(sorted(set(expected_dirs)))\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in expected_dirs]\n&gt;&gt;&gt; pprint(expected_dirs)\n['files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; _files, _dirs = files_dirs_gen(tmpdir)\n&gt;&gt;&gt; _files = list(_files)\n&gt;&gt;&gt; _dirs = list(_dirs)\n&gt;&gt;&gt; files_n_dirs_list = list(sorted(set(_files + _dirs)))\n&gt;&gt;&gt; files_n_dirs_list = [el.replace('\\\\', '/') for el in files_n_dirs_list]\n&gt;&gt;&gt; pprint(files_n_dirs_list)\n['files_dirs_gen.doctest',\n 'files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt',\n 'files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; expected = [el.replace('\\\\', '/') for el in expected]\n&gt;&gt;&gt; pprint(expected)\n['files_dirs_gen.doctest',\n 'files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt',\n 'files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; files_n_dirs_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_dirs_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check if dirpath is a directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen","title":"files_gen","text":"<pre><code>files_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield file-paths beneath a given dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields file-paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'files_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt',\n 'files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; files_list = list(sorted(set(files_gen(tmpdir))))\n&gt;&gt;&gt; files_list = [el.replace('\\\\', '/') for el in files_list]\n&gt;&gt;&gt; pprint(files_list)\n['files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt',\n 'files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; pprint(list(sorted(set(expected_files))))\n['files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt',\n 'files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; list(sorted(set(files_list))) == list(sorted(set(expected_files)))\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.files_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that dir exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filesize","title":"filesize","text":"<pre><code>filesize(fspath: FsPath) -&gt; int\n</code></pre> <p>Return the size of the given file(path) in bytes</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>size of the fspath in bytes</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filesize(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath as a string or pathlib.Path object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.filesize_async","title":"filesize_async  <code>async</code>","text":"<pre><code>filesize_async(fspath: FsPath) -&gt; int\n</code></pre> <p>Return the size of the file at the given fspath</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from tempfile import TemporaryDirectory\n&gt;&gt;&gt; with TemporaryDirectory() as tmpdir:\n...     tmpdir = Path(tmpdir)\n...     fpath = tmpdir / \"test.txt\"\n...     written = fpath.write_text(\"hello world\")\n...     aiorun(filesize_async(fpath))\n11\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.fspath","title":"fspath","text":"<pre><code>fspath(fspath: FsPath) -&gt; str\n</code></pre> <p>Alias for os._fspath; returns fspath string for any type of path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.glob","title":"glob","text":"<pre><code>glob(\n    pattern: str,\n    *,\n    recursive: bool = False,\n    r: bool = False,\n) -&gt; Iterator[str]\n</code></pre> <p>Return an iterator of fspaths matching the given glob pattern</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Iterator[str]: Iterator of fspaths matching the glob pattern</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.glob(pattern)","title":"<code>pattern</code>","text":"(<code>str</code>)           \u2013            <p>Glob pattern</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.glob(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively search directories if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.glob(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively search directories if True (Alias for recursive)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_dir","title":"is_dir","text":"<pre><code>is_dir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_dir_async","title":"is_dir_async  <code>async</code>","text":"<pre><code>is_dir_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_file","title":"is_file","text":"<pre><code>is_file(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; alias for isfile</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_file_async","title":"is_file_async  <code>async</code>","text":"<pre><code>is_file_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_link","title":"is_link","text":"<pre><code>is_link(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; alias for islink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.is_link_async","title":"is_link_async  <code>async</code>","text":"<pre><code>is_link_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.isdir","title":"isdir","text":"<pre><code>isdir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.isdir_async","title":"isdir_async  <code>async</code>","text":"<pre><code>isdir_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.isfile","title":"isfile","text":"<pre><code>isfile(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.isfile_async","title":"isfile_async  <code>async</code>","text":"<pre><code>isfile_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.islink","title":"islink","text":"<pre><code>islink(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.islink_async","title":"islink_async  <code>async</code>","text":"<pre><code>islink_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.listdir_async","title":"listdir_async  <code>async</code>","text":"<pre><code>listdir_async(fspath: FsPath) -&gt; list[str]\n</code></pre> <p>Async version of <code>os.listdir</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.listdir_gen","title":"listdir_gen","text":"<pre><code>listdir_gen(\n    fspath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    follow_symlinks: bool = True,\n    files: bool = True,\n    dirs: bool = True,\n    symlinks: bool = False,\n    files_only: bool = False,\n    dirs_only: bool = False,\n    symlinks_only: bool = False,\n) -&gt; Iterator[Path]\n</code></pre> <p>Return an iterator of strings from DirEntries</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'listdir_gen.doctest'\n&gt;&gt;&gt; from shellfish import sh\n&gt;&gt;&gt; from os import makedirs, path, chdir\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; pwd = sh.pwd()\n&gt;&gt;&gt; sh.cd(tmpdir)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"data1.json\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; dirpath = path.join(tmpdir, 'dir')\n&gt;&gt;&gt; dirpath.replace(\"\\\\\", \"/\")\n'listdir_gen.doctest/dir'\n&gt;&gt;&gt; sorted(listdir_gen(dirpath, dirs=False, symlinks=False))\n['data1.json', 'file1.txt', 'file2.txt', 'file3.txt']\n&gt;&gt;&gt; abspaths = sorted(listdir_gen(dirpath, abspath=True, dirs=False, symlinks=False))\n&gt;&gt;&gt; for abspath in [p.replace(\"\\\\\", \"/\") for p in abspaths]:\n...    print(abspath)\nlistdir_gen.doctest/dir/data1.json\nlistdir_gen.doctest/dir/file1.txt\nlistdir_gen.doctest/dir/file2.txt\nlistdir_gen.doctest/dir/file3.txt\n&gt;&gt;&gt; sh.cd(pwd)\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; if path.exists(tmpdir):\n...     rmtree(tmpdir)\n&gt;&gt;&gt; path.isdir(tmpdir)\nFalse\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.lstat_async","title":"lstat_async  <code>async</code>","text":"<pre><code>lstat_async(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Async version of <code>os.lstat</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.mkdir","title":"mkdir","text":"<pre><code>mkdir(\n    fspath: FsPath,\n    *,\n    parents: bool = False,\n    p: bool = False,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make directory at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.mkdir(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory path to create</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.mkdir(parents)","title":"<code>parents</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make parent dirs if True; do not make parent dirs if False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.mkdir(p)","title":"<code>p</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make parent dirs if True; do not make parent dirs if False (alias of parents)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.mkdir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Throw error if directory exists and exist_ok is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.mkdirp","title":"mkdirp","text":"<pre><code>mkdirp(fspath: FsPath) -&gt; None\n</code></pre> <p>Make directory and parents</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.move","title":"move","text":"<pre><code>move(src: FsPath, dest: FsPath) -&gt; None\n</code></pre> <p>Move file(s) like on the command line</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.move(src)","title":"<code>src</code>","text":"(<code>FsPath</code>)           \u2013            <p>source file(s)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.move(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>destination path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.path_gen","title":"path_gen","text":"<pre><code>path_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes","title":"read_bytes","text":"<pre><code>read_bytes(filepath: FsPath) -&gt; bytes\n</code></pre> <p>Read bytes from a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes from the fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"rbytes.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; write_bytes(fspath, bites_to_save)\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath read as bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes_async","title":"read_bytes_async  <code>async</code>","text":"<pre><code>read_bytes_async(filepath: FsPath) -&gt; bytes\n</code></pre> <p>(ASYNC) Load/Read bytes from a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes from the fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs._async import read_bytes_async, write_bytes_async\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; fspath = \"rbytes_async.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; aiorun(write_bytes_async(fspath, bites_to_save))\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; aiorun(read_bytes_async(fspath))\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath read as bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes_gen","title":"read_bytes_gen","text":"<pre><code>read_bytes_gen(\n    filepath: FsPath, blocksize: int = 65536\n) -&gt; Iterable[bytes]\n</code></pre> <p>Yield bytes from a given fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes_gen_async","title":"read_bytes_gen_async  <code>async</code>","text":"<pre><code>read_bytes_gen_async(\n    filepath: FsPath, blocksize: int = 65536\n) -&gt; AsyncIterable[bytes]\n</code></pre> <p>Yield (asynchronously) bytes from a given fspath</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>AsyncIterable[bytes]</code>           \u2013            <p>bytes from AsyncIterable[bytes] of the file bytes</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import write_bytes_gen_async, read_bytes_gen_async\n&gt;&gt;&gt; fspath = 'rbytes_gen_async.doctest.txt'\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; async def read():\n...     async for b in read_bytes_gen_async(fspath, blocksize=4):\n...         print(b)\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; async def async_gen():\n...     for b in bites_to_save:\n...        yield b\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, AsyncIterable()))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes_gen_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to read from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_bytes_gen_async(blocksize)","title":"<code>blocksize</code>","text":"(<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>size of the block to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_json","title":"read_json","text":"<pre><code>read_json(filepath: FsPath) -&gt; Any\n</code></pre> <p>Load/Read-&amp;-parse json data given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Parsed JSON data</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_json, write_json\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n19\n&gt;&gt;&gt; read_json(fspath)\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n25\n&gt;&gt;&gt; read_json(fspath)\n[['a', 1], ['b', 2], ['c', 3]]\n&gt;&gt;&gt; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_json(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to load/read data from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_json_async","title":"read_json_async  <code>async</code>","text":"<pre><code>read_json_async(filepath: FsPath) -&gt; Any\n</code></pre> <p>Load/Read-&amp;-parse json data given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Parsed JSON data</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import read_json_async, write_json_async\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_async_dict.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n19\n&gt;&gt;&gt; run(read_json_async(fspath))\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_async_list.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n25\n&gt;&gt;&gt; run(read_json_async(fspath))\n[['a', 1], ['b', 2], ['c', 3]]\n</code></pre> <pre><code>&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_json_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to load/read data from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_str","title":"read_str","text":"<pre><code>read_str(\n    filepath: FsPath, *, encoding: str = \"utf-8\"\n) -&gt; str\n</code></pre> <p>Load/Read a string given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>String read from given fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_str, write_str\n&gt;&gt;&gt; fspath = \"read_str.doctest.txt\"\n&gt;&gt;&gt; write_str(fspath, r'Check out this string')\n21\n&gt;&gt;&gt; read_str(fspath)\n'Check out this string'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_str(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath for file to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>Encoding to use for reading the file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_str_async","title":"read_str_async  <code>async</code>","text":"<pre><code>read_str_async(\n    filepath: FsPath, encoding: str = \"utf-8\"\n) -&gt; str\n</code></pre> <p>(ASYNC) Load/Read a string given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>String read from given fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_str_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath for file to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.read_str_async(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>File encoding (Default='utf-8')</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm","title":"rm","text":"<pre><code>rm(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n    dryrun: bool = False,\n    verbose: bool = False,\n) -&gt; list[str] | None\n</code></pre> <p>Remove files &amp; directories in the style of the shell</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If recursive and r are <code>False</code> and fspath is a directory</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>ignore errors and missing files/dirs; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to remove recursively (like the <code>-r</code> in <code>rm -r dir</code>)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Print the files being removed</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm_gen","title":"rm_gen","text":"<pre><code>rm_gen(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n    dryrun: bool = False,\n) -&gt; Generator[str, Any, Any]\n</code></pre> <p>Remove files &amp; directories in the style of the shell</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If recursive and r are <code>False</code> and fspath is a directory</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm_gen(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm_gen(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force removal of files and directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm_gen(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to remove recursively (like the <code>-r</code> in <code>rm -r dir</code>)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rm_gen(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmdir","title":"rmdir","text":"<pre><code>rmdir(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n) -&gt; None\n</code></pre> <p>Remove directory at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmdir(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory path to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmdir(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force removal of files and directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmdir(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively remove all contents if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmfile","title":"rmfile","text":"<pre><code>rmfile(fspath: FsPath, *, dryrun: bool = False) -&gt; str\n</code></pre> <p>Remove a file at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmfile(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.rmfile(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.safepath","title":"safepath","text":"<pre><code>safepath(fspath: FsPath) -&gt; str\n</code></pre> <p>Check if a file/dir path is save/unused; returns an unused path.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>file/dir path that does not exist and contains the given path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.safepath(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>file-system path; file or directory path string or Path obj</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir","title":"scandir","text":"<pre><code>scandir(\n    dirpath: FsPath = \".\",\n) -&gt; Iterable[DirEntry[AnyStr]]\n</code></pre> <p>Typed version of os.scandir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen","title":"scandir_gen","text":"<pre><code>scandir_gen(\n    fspath: FsPath = \".\",\n    *,\n    recursive: bool = False,\n    follow_symlinks: bool = True,\n    files: bool = True,\n    dirs: bool = True,\n    symlinks: bool = True,\n    files_only: bool = False,\n    dirs_only: bool = False,\n    symlinks_only: bool = False,\n) -&gt; Iterator[DirEntry[str]]\n</code></pre> <p>Return an iterator of os.DirEntry objects</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[DirEntry[str]]</code>           \u2013            <p>Iterator[DirEntry]: Iterator of os.DirEntry objects</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if any of the kwargs (<code>dirs</code>, <code>files</code> and <code>symlinks</code>) are not True</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>(FsPath): dirpath to look through</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>recursively scan the directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(follow_symlinks)","title":"<code>follow_symlinks</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>follow symlinks when checking for dirs and files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(files)","title":"<code>files</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(dirs)","title":"<code>dirs</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(symlinks)","title":"<code>symlinks</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include symlinks</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(dirs_only)","title":"<code>dirs_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(files_only)","title":"<code>files_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_gen(symlinks_only)","title":"<code>symlinks_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include symlinks</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_list","title":"scandir_list","text":"<pre><code>scandir_list(\n    dirpath: FsPath = \".\",\n) -&gt; list[DirEntry[AnyStr]]\n</code></pre> <p>Return a list of os.DirEntry objects</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[DirEntry[AnyStr]]</code>           \u2013            <p>list[DirEntry]: List of os.DirEntry objects</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.scandir_list(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Dirpath to scan</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.sep_join","title":"sep_join","text":"<pre><code>sep_join(path_strings: Iterator[str]) -&gt; str\n</code></pre> <p>Join iterable of strings on the current platform os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.sep_lstrip","title":"sep_lstrip","text":"<pre><code>sep_lstrip(fspath: FsPath) -&gt; str\n</code></pre> <p>Left-strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.sep_rstrip","title":"sep_rstrip","text":"<pre><code>sep_rstrip(fspath: FsPath) -&gt; str\n</code></pre> <p>Right-strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.sep_split","title":"sep_split","text":"<pre><code>sep_split(fspath: FsPath) -&gt; tuple[str, ...]\n</code></pre> <p>Split a string on the current platform os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.sep_strip","title":"sep_strip","text":"<pre><code>sep_strip(fspath: FsPath) -&gt; str\n</code></pre> <p>Strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.shebang","title":"shebang","text":"<pre><code>shebang(fspath: FsPath) -&gt; str | None\n</code></pre> <p>Get the shebang string given a fspath; Returns None if no shebang</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: The shebang string if it exists, None otherwise</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from inspect import getabsfile\n&gt;&gt;&gt; script = 'ashellscript.sh'\n&gt;&gt;&gt; with open(script, 'w') as f:\n...     f.write('#!/bin/bash\\necho \"howdy\"\\n')\n25\n&gt;&gt;&gt; shebang(script)\n'#!/bin/bash'\n&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; remove(script)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.shebang(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file that might have a shebang</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.stat","title":"stat","text":"<pre><code>stat(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Return the os.stat_result object for a given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>stat_result</code>           \u2013            <p>os.stat_result: stat_result object</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.stat(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.stat_async","title":"stat_async  <code>async</code>","text":"<pre><code>stat_async(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Async version of <code>os.stat</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.touch","title":"touch","text":"<pre><code>touch(fspath: FsPath, *, mkdirp: bool = True) -&gt; None\n</code></pre> <p>Create an empty file given a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.touch(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path for where to make an empty file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.touch(mkdirp)","title":"<code>mkdirp</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Make parent directories if they don't exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen","title":"walk_gen","text":"<pre><code>walk_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield all paths beneath a given dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields directory paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'walk_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f).replace('\\\\', '/')\n...     fspath = path.join(tmpdir, fspath).replace('\\\\', '/')\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in sorted(set(expected_dirs))]\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint(expected_files)\n['walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; pprint(expected_dirs)\n['walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; walk_gen_list = list(sorted(walk_gen(tmpdir)))\n&gt;&gt;&gt; walk_gen_list = [el.replace('\\\\', '/') for el in walk_gen_list]\n&gt;&gt;&gt; pprint(walk_gen_list)\n['walk_gen.doctest',\n 'walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt',\n 'walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; pprint(expected)\n['walk_gen.doctest',\n 'walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt',\n 'walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; walk_gen_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.walk_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check if dirpath exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes","title":"write_bytes","text":"<pre><code>write_bytes(\n    filepath: FsPath,\n    bites: bytes,\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/Save bytes to a fspath</p> <p>The parameter 'bites' is used instead of 'bytes' to not redefine the built-in python bytes object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"wbytes.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; write_bytes(fspath, bites_to_save)\n20\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the file after writing; default is None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_async","title":"write_bytes_async  <code>async</code>","text":"<pre><code>write_bytes_async(\n    filepath: FsPath,\n    bites: bytes,\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>(ASYNC) Write/Save bytes to a fspath</p> <p>The parameter 'bites' is used instead of 'bytes' so as to not redefine the built-in python bytes object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs._async import read_bytes_async, write_bytes_async\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; fspath = \"wbytes_async.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; aiorun(write_bytes_async(fspath, bites_to_save))\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; aiorun(read_bytes_async(fspath))\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; otherwise overwrite</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_async(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_async(chmod)","title":"<code>chmod</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath to this mode after writing</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen","title":"write_bytes_gen","text":"<pre><code>write_bytes_gen(\n    filepath: FsPath,\n    bytes_gen: Iterable[bytes],\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/Save bytes to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"wbytes_gen.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save  # they are bytes!\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; write_bytes_gen(fspath, (b for b in bites_to_save))\n35\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes... more bytes!'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen(bytes_gen)","title":"<code>bytes_gen</code>","text":"(<code>Iterable[bytes]</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the file after writing; default is None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen_async","title":"write_bytes_gen_async  <code>async</code>","text":"<pre><code>write_bytes_gen_async(\n    filepath: FsPath,\n    bytes_gen: Iterable[bytes] | AsyncIterable[bytes],\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/save bytes to a filepath from an (async)iterable/iterator of bytes</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import write_bytes_gen_async, read_bytes_gen_async\n&gt;&gt;&gt; fspath = 'wbytes_gen_async.doctest.txt'\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; async def read():\n...     async for b in read_bytes_gen_async(fspath, blocksize=4):\n...         print(b)\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; async def async_gen():\n...     for b in bites_to_save:\n...        yield b\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, AsyncIterable()))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen_async(bytes_gen)","title":"<code>bytes_gen</code>","text":"(<code>Iterable[bytes] | AsyncIterable[bytes]</code>)           \u2013            <p>AsyncIterable/Iterator of bytes to write</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; otherwise overwrite</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_bytes_gen_async(chmod)","title":"<code>chmod</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json","title":"write_json","text":"<pre><code>write_json(\n    filepath: FsPath,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    chmod: int | None = None,\n    append: bool = False,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Save/Write json-serial-ize-able data to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_json, write_json\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n19\n&gt;&gt;&gt; read_json(fspath)\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n25\n&gt;&gt;&gt; read_json(fspath)\n[['a', 1], ['b', 2], ['c', 3]]\n&gt;&gt;&gt; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(data)","title":"<code>data</code>","text":"(<code>Any</code>)           \u2013            <p>json-serial-ize-able data</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline to the end of the file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional chmod to set on file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to jsonbourne.JSON.dumpb</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async","title":"write_json_async  <code>async</code>","text":"<pre><code>write_json_async(\n    filepath: FsPath,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    append: bool = False,\n    chmod: int | None = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Save/Write json-serial-ize-able data to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import read_json_async, write_json_async\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"wjson_async_dict.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n19\n&gt;&gt;&gt; run(read_json_async(fspath))\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"wjson_async_list.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n25\n&gt;&gt;&gt; run(read_json_async(fspath))\n[['a', 1], ['b', 2], ['c', 3]]\n</code></pre> <pre><code>&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(data)","title":"<code>data</code>","text":"(<code>Any</code>)           \u2013            <p>json-serial-ize-able data</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_json_async(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to jsonbourne.JSON.dump</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str","title":"write_str","text":"<pre><code>write_str(\n    filepath: FsPath,\n    string: str,\n    *,\n    encoding: str = \"utf-8\",\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Save/Write a string to fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_str, write_str\n&gt;&gt;&gt; fspath = \"sstring.doctest.txt\"\n&gt;&gt;&gt; write_str(fspath, r'Check out this string')\n21\n&gt;&gt;&gt; read_str(fspath)\n'Check out this string'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>String encoding to write file with</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file; default = False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional chmod to set on file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str_async","title":"write_str_async  <code>async</code>","text":"<pre><code>write_str_async(\n    filepath: FsPath,\n    string: str,\n    *,\n    encoding: str = \"utf-8\",\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>(ASYNC) Save/Write a string to fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>number of bytes written</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str_async(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str_async(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>File encoding (Default='utf-8')</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.fs.write_str_async(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh","title":"sh","text":"<p>shell utils</p> <p>Classes:</p> <ul> <li> <code>Done</code>           \u2013            <p>Completed subprocess</p> </li> <li> <code>DoneError</code>           \u2013            <p>Error raised when a process returns a non-zero/ok exit status</p> </li> <li> <code>Flag</code>           \u2013            <p>Flag obj</p> </li> <li> <code>FlagMeta</code>           \u2013            <p>Meta class</p> </li> <li> <code>HrTime</code>           \u2013            <p>High resolution time</p> </li> <li> <code>HrTimeDict</code>           \u2013            <p>High resolution time</p> </li> <li> <code>LIN</code>           \u2013            <p>Linux (and Mac) shell commands/methods container</p> </li> <li> <code>Stdio</code>           \u2013            <p>Standard-io enum object</p> </li> <li> <code>WIN</code>           \u2013            <p>Windows shell commands/methods container</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>basename</code>             \u2013              <p>Return the basename of given path; alias of os.path.dirname</p> </li> <li> <code>cd</code>             \u2013              <p>Change directory to given dirpath; alias for <code>os.chdir</code></p> </li> <li> <code>chmod</code>             \u2013              <p>Change the access permissions of a file</p> </li> <li> <code>copy_file</code>             \u2013              <p>Copy a file given a source-path and a destination-path</p> </li> <li> <code>cp</code>             \u2013              <p>Copy the directory/file src to the directory/file dest</p> </li> <li> <code>decode_stdio_bytes</code>             \u2013              <p>Return Stdio bytes from stdout/stderr as a string</p> </li> <li> <code>dir_exists</code>             \u2013              <p>Return True if the given path exists; False otherwise; alias for isdir</p> </li> <li> <code>dir_exists_async</code>             \u2013              <p>Return True if the directory exists; False otherwise</p> </li> <li> <code>dirname</code>             \u2013              <p>Return dirname/parent-dir of given path; alias of os.path.dirname</p> </li> <li> <code>dirpath_gen</code>             \u2013              <p>Yield all dirpaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>dirs_gen</code>             \u2013              <p>Yield directory-paths beneath a dirpath (defaults to os.getcwd())</p> </li> <li> <code>do</code>             \u2013              <p>Run a subprocess synchronously</p> </li> <li> <code>do_async</code>             \u2013              <p>Run a subprocess and await its completion</p> </li> <li> <code>do_asyncify</code>             \u2013              <p>Run a subprocess asynchronously using asyncified version of do</p> </li> <li> <code>doa</code>             \u2013              <p>Run a subprocess and await its completion</p> </li> <li> <code>echo</code>             \u2013              <p>Print/echo function</p> </li> <li> <code>exists</code>             \u2013              <p>Return True if the given path exists; False otherwise</p> </li> <li> <code>export</code>             \u2013              <p>Export/Set an environment variable</p> </li> <li> <code>extension</code>             \u2013              <p>Return the extension for a fspath</p> </li> <li> <code>file_exists</code>             \u2013              <p>Return True if the given path exists; False otherwise; alias for isfile</p> </li> <li> <code>file_exists_async</code>             \u2013              <p>Return True if the file exists; False otherwise</p> </li> <li> <code>file_lines_gen</code>             \u2013              <p>Yield lines from a given fspath</p> </li> <li> <code>filecmp</code>             \u2013              <p>Compare 2 files for equality given their filepaths</p> </li> <li> <code>filepath_gen</code>             \u2013              <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>filepath_mtimedelta_sec</code>             \u2013              <p>Return the seconds since the file(path) was last modified</p> </li> <li> <code>files_dirs_gen</code>             \u2013              <p>Return a files_gen() and a dirs_gen() in one swell-foop</p> </li> <li> <code>files_gen</code>             \u2013              <p>Yield file-paths beneath a given dirpath (defaults to os.getcwd())</p> </li> <li> <code>filesize</code>             \u2013              <p>Return the size of the given file(path) in bytes</p> </li> <li> <code>filesize_async</code>             \u2013              <p>Return the size of the file at the given fspath</p> </li> <li> <code>flatten_args</code>             \u2013              <p>Flatten possibly nested iterables of sequences to a list of strings</p> </li> <li> <code>fspath</code>             \u2013              <p>Alias for os._fspath; returns fspath string for any type of path</p> </li> <li> <code>glob</code>             \u2013              <p>Return an iterator of fspaths matching the given glob pattern</p> </li> <li> <code>is_dir</code>             \u2013              <p>Return True if the given path is a directory; alias for isdir</p> </li> <li> <code>is_dir_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>is_file</code>             \u2013              <p>Return True if the given path is a file; alias for isfile</p> </li> <li> <code>is_file_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>is_link</code>             \u2013              <p>Return True if the given path is a link; alias for islink</p> </li> <li> <code>is_link_async</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>isdir</code>             \u2013              <p>Return True if the given path is a directory; False otherwise</p> </li> <li> <code>isdir_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>isfile</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>isfile_async</code>             \u2013              <p>Return True if the given path is a file; False otherwise</p> </li> <li> <code>islink</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>islink_async</code>             \u2013              <p>Return True if the given path is a link; False otherwise</p> </li> <li> <code>listdir_async</code>             \u2013              <p>Async version of <code>os.listdir</code></p> </li> <li> <code>listdir_gen</code>             \u2013              <p>Return an iterator of strings from DirEntries</p> </li> <li> <code>ls</code>             \u2013              <p>List files and dirs given a dirpath (defaults to pwd)</p> </li> <li> <code>ls_async</code>             \u2013              <p>List files and dirs given a dirpath (defaults to pwd)</p> </li> <li> <code>ls_dirs</code>             \u2013              <p>List the directories in a given directory path</p> </li> <li> <code>ls_files</code>             \u2013              <p>List the files in a given directory path</p> </li> <li> <code>ls_files_dirs</code>             \u2013              <p>List the files and directories given directory path</p> </li> <li> <code>lstat_async</code>             \u2013              <p>Async version of <code>os.lstat</code></p> </li> <li> <code>mkdir</code>             \u2013              <p>Make directory at given fspath</p> </li> <li> <code>mkdirp</code>             \u2013              <p>Make directory and parents</p> </li> <li> <code>move</code>             \u2013              <p>Move file(s) like on the command line</p> </li> <li> <code>mv</code>             \u2013              <p>Move file(s) like on the command line</p> </li> <li> <code>path_gen</code>             \u2013              <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p> </li> <li> <code>pstderr</code>             \u2013              <p>Get the STDERR as a string from a subprocess</p> </li> <li> <code>pstdout</code>             \u2013              <p>Get the STDOUT as a string from a subprocess</p> </li> <li> <code>pstdout_pstderr</code>             \u2013              <p>Get the STDOUT and STDERR as strings from a subprocess</p> </li> <li> <code>pwd</code>             \u2013              <p>Return present-working-directory path string; alias for os.getcwd</p> </li> <li> <code>q</code>             \u2013              <p>Typed alias for shlex.quote</p> </li> <li> <code>quote</code>             \u2013              <p>Typed alias for shlex.quote</p> </li> <li> <code>read_bytes</code>             \u2013              <p>Read bytes from a fspath</p> </li> <li> <code>read_bytes_async</code>             \u2013              <p>(ASYNC) Load/Read bytes from a fspath</p> </li> <li> <code>read_bytes_gen</code>             \u2013              <p>Yield bytes from a given fspath</p> </li> <li> <code>read_bytes_gen_async</code>             \u2013              <p>Yield (asynchronously) bytes from a given fspath</p> </li> <li> <code>read_json</code>             \u2013              <p>Load/Read-&amp;-parse json data given a fspath</p> </li> <li> <code>read_json_async</code>             \u2013              <p>Load/Read-&amp;-parse json data given a fspath</p> </li> <li> <code>read_str</code>             \u2013              <p>Load/Read a string given a fspath</p> </li> <li> <code>read_str_async</code>             \u2013              <p>(ASYNC) Load/Read a string given a fspath</p> </li> <li> <code>rm</code>             \u2013              <p>Remove files &amp; directories in the style of the shell</p> </li> <li> <code>rm_gen</code>             \u2013              <p>Remove files &amp; directories in the style of the shell</p> </li> <li> <code>rmdir</code>             \u2013              <p>Remove directory at given fspath</p> </li> <li> <code>rmfile</code>             \u2013              <p>Remove a file at given fspath</p> </li> <li> <code>safepath</code>             \u2013              <p>Check if a file/dir path is save/unused; returns an unused path.</p> </li> <li> <code>scandir</code>             \u2013              <p>Typed version of os.scandir</p> </li> <li> <code>scandir_gen</code>             \u2013              <p>Return an iterator of os.DirEntry objects</p> </li> <li> <code>scandir_list</code>             \u2013              <p>Return a list of os.DirEntry objects</p> </li> <li> <code>sep_join</code>             \u2013              <p>Join iterable of strings on the current platform os.path.sep value</p> </li> <li> <code>sep_lstrip</code>             \u2013              <p>Left-strip a string of the current platform's os.path.sep value</p> </li> <li> <code>sep_rstrip</code>             \u2013              <p>Right-strip a string of the current platform's os.path.sep value</p> </li> <li> <code>sep_split</code>             \u2013              <p>Split a string on the current platform os.path.sep value</p> </li> <li> <code>sep_strip</code>             \u2013              <p>Strip a string of the current platform's os.path.sep value</p> </li> <li> <code>setenv</code>             \u2013              <p>Export/Set an environment variable</p> </li> <li> <code>shebang</code>             \u2013              <p>Get the shebang string given a fspath; Returns None if no shebang</p> </li> <li> <code>shell</code>             \u2013              <p>Run a subprocess synchronously in current shell</p> </li> <li> <code>shplit</code>             \u2013              <p>Typed alias for shlex.split</p> </li> <li> <code>source</code>             \u2013              <p>Execute/run a python file given a fspath and put globals in globasl</p> </li> <li> <code>stat</code>             \u2013              <p>Return the os.stat_result object for a given fspath</p> </li> <li> <code>stat_async</code>             \u2013              <p>Async version of <code>os.stat</code></p> </li> <li> <code>touch</code>             \u2013              <p>Create an empty file given a fspath</p> </li> <li> <code>tree</code>             \u2013              <p>Create a directory tree string given a directory path</p> </li> <li> <code>walk_gen</code>             \u2013              <p>Yield all paths beneath a given dirpath (defaults to os.getcwd())</p> </li> <li> <code>where</code>             \u2013              <p>Return the result of <code>shutil.which</code>; alias of shellfish.sh.which</p> </li> <li> <code>which</code>             \u2013              <p>Return the result of <code>shutil.which</code></p> </li> <li> <code>which_lru</code>             \u2013              <p>Return the result of <code>shutil.which</code> and cache the results</p> </li> <li> <code>write_bytes</code>             \u2013              <p>Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_async</code>             \u2013              <p>(ASYNC) Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_gen</code>             \u2013              <p>Write/Save bytes to a fspath</p> </li> <li> <code>write_bytes_gen_async</code>             \u2013              <p>Write/save bytes to a filepath from an (async)iterable/iterator of bytes</p> </li> <li> <code>write_json</code>             \u2013              <p>Save/Write json-serial-ize-able data to a fspath</p> </li> <li> <code>write_json_async</code>             \u2013              <p>Save/Write json-serial-ize-able data to a fspath</p> </li> <li> <code>write_str</code>             \u2013              <p>Save/Write a string to fspath</p> </li> <li> <code>write_str_async</code>             \u2013              <p>(ASYNC) Save/Write a string to fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done","title":"Done","text":"<p>               Bases: <code>_ShellfishBaseModel</code></p> <p>Completed subprocess</p> <p>Methods:</p> <ul> <li> <code>check</code>             \u2013              <p>Check returncode and stderr</p> </li> <li> <code>completed_process</code>             \u2013              <p>Return subprocess.CompletedProcess object</p> </li> <li> <code>done_dict</code>             \u2013              <p>Return Done object as typed-dict</p> </li> <li> <code>grep</code>             \u2013              <p>Return lines in stdout that have</p> </li> <li> <code>json_parse</code>             \u2013              <p>Return json parsed stdout</p> </li> <li> <code>json_parse_stderr</code>             \u2013              <p>Return json parsed stderr</p> </li> <li> <code>json_parse_stdout</code>             \u2013              <p>Return json parsed stdout</p> </li> <li> <code>parse_json</code>             \u2013              <p>Return json parsed stdout (alias bc I keep flip-flopping the fn name)</p> </li> <li> <code>sys_print</code>             \u2013              <p>Write self.stdout to sys.stdout and self.stderr to sys.stderr</p> </li> <li> <code>write_stderr</code>             \u2013              <p>Write stderr as a string to a fspath</p> </li> <li> <code>write_stdout</code>             \u2013              <p>Write stdout as a string to a fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.check","title":"check","text":"<pre><code>check(\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n) -&gt; None\n</code></pre> <p>Check returncode and stderr</p> <p>Raises:</p> <ul> <li> <code>DoneError</code>             \u2013            <p>If return code is non-zero and stderr is not None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.completed_process","title":"completed_process","text":"<pre><code>completed_process() -&gt; CompletedProcess[str]\n</code></pre> <p>Return subprocess.CompletedProcess object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.done_dict","title":"done_dict","text":"<pre><code>done_dict() -&gt; DoneDict\n</code></pre> <p>Return Done object as typed-dict</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.grep","title":"grep","text":"<pre><code>grep(string: str) -&gt; list[str]\n</code></pre> <p>Return lines in stdout that have</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of strings of stdout lines containing the given search string</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.grep(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>String to search for</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.json_parse","title":"json_parse","text":"<pre><code>json_parse(\n    *,\n    stderr: bool = False,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stdout</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.json_parse_stderr","title":"json_parse_stderr","text":"<pre><code>json_parse_stderr(\n    *,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.json_parse_stdout","title":"json_parse_stdout","text":"<pre><code>json_parse_stdout(\n    *,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stdout</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.parse_json","title":"parse_json","text":"<pre><code>parse_json(\n    *,\n    stderr: bool = False,\n    jsonc: bool = False,\n    jsonl: bool = False,\n    ndjson: bool = False,\n) -&gt; Any\n</code></pre> <p>Return json parsed stdout (alias bc I keep flip-flopping the fn name)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.sys_print","title":"sys_print","text":"<pre><code>sys_print() -&gt; None\n</code></pre> <p>Write self.stdout to sys.stdout and self.stderr to sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.write_stderr","title":"write_stderr","text":"<pre><code>write_stderr(\n    filepath: FsPath, *, append: bool = False\n) -&gt; None\n</code></pre> <p>Write stderr as a string to a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.write_stderr(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath of location to write stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.write_stderr(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file or plain write to file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.write_stdout","title":"write_stdout","text":"<pre><code>write_stdout(\n    filepath: FsPath, *, append: bool = False\n) -&gt; None\n</code></pre> <p>Write stdout as a string to a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.write_stdout(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to write stdout to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Done.write_stdout(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file or plain write to file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.DoneError","title":"DoneError","text":"<pre><code>DoneError(done: Done)\n</code></pre> <p>               Bases: <code>SubprocessError</code></p> <p>Error raised when a process returns a non-zero/ok exit status</p> <p>Attributes:</p> <ul> <li> <code>cmd</code>               (<code>str</code>)           \u2013            <p>command that was run</p> </li> <li> <code>returncode</code>               (<code>int</code>)           \u2013            <p>exit status of the process</p> </li> <li> <code>stdout</code>               (<code>str</code>)           \u2013            <p>standard output (stdout) of the process</p> </li> <li> <code>stderr</code>               (<code>str</code>)           \u2013            <p>standard error (stderr) of the process</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Flag","title":"Flag","text":"<p>Flag obj</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Flag.__help\n'--help'\n&gt;&gt;&gt; Flag._v\n'-v'\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.FlagMeta","title":"FlagMeta","text":"<p>               Bases: <code>type</code></p> <p>Meta class</p> <p>Methods:</p> <ul> <li> <code>attr2flag</code>             \u2013              <p>Convert and return attr to string</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.FlagMeta.attr2flag","title":"attr2flag  <code>cached</code> <code>staticmethod</code>","text":"<pre><code>attr2flag(string: str) -&gt; str\n</code></pre> <p>Convert and return attr to string</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.HrTime","title":"HrTime","text":"<p>               Bases: <code>_ShellfishBaseModel</code></p> <p>High resolution time</p> <p>Methods:</p> <ul> <li> <code>from_seconds</code>             \u2013              <p>Return HrTime object from seconds</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.HrTime.from_seconds","title":"from_seconds  <code>classmethod</code>","text":"<pre><code>from_seconds(seconds: float) -&gt; HrTime\n</code></pre> <p>Return HrTime object from seconds</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>HrTime</code>           \u2013            <p>HrTime object</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.HrTime.from_seconds(seconds)","title":"<code>seconds</code>","text":"(<code>float</code>)           \u2013            <p>number of seconds</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.HrTimeDict","title":"HrTimeDict","text":"<p>               Bases: <code>TypedDict</code></p> <p>High resolution time</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN","title":"LIN","text":"<p>               Bases: <code>LIN</code></p> <p>Linux (and Mac) shell commands/methods container</p> <p>Methods:</p> <ul> <li> <code>link_dir</code>             \u2013              <p>Make a directory symlink</p> </li> <li> <code>link_dirs</code>             \u2013              <p>Make multiple directory symlinks</p> </li> <li> <code>link_file</code>             \u2013              <p>Make a file symlink</p> </li> <li> <code>link_files</code>             \u2013              <p>Make multiple file symlinks</p> </li> <li> <code>rsync</code>             \u2013              <p>Run an <code>rsync</code> subprocess</p> </li> <li> <code>rsync_args</code>             \u2013              <p>Return args for rsync command on linux/mac</p> </li> <li> <code>unlink_dir</code>             \u2013              <p>Unlink a directory symlink given a path to the symlink</p> </li> <li> <code>unlink_dirs</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> <li> <code>unlink_file</code>             \u2013              <p>Unlink a file symlink given a path to the symlink</p> </li> <li> <code>unlink_files</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dir","title":"link_dir  <code>staticmethod</code>","text":"<pre><code>link_dir(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a directory symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dir(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dir(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>str</code>, default:                   <code>False</code> )           \u2013            <p>Allow link to exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dirs","title":"link_dirs  <code>staticmethod</code>","text":"<pre><code>link_dirs(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple directory symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dirs(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_dirs(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow link to exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_file","title":"link_file  <code>staticmethod</code>","text":"<pre><code>link_file(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a file symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_file(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_file(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_file(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow links to already exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_files","title":"link_files  <code>staticmethod</code>","text":"<pre><code>link_files(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple file symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_files(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Allow links to already exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.link_files(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync","title":"rsync  <code>staticmethod</code>","text":"<pre><code>rsync(\n    src: str,\n    dest: str,\n    *,\n    delete: bool = False,\n    mkdirs: bool = False,\n    dry_run: bool = False,\n    exclude: Iterable[str] | None = None,\n    include: Iterable[str] | None = None,\n) -&gt; Done\n</code></pre> <p>Run an <code>rsync</code> subprocess</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code> (              <code>Done</code> )          \u2013            <p>Done object containing the info for the rsync run</p> </li> </ul> <p>Rsync return codes::</p> <pre><code>- 0 == Success\n- 1 == Syntax or usage error\n- 2 == Protocol incompatibility\n- 3 == Errors selecting input/output files, dirs\n- 4 == Requested  action not supported: an attempt was made to\n  manipulate 64-bit files on a platform that cannot support them;\n  or an option was specified that is supported by the client and\n  not the server.\n- 5 == Error starting client-server protocol\n- 6 == Daemon unable to append to log-file\n- 10 == Error in socket I/O\n- 11 == Error in file I/O\n- 12 == Error in rsync protocol data stream\n- 13 == Errors with program diagnostics\n- 14 == Error in IPC code\n- 20 == Received SIGUSR1 or SIGINT\n- 21 == Some error returned by waitpid()\n- 22 == Error allocating core memory buffers\n- 23 == Partial transfer due to error\n- 24 == Partial transfer due to vanished source files\n- 25 == The --max-delete limit stopped deletions\n- 30 == Timeout in data send2viewserver/receive\n- 35 == Timeout waiting for daemon connection\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(mkdirs)","title":"<code>mkdirs</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make destination directories if they do not already exist; defaults to False.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source directory path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>Destination directory path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Delete files/directories in destination if they do exist in source</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(exclude)","title":"<code>exclude</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to exclude</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(include)","title":"<code>include</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to include</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Perform operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args","title":"rsync_args  <code>staticmethod</code>","text":"<pre><code>rsync_args(\n    src: str,\n    dest: str,\n    *,\n    delete: bool = False,\n    dry_run: bool = False,\n    exclude: Iterable[str] | None = None,\n    include: Iterable[str] | None = None,\n) -&gt; list[str]\n</code></pre> <p>Return args for rsync command on linux/mac</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>subprocess return code from rsync</p> </li> </ul> <p>Rsync return codes::</p> <pre><code>- 0 == Success\n- 1 == Syntax or usage error\n- 2 == Protocol incompatibility\n- 3 == Errors selecting input/output files, dirs\n- 4 == Requested  action not supported: an attempt was made to\n  manipulate 64-bit files on a platform that cannot support them;\n  or an option was specified that is supported by the client and\n  not the server.\n- 5 == Error starting client-server protocol\n- 6 == Daemon unable to append to log-file\n- 10 == Error in socket I/O\n- 11 == Error in file I/O\n- 12 == Error in rsync protocol data stream\n- 13 == Errors with program diagnostics\n- 14 == Error in IPC code\n- 20 == Received SIGUSR1 or SIGINT\n- 21 == Some error returned by waitpid()\n- 22 == Error allocating core memory buffers\n- 23 == Partial transfer due to error\n- 24 == Partial transfer due to vanished source files\n- 25 == The --max-delete limit stopped deletions\n- 30 == Timeout in data send2viewserver/receive\n- 35 == Timeout waiting for daemon connection\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>path to remote (raid) tdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>path to local tdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag that will do a 'hard sync'</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args(exclude)","title":"<code>exclude</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to exclude</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args(include)","title":"<code>include</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns to include</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.rsync_args(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Perform operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_dir","title":"unlink_dir  <code>staticmethod</code>","text":"<pre><code>unlink_dir(link: str) -&gt; None\n</code></pre> <p>Unlink a directory symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_dir(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_dirs","title":"unlink_dirs  <code>staticmethod</code>","text":"<pre><code>unlink_dirs(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_dirs(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_file","title":"unlink_file  <code>staticmethod</code>","text":"<pre><code>unlink_file(link: str) -&gt; None\n</code></pre> <p>Unlink a file symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_file(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_files","title":"unlink_files  <code>staticmethod</code>","text":"<pre><code>unlink_files(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.LIN.unlink_files(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.Stdio","title":"Stdio","text":"<p>               Bases: <code>IntEnum</code></p> <p>Standard-io enum object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN","title":"WIN","text":"<p>               Bases: <code>WIN</code></p> <p>Windows shell commands/methods container</p> <p>Methods:</p> <ul> <li> <code>link_dir</code>             \u2013              <p>Make a directory symlink</p> </li> <li> <code>link_dirs</code>             \u2013              <p>Make multiple directory symlinks</p> </li> <li> <code>link_file</code>             \u2013              <p>Make a file symlink</p> </li> <li> <code>link_files</code>             \u2013              <p>Make multiple file symlinks</p> </li> <li> <code>robocopy</code>             \u2013              <p>Robocopy wrapper function (crude in that it opens a subprocess)</p> </li> <li> <code>robocopy_args</code>             \u2013              <p>Return list of robocopy command args</p> </li> <li> <code>unlink_dir</code>             \u2013              <p>Unlink a directory symlink given a path to the symlink</p> </li> <li> <code>unlink_dirs</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> <li> <code>unlink_file</code>             \u2013              <p>Unlink a file symlink given a path to the symlink</p> </li> <li> <code>unlink_files</code>             \u2013              <p>Unlink directory symlinks given the paths the links</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dir","title":"link_dir  <code>staticmethod</code>","text":"<pre><code>link_dir(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a directory symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dir(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dir(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an exception if the link exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dirs","title":"link_dirs  <code>staticmethod</code>","text":"<pre><code>link_dirs(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple directory symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dirs(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_dirs(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, do not raise an exception if the link(s) exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_file","title":"link_file  <code>staticmethod</code>","text":"<pre><code>link_file(\n    linkpath: str,\n    targetpath: str,\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make a file symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_file(linkpath)","title":"<code>linkpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_file(targetpath)","title":"<code>targetpath</code>","text":"(<code>str</code>)           \u2013            <p>Path to the target of the link to be made</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_file(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, don't raise an exception if the link exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_files","title":"link_files  <code>staticmethod</code>","text":"<pre><code>link_files(\n    link_target_tuples: list[tuple[str, str]],\n    *,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make multiple file symlinks</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_files(link_target_tuples)","title":"<code>link_target_tuples</code>","text":"(<code>list[tuple[str, str]]</code>)           \u2013            <p>Iterable of tuples of the form: (link, target) or a dictionary mapping with key =&gt; value pairs of the form link =&gt; target.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.link_files(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, don't raise an exception if the link exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy","title":"robocopy  <code>staticmethod</code>","text":"<pre><code>robocopy(\n    src: str,\n    dest: str,\n    *,\n    mkdirs: bool = True,\n    delete: bool = False,\n    exclude_files: Iterable[str] | None = None,\n    exclude_dirs: Iterable[str] | None = None,\n    dry_run: bool = False,\n) -&gt; Done\n</code></pre> <p>Robocopy wrapper function (crude in that it opens a subprocess)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>subprocess return code from robocopy</p> </li> </ul> <p>Robocopy return codes::</p> <pre><code>0. No files were copied. No failure was encountered. No files were\n   mismatched. The files already exist in the destination\n   directory; therefore, the copy operation was skipped.\n1. All files were copied successfully.\n2. There are some additional files in the destination directory\n   that are not present in the source directory. No files were\n   copied.\n3. Some files were copied. Additional files were present. No\n   failure was encountered.\n5. Some files were copied. Some files were mismatched. No failure\n   was encountered.\n6. Additional files and mismatched files exist. No files were\n   copied and no failures were encountered. This means that the\n   files already exist in the destination directory.\n7. Files were copied, a file mismatch was present, and additional\n   files were present.\n8. Several files did not copy.\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>path to source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>path to destination directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Delete files in the destination directory if they do not exist in the source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(exclude_files)","title":"<code>exclude_files</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(exclude_dirs)","title":"<code>exclude_dirs</code>","text":"(<code>Iterable[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do the operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy(mkdirs)","title":"<code>mkdirs</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to make destinaation directories if they do not already exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args","title":"robocopy_args  <code>staticmethod</code>","text":"<pre><code>robocopy_args(\n    src: str,\n    dest: str,\n    *,\n    delete: bool = False,\n    exclude_files: list[str] | None = None,\n    exclude_dirs: list[str] | None = None,\n    dry_run: bool = False,\n) -&gt; list[str]\n</code></pre> <p>Return list of robocopy command args</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>subprocess return code from robocopy</p> </li> </ul> <p>Robocopy return codes::</p> <pre><code>0. No files were copied. No failure was encountered. No files were\n   mismatched. The files already exist in the destination\n   directory; therefore, the copy operation was skipped.\n1. All files were copied successfully.\n2. There are some additional files in the destination directory\n   that are not present in the source directory. No files were\n   copied.\n3. Some files were copied. Additional files were present. No\n   failure was encountered.\n5. Some files were copied. Some files were mismatched. No failure\n   was encountered.\n6. Additional files and mismatched files exist. No files were\n   copied and no failures were encountered. This means that the\n   files already exist in the destination directory.\n7. Files were copied, a file mismatch was present, and additional\n   files were present.\n8. Several files did not copy.\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>path to source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>path to destination directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args(delete)","title":"<code>delete</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Delete files in the destination directory if they do not exist in the source directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args(exclude_files)","title":"<code>exclude_files</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args(exclude_dirs)","title":"<code>exclude_dirs</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Strings/patterns with which to exclude directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.robocopy_args(dry_run)","title":"<code>dry_run</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do the operation as a dry run</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_dir","title":"unlink_dir  <code>staticmethod</code>","text":"<pre><code>unlink_dir(link: str) -&gt; None\n</code></pre> <p>Unlink a directory symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_dir(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_dirs","title":"unlink_dirs  <code>staticmethod</code>","text":"<pre><code>unlink_dirs(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_dirs(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_file","title":"unlink_file  <code>staticmethod</code>","text":"<pre><code>unlink_file(link: str) -&gt; None\n</code></pre> <p>Unlink a file symlink given a path to the symlink</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_file(link)","title":"<code>link</code>","text":"(<code>str</code>)           \u2013            <p>path to the symlink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_files","title":"unlink_files  <code>staticmethod</code>","text":"<pre><code>unlink_files(links: Iterable[str]) -&gt; None\n</code></pre> <p>Unlink directory symlinks given the paths the links</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.WIN.unlink_files(links)","title":"<code>links</code>","text":"(<code>Iterable[str]</code>)           \u2013            <p>Iterable of paths to links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.basename","title":"basename","text":"<pre><code>basename(fspath: FsPath) -&gt; str\n</code></pre> <p>Return the basename of given path; alias of os.path.dirname</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>basename of path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.basename(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cd","title":"cd","text":"<pre><code>cd(dirpath: FsPath) -&gt; None\n</code></pre> <p>Change directory to given dirpath; alias for <code>os.chdir</code></p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cd(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.chmod","title":"chmod","text":"<pre><code>chmod(fspath: FsPath, mode: int) -&gt; None\n</code></pre> <p>Change the access permissions of a file</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.chmod(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file to chmod</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.chmod(mode)","title":"<code>mode</code>","text":"(<code>int</code>)           \u2013            <p>Permissions mode as an int</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.copy_file","title":"copy_file","text":"<pre><code>copy_file(\n    src: FsPath,\n    dest: FsPath,\n    *,\n    dryrun: bool = False,\n    mkdirp: bool = False,\n) -&gt; tuple[str, str]\n</code></pre> <p>Copy a file given a source-path and a destination-path</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.copy_file(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.copy_file(dest)","title":"<code>dest</code>","text":"(<code>str</code>)           \u2013            <p>Destination fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.copy_file(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not copy file if True just return the src and dest</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.copy_file(mkdirp)","title":"<code>mkdirp</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Create parent directories if they do not exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp","title":"cp","text":"<pre><code>cp(\n    src: FsPath,\n    dest: FsPath,\n    *,\n    force: bool = True,\n    recursive: bool = False,\n    r: bool = False,\n    f: bool = True,\n) -&gt; None\n</code></pre> <p>Copy the directory/file src to the directory/file dest</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If src is a directory and recursive and r are both <code>False</code></p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp(src)","title":"<code>src</code>","text":"(<code>str</code>)           \u2013            <p>Source directory/file to copy</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>Destination directory/file to copy</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Force the copy (like -f flag for cp in shell)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursive copy (like -r flag for cp in shell)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for recursive</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.cp(f)","title":"<code>f</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>alias for force</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.decode_stdio_bytes","title":"decode_stdio_bytes","text":"<pre><code>decode_stdio_bytes(\n    stdio_bytes: str | bytes, *, lf: bool = True\n) -&gt; str\n</code></pre> <p>Return Stdio bytes from stdout/stderr as a string</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>decoded stdio bytes</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.decode_stdio_bytes(stdio_bytes)","title":"<code>stdio_bytes</code>","text":"(<code>bytes</code>)           \u2013            <p>STDOUT/STDERR bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.decode_stdio_bytes(lf)","title":"<code>lf</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Replace <code>\\r\\n</code> line endings with <code>\\n</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dir_exists","title":"dir_exists","text":"<pre><code>dir_exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dir_exists_async","title":"dir_exists_async  <code>async</code>","text":"<pre><code>dir_exists_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the directory exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirname","title":"dirname","text":"<pre><code>dirname(fspath: FsPath) -&gt; str\n</code></pre> <p>Return dirname/parent-dir of given path; alias of os.path.dirname</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>basename of path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirname(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirpath_gen","title":"dirpath_gen","text":"<pre><code>dirpath_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all dirpaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen","title":"dirs_gen","text":"<pre><code>dirs_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield directory-paths beneath a dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields directory paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'dirs_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = list(sorted(set(expected_dirs)))\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in expected_dirs]\n&gt;&gt;&gt; pprint(expected_dirs)\n['dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; _files = list(files_gen(tmpdir))\n&gt;&gt;&gt; _dirs = list(dirs_gen(tmpdir))\n&gt;&gt;&gt; files_n_dirs_list = list(sorted(_files + _dirs))\n&gt;&gt;&gt; files_n_dirs_list = [el.replace('\\\\', '/') for el in files_n_dirs_list]\n&gt;&gt;&gt; pprint(files_n_dirs_list)\n['dirs_gen.doctest',\n 'dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt',\n 'dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; expected = [el.replace('\\\\', '/') for el in expected]\n&gt;&gt;&gt; pprint(expected)\n['dirs_gen.doctest',\n 'dirs_gen.doctest/dir',\n 'dirs_gen.doctest/dir/dir2',\n 'dirs_gen.doctest/dir/dir2/file1.txt',\n 'dirs_gen.doctest/dir/dir2/file2.txt',\n 'dirs_gen.doctest/dir/dir2/file3.txt',\n 'dirs_gen.doctest/dir/dir2a',\n 'dirs_gen.doctest/dir/dir2a/file1.txt',\n 'dirs_gen.doctest/dir/dir2a/file2.txt',\n 'dirs_gen.doctest/dir/dir2a/file3.txt',\n 'dirs_gen.doctest/dir/file1.txt',\n 'dirs_gen.doctest/dir/file2.txt',\n 'dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; files_n_dirs_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.dirs_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that dir exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do","title":"do","text":"<pre><code>do(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: FsPath | None = None,\n    shell: bool = False,\n    check: bool = False,\n    tee: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    timeout: float | int | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess synchronously</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if args and *popenargs are both given</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend the environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(cwd)","title":"<code>cwd</code>","text":"(<code>FsPath | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Run in shell or sub-shell</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the outputs (generally useless)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(tee)","title":"<code>tee</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to tee the subprocess stdout and stderr to sys.stdout/stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) to check against</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Don't run the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async","title":"do_async  <code>async</code>","text":"<pre><code>do_async(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: str | None = None,\n    shell: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    check: bool = False,\n    timeout: float | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess and await its completion</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If both *popenargs and args are given</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the result returncode</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(cwd)","title":"<code>cwd</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Run in shell or sub-shell</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) that are considered OK (Default value = 0)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_async(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to not run the subprocess but return a Done object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.do_asyncify","title":"do_asyncify  <code>async</code>","text":"<pre><code>do_asyncify(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: str | None = None,\n    shell: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    check: bool = False,\n    timeout: float | int | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess asynchronously using asyncified version of do</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa","title":"doa  <code>async</code>","text":"<pre><code>doa(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    extenv: bool = True,\n    cwd: str | None = None,\n    shell: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    check: bool = False,\n    timeout: float | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess and await its completion</p> <p>Alias for sh.do_async</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the result returncode</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(cwd)","title":"<code>cwd</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Run in shell or sub-shell</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) that are considered OK (Default value = 0)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to not run the subprocess but return a Done object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.doa(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.echo","title":"echo","text":"<pre><code>echo(\n    *objects: Any,\n    sep: str = \" \",\n    end: str = \"\\n\",\n    file: IO[str] | None = None,\n    flush: bool = False,\n) -&gt; None\n</code></pre> <p>Print/echo function</p> <p>This function is basically the print function, and exists so that one can deliberately print without using the built-in print function which is not allowed by the <code>dgpy-libs</code> ruff rules.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; echo(\"shellfish\")\nshellfish\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.echo(*objects)","title":"<code>*objects</code>","text":"(<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>Item(s) to print/echo</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.echo(sep)","title":"<code>sep</code>","text":"(<code>str</code>, default:                   <code>' '</code> )           \u2013            <p>Separator to print with</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.echo(end)","title":"<code>end</code>","text":"(<code>str</code>, default:                   <code>'\\n'</code> )           \u2013            <p>End of print suffix; defaults to <code>\\n</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.echo(file)","title":"<code>file</code>","text":"(<code>IO[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>File like object to write to if not stdout</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.echo(flush)","title":"<code>flush</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flush the file after writing</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.exists","title":"exists","text":"<pre><code>exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.export","title":"export","text":"<pre><code>export(key: str, val: str | None = None) -&gt; tuple[str, str]\n</code></pre> <p>Export/Set an environment variable</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if unable to parse key/val</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.export(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>environment variable name/key</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.export(val)","title":"<code>val</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>environment variable value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.extension","title":"extension","text":"<pre><code>extension(fspath: str, *, period: bool = False) -&gt; str\n</code></pre> <p>Return the extension for a fspath</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import extension\n&gt;&gt;&gt; extension(\"foo.bar\")\n'bar'\n&gt;&gt;&gt; extension(\"foo.tar.gz\")\n'tar.gz'\n&gt;&gt;&gt; extension(\"foo.tar.gz\", period=True)\n'.tar.gz'\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.file_exists","title":"file_exists","text":"<pre><code>file_exists(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path exists; False otherwise; alias for isfile</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.file_exists_async","title":"file_exists_async  <code>async</code>","text":"<pre><code>file_exists_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the file exists; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.file_lines_gen","title":"file_lines_gen","text":"<pre><code>file_lines_gen(\n    filepath: FsPath, *, keepends: bool = True\n) -&gt; Iterable[str]\n</code></pre> <p>Yield lines from a given fspath</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Iterable[str]</code>           \u2013            <p>Lines from the given fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; string = '\\n'.join(str(i) for i in range(1, 10))\n&gt;&gt;&gt; string\n'1\\n2\\n3\\n4\\n5\\n6\\n7\\n8\\n9'\n&gt;&gt;&gt; fspath = \"file_lines_gen.doctest.txt\"\n&gt;&gt;&gt; from shellfish.fs import write_str\n&gt;&gt;&gt; write_str(fspath, string)\n17\n&gt;&gt;&gt; for file_line in file_lines_gen(fspath):\n...     file_line\n'1\\n'\n'2\\n'\n'3\\n'\n'4\\n'\n'5\\n'\n'6\\n'\n'7\\n'\n'8\\n'\n'9'\n&gt;&gt;&gt; for file_line in file_lines_gen(fspath, keepends=False):\n...     file_line\n'1'\n'2'\n'3'\n'4'\n'5'\n'6'\n'7'\n'8'\n'9'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.file_lines_gen(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File to yield lines from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.file_lines_gen(keepends)","title":"<code>keepends</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag to keep the ends of the file lines</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filecmp","title":"filecmp","text":"<pre><code>filecmp(\n    left: FsPath,\n    right: FsPath,\n    *,\n    shallow: bool = True,\n    blocksize: int = 65536,\n) -&gt; bool\n</code></pre> <p>Compare 2 files for equality given their filepaths</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if files are equal, False otherwise</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filecmp(left)","title":"<code>left</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath 1</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filecmp(right)","title":"<code>right</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath 2</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filecmp(shallow)","title":"<code>shallow</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check only size and modification time if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filecmp(blocksize)","title":"<code>blocksize</code>","text":"(<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>Chunk size to read files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filepath_gen","title":"filepath_gen","text":"<pre><code>filepath_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filepath_mtimedelta_sec","title":"filepath_mtimedelta_sec","text":"<pre><code>filepath_mtimedelta_sec(filepath: FsPath) -&gt; float\n</code></pre> <p>Return the seconds since the file(path) was last modified</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen","title":"files_dirs_gen","text":"<pre><code>files_dirs_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; tuple[Iterator[str], Iterator[str]]\n</code></pre> <p>Return a files_gen() and a dirs_gen() in one swell-foop</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[Iterator[str], Iterator[str]]</code>           \u2013            <p>A tuple of two generators (files_gen(), dirs_gen())</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'files_dirs_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = list(sorted(set(expected_dirs)))\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in expected_dirs]\n&gt;&gt;&gt; pprint(expected_dirs)\n['files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; _files, _dirs = files_dirs_gen(tmpdir)\n&gt;&gt;&gt; _files = list(_files)\n&gt;&gt;&gt; _dirs = list(_dirs)\n&gt;&gt;&gt; files_n_dirs_list = list(sorted(set(_files + _dirs)))\n&gt;&gt;&gt; files_n_dirs_list = [el.replace('\\\\', '/') for el in files_n_dirs_list]\n&gt;&gt;&gt; pprint(files_n_dirs_list)\n['files_dirs_gen.doctest',\n 'files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt',\n 'files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; expected = [el.replace('\\\\', '/') for el in expected]\n&gt;&gt;&gt; pprint(expected)\n['files_dirs_gen.doctest',\n 'files_dirs_gen.doctest/dir',\n 'files_dirs_gen.doctest/dir/dir2',\n 'files_dirs_gen.doctest/dir/dir2/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2/file3.txt',\n 'files_dirs_gen.doctest/dir/dir2a',\n 'files_dirs_gen.doctest/dir/dir2a/file1.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file2.txt',\n 'files_dirs_gen.doctest/dir/dir2a/file3.txt',\n 'files_dirs_gen.doctest/dir/file1.txt',\n 'files_dirs_gen.doctest/dir/file2.txt',\n 'files_dirs_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; files_n_dirs_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_dirs_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check if dirpath is a directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen","title":"files_gen","text":"<pre><code>files_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield file-paths beneath a given dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields file-paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'files_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; expected_files = [el.replace('\\\\', '/') for el in expected_files]\n&gt;&gt;&gt; pprint(expected_files)\n['files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt',\n 'files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; files_list = list(sorted(set(files_gen(tmpdir))))\n&gt;&gt;&gt; files_list = [el.replace('\\\\', '/') for el in files_list]\n&gt;&gt;&gt; pprint(files_list)\n['files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt',\n 'files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; pprint(list(sorted(set(expected_files))))\n['files_gen.doctest/dir/dir2/file1.txt',\n 'files_gen.doctest/dir/dir2/file2.txt',\n 'files_gen.doctest/dir/dir2/file3.txt',\n 'files_gen.doctest/dir/dir2a/file1.txt',\n 'files_gen.doctest/dir/dir2a/file2.txt',\n 'files_gen.doctest/dir/dir2a/file3.txt',\n 'files_gen.doctest/dir/file1.txt',\n 'files_gen.doctest/dir/file2.txt',\n 'files_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; list(sorted(set(files_list))) == list(sorted(set(expected_files)))\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.files_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check that dir exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filesize","title":"filesize","text":"<pre><code>filesize(fspath: FsPath) -&gt; int\n</code></pre> <p>Return the size of the given file(path) in bytes</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>size of the fspath in bytes</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filesize(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath as a string or pathlib.Path object</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.filesize_async","title":"filesize_async  <code>async</code>","text":"<pre><code>filesize_async(fspath: FsPath) -&gt; int\n</code></pre> <p>Return the size of the file at the given fspath</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from tempfile import TemporaryDirectory\n&gt;&gt;&gt; with TemporaryDirectory() as tmpdir:\n...     tmpdir = Path(tmpdir)\n...     fpath = tmpdir / \"test.txt\"\n...     written = fpath.write_text(\"hello world\")\n...     aiorun(filesize_async(fpath))\n11\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.flatten_args","title":"flatten_args","text":"<pre><code>flatten_args(*args: Any | list[Any]) -&gt; list[str]\n</code></pre> <p>Flatten possibly nested iterables of sequences to a list of strings</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list(flatten_args(\"cmd\", [\"uno\", \"dos\", \"tres\"]))\n['cmd', 'uno', 'dos', 'tres']\n&gt;&gt;&gt; list(flatten_args(\"cmd\", [\"uno\", \"dos\", \"tres\", [\"4444\", \"five\"]]))\n['cmd', 'uno', 'dos', 'tres', '4444', 'five']\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.fspath","title":"fspath","text":"<pre><code>fspath(fspath: FsPath) -&gt; str\n</code></pre> <p>Alias for os._fspath; returns fspath string for any type of path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.glob","title":"glob","text":"<pre><code>glob(\n    pattern: str,\n    *,\n    recursive: bool = False,\n    r: bool = False,\n) -&gt; Iterator[str]\n</code></pre> <p>Return an iterator of fspaths matching the given glob pattern</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Iterator[str]: Iterator of fspaths matching the glob pattern</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.glob(pattern)","title":"<code>pattern</code>","text":"(<code>str</code>)           \u2013            <p>Glob pattern</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.glob(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively search directories if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.glob(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively search directories if True (Alias for recursive)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.is_dir","title":"is_dir","text":"<pre><code>is_dir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; alias for isdir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.is_dir_async","title":"is_dir_async  <code>async</code>","text":"<pre><code>is_dir_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.is_file","title":"is_file","text":"<pre><code>is_file(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; alias for isfile</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.is_file_async","title":"is_file_async  <code>async</code>","text":"<pre><code>is_file_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.is_link","title":"is_link","text":"<pre><code>is_link(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; alias for islink</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.is_link_async","title":"is_link_async  <code>async</code>","text":"<pre><code>is_link_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.isdir","title":"isdir","text":"<pre><code>isdir(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a directory; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.isdir_async","title":"isdir_async  <code>async</code>","text":"<pre><code>isdir_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.isfile","title":"isfile","text":"<pre><code>isfile(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.isfile_async","title":"isfile_async  <code>async</code>","text":"<pre><code>isfile_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a file; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.islink","title":"islink","text":"<pre><code>islink(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.islink_async","title":"islink_async  <code>async</code>","text":"<pre><code>islink_async(fspath: FsPath) -&gt; bool\n</code></pre> <p>Return True if the given path is a link; False otherwise</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.listdir_async","title":"listdir_async  <code>async</code>","text":"<pre><code>listdir_async(fspath: FsPath) -&gt; list[str]\n</code></pre> <p>Async version of <code>os.listdir</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.listdir_gen","title":"listdir_gen","text":"<pre><code>listdir_gen(\n    fspath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    follow_symlinks: bool = True,\n    files: bool = True,\n    dirs: bool = True,\n    symlinks: bool = False,\n    files_only: bool = False,\n    dirs_only: bool = False,\n    symlinks_only: bool = False,\n) -&gt; Iterator[Path]\n</code></pre> <p>Return an iterator of strings from DirEntries</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'listdir_gen.doctest'\n&gt;&gt;&gt; from shellfish import sh\n&gt;&gt;&gt; from os import makedirs, path, chdir\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; pwd = sh.pwd()\n&gt;&gt;&gt; sh.cd(tmpdir)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"data1.json\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; dirpath = path.join(tmpdir, 'dir')\n&gt;&gt;&gt; dirpath.replace(\"\\\\\", \"/\")\n'listdir_gen.doctest/dir'\n&gt;&gt;&gt; sorted(listdir_gen(dirpath, dirs=False, symlinks=False))\n['data1.json', 'file1.txt', 'file2.txt', 'file3.txt']\n&gt;&gt;&gt; abspaths = sorted(listdir_gen(dirpath, abspath=True, dirs=False, symlinks=False))\n&gt;&gt;&gt; for abspath in [p.replace(\"\\\\\", \"/\") for p in abspaths]:\n...    print(abspath)\nlistdir_gen.doctest/dir/data1.json\nlistdir_gen.doctest/dir/file1.txt\nlistdir_gen.doctest/dir/file2.txt\nlistdir_gen.doctest/dir/file3.txt\n&gt;&gt;&gt; sh.cd(pwd)\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; if path.exists(tmpdir):\n...     rmtree(tmpdir)\n&gt;&gt;&gt; path.isdir(tmpdir)\nFalse\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls","title":"ls","text":"<pre><code>ls(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List files and dirs given a dirpath (defaults to pwd)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of the directory items</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>path-string to directory to list</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Give absolute paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_async","title":"ls_async  <code>async</code>","text":"<pre><code>ls_async(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List files and dirs given a dirpath (defaults to pwd)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of the directory items</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_async(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>path-string to directory to list</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_async(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Give absolute paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_dirs","title":"ls_dirs","text":"<pre><code>ls_dirs(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List the directories in a given directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of directories as strings</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_dirs(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path for which one might want list directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_dirs(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return absolute directory paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_files","title":"ls_files","text":"<pre><code>ls_files(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; list[str]\n</code></pre> <p>List the files in a given directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of files as strings</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_files(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path for which one might want to list files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_files(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return absolute filepaths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_files_dirs","title":"ls_files_dirs","text":"<pre><code>ls_files_dirs(\n    dirpath: FsPath = \".\", *, abspath: bool = False\n) -&gt; tuple[list[str], list[str]]\n</code></pre> <p>List the files and directories given directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[str], list[str]]</code>           \u2013            <p>Two lists of strings; the first is a list of the files and the second is a list of the directories</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_files_dirs(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to execute on</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.ls_files_dirs(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Return absolute file/directory paths</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.lstat_async","title":"lstat_async  <code>async</code>","text":"<pre><code>lstat_async(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Async version of <code>os.lstat</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mkdir","title":"mkdir","text":"<pre><code>mkdir(\n    fspath: FsPath,\n    *,\n    parents: bool = False,\n    p: bool = False,\n    exist_ok: bool = False,\n) -&gt; None\n</code></pre> <p>Make directory at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mkdir(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory path to create</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mkdir(parents)","title":"<code>parents</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make parent dirs if True; do not make parent dirs if False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mkdir(p)","title":"<code>p</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Make parent dirs if True; do not make parent dirs if False (alias of parents)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mkdir(exist_ok)","title":"<code>exist_ok</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Throw error if directory exists and exist_ok is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mkdirp","title":"mkdirp","text":"<pre><code>mkdirp(fspath: FsPath) -&gt; None\n</code></pre> <p>Make directory and parents</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.move","title":"move","text":"<pre><code>move(src: FsPath, dest: FsPath) -&gt; None\n</code></pre> <p>Move file(s) like on the command line</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.move(src)","title":"<code>src</code>","text":"(<code>FsPath</code>)           \u2013            <p>source file(s)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.move(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>destination path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mv","title":"mv","text":"<pre><code>mv(src: FsPath, dest: FsPath) -&gt; None\n</code></pre> <p>Move file(s) like on the command line</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mv(src)","title":"<code>src</code>","text":"(<code>FsPath</code>)           \u2013            <p>source file(s)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.mv(dest)","title":"<code>dest</code>","text":"(<code>FsPath</code>)           \u2013            <p>destination path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.path_gen","title":"path_gen","text":"<pre><code>path_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = False,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[Path]\n</code></pre> <p>Yield all filepaths as pathlib.Path objects beneath a dirpath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pstderr","title":"pstderr","text":"<pre><code>pstderr(proc: CompletedProcess[AnyStr]) -&gt; str\n</code></pre> <p>Get the STDERR as a string from a subprocess</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>STDERR for the proc as string</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pstderr(proc)","title":"<code>proc</code>","text":"(<code>CompletedProcess[AnyStr]</code>)           \u2013            <p>python subprocess.process object with STDERR</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pstdout","title":"pstdout","text":"<pre><code>pstdout(proc: CompletedProcess[AnyStr]) -&gt; str\n</code></pre> <p>Get the STDOUT as a string from a subprocess</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>STDOUT for the proc as string</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pstdout(proc)","title":"<code>proc</code>","text":"(<code>CompletedProcess[AnyStr]</code>)           \u2013            <p>python subprocess.process object with stdout</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pstdout_pstderr","title":"pstdout_pstderr","text":"<pre><code>pstdout_pstderr(\n    proc: CompletedProcess[AnyStr],\n) -&gt; tuple[str, str]\n</code></pre> <p>Get the STDOUT and STDERR as strings from a subprocess</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>Tuple of two strings: (stdout-string, stderr-string)</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pstdout_pstderr(proc)","title":"<code>proc</code>","text":"(<code>CompletedProcess[AnyStr]</code>)           \u2013            <p>Completed-subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.pwd","title":"pwd","text":"<pre><code>pwd() -&gt; str\n</code></pre> <p>Return present-working-directory path string; alias for os.getcwd</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>present working directory as string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import os\n&gt;&gt;&gt; pwd() == os.getcwd()\nTrue\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.q","title":"q","text":"<pre><code>q(string: str) -&gt; str\n</code></pre> <p>Typed alias for shlex.quote</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>quoted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; q(\"hello world\")\n\"'hello world'\"\n&gt;&gt;&gt; q(\"hello 'world'\")\n'\\'hello \\'\"\\'\"\\'world\\'\"\\'\"\\'\\''\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.q(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to quote</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.quote","title":"quote","text":"<pre><code>quote(string: str) -&gt; str\n</code></pre> <p>Typed alias for shlex.quote</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>quoted string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; quote(\"hello world\")\n\"'hello world'\"\n&gt;&gt;&gt; quote(\"hello 'world'\")\n'\\'hello \\'\"\\'\"\\'world\\'\"\\'\"\\'\\''\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.quote(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to quote</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes","title":"read_bytes","text":"<pre><code>read_bytes(filepath: FsPath) -&gt; bytes\n</code></pre> <p>Read bytes from a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes from the fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"rbytes.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; write_bytes(fspath, bites_to_save)\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath read as bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes_async","title":"read_bytes_async  <code>async</code>","text":"<pre><code>read_bytes_async(filepath: FsPath) -&gt; bytes\n</code></pre> <p>(ASYNC) Load/Read bytes from a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bytes</code>           \u2013            <p>bytes from the fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs._async import read_bytes_async, write_bytes_async\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; fspath = \"rbytes_async.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; aiorun(write_bytes_async(fspath, bites_to_save))\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; aiorun(read_bytes_async(fspath))\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath read as bytes</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes_gen","title":"read_bytes_gen","text":"<pre><code>read_bytes_gen(\n    filepath: FsPath, blocksize: int = 65536\n) -&gt; Iterable[bytes]\n</code></pre> <p>Yield bytes from a given fspath</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes_gen_async","title":"read_bytes_gen_async  <code>async</code>","text":"<pre><code>read_bytes_gen_async(\n    filepath: FsPath, blocksize: int = 65536\n) -&gt; AsyncIterable[bytes]\n</code></pre> <p>Yield (asynchronously) bytes from a given fspath</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>AsyncIterable[bytes]</code>           \u2013            <p>bytes from AsyncIterable[bytes] of the file bytes</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import write_bytes_gen_async, read_bytes_gen_async\n&gt;&gt;&gt; fspath = 'rbytes_gen_async.doctest.txt'\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; async def read():\n...     async for b in read_bytes_gen_async(fspath, blocksize=4):\n...         print(b)\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; async def async_gen():\n...     for b in bites_to_save:\n...        yield b\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, AsyncIterable()))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes_gen_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to read from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_bytes_gen_async(blocksize)","title":"<code>blocksize</code>","text":"(<code>int</code>, default:                   <code>65536</code> )           \u2013            <p>size of the block to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_json","title":"read_json","text":"<pre><code>read_json(filepath: FsPath) -&gt; Any\n</code></pre> <p>Load/Read-&amp;-parse json data given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Parsed JSON data</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_json, write_json\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n19\n&gt;&gt;&gt; read_json(fspath)\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n25\n&gt;&gt;&gt; read_json(fspath)\n[['a', 1], ['b', 2], ['c', 3]]\n&gt;&gt;&gt; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_json(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to load/read data from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_json_async","title":"read_json_async  <code>async</code>","text":"<pre><code>read_json_async(filepath: FsPath) -&gt; Any\n</code></pre> <p>Load/Read-&amp;-parse json data given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>Parsed JSON data</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import read_json_async, write_json_async\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_async_dict.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n19\n&gt;&gt;&gt; run(read_json_async(fspath))\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_async_list.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n25\n&gt;&gt;&gt; run(read_json_async(fspath))\n[['a', 1], ['b', 2], ['c', 3]]\n</code></pre> <pre><code>&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_json_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to load/read data from</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_str","title":"read_str","text":"<pre><code>read_str(\n    filepath: FsPath, *, encoding: str = \"utf-8\"\n) -&gt; str\n</code></pre> <p>Load/Read a string given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>String read from given fspath</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_str, write_str\n&gt;&gt;&gt; fspath = \"read_str.doctest.txt\"\n&gt;&gt;&gt; write_str(fspath, r'Check out this string')\n21\n&gt;&gt;&gt; read_str(fspath)\n'Check out this string'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_str(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath for file to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>Encoding to use for reading the file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_str_async","title":"read_str_async  <code>async</code>","text":"<pre><code>read_str_async(\n    filepath: FsPath, encoding: str = \"utf-8\"\n) -&gt; str\n</code></pre> <p>(ASYNC) Load/Read a string given a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>String read from given fspath</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_str_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath for file to read</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.read_str_async(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>File encoding (Default='utf-8')</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm","title":"rm","text":"<pre><code>rm(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n    verbose: bool = False,\n    f: bool = False,\n    r: bool = False,\n    v: bool = False,\n    dryrun: bool = False,\n) -&gt; None\n</code></pre> <p>Remove files &amp; directories in the style of the shell</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If recursive and r are <code>False</code> and fspath is a directory</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to force removal; ignore missing</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to remove recursively (like the <code>-r</code> in <code>rm -r dir</code>)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to be verbose</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(f)","title":"<code>f</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for force kwarg</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(v)","title":"<code>v</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for verbose</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(r)","title":"<code>r</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>alias for recursive kwarg</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to not actually remove anything</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm_gen","title":"rm_gen","text":"<pre><code>rm_gen(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n    dryrun: bool = False,\n) -&gt; Generator[str, Any, Any]\n</code></pre> <p>Remove files &amp; directories in the style of the shell</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If recursive and r are <code>False</code> and fspath is a directory</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm_gen(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm_gen(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force removal of files and directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm_gen(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to remove recursively (like the <code>-r</code> in <code>rm -r dir</code>)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rm_gen(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmdir","title":"rmdir","text":"<pre><code>rmdir(\n    fspath: FsPath,\n    *,\n    force: bool = False,\n    recursive: bool = False,\n) -&gt; None\n</code></pre> <p>Remove directory at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmdir(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory path to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmdir(force)","title":"<code>force</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force removal of files and directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmdir(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Recursively remove all contents if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmfile","title":"rmfile","text":"<pre><code>rmfile(fspath: FsPath, *, dryrun: bool = False) -&gt; str\n</code></pre> <p>Remove a file at given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>None</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmfile(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Filepath to remove</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.rmfile(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Do not remove file if True</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.safepath","title":"safepath","text":"<pre><code>safepath(fspath: FsPath) -&gt; str\n</code></pre> <p>Check if a file/dir path is save/unused; returns an unused path.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>file/dir path that does not exist and contains the given path</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.safepath(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>file-system path; file or directory path string or Path obj</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir","title":"scandir","text":"<pre><code>scandir(\n    dirpath: FsPath = \".\",\n) -&gt; Iterable[DirEntry[AnyStr]]\n</code></pre> <p>Typed version of os.scandir</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen","title":"scandir_gen","text":"<pre><code>scandir_gen(\n    fspath: FsPath = \".\",\n    *,\n    recursive: bool = False,\n    follow_symlinks: bool = True,\n    files: bool = True,\n    dirs: bool = True,\n    symlinks: bool = True,\n    files_only: bool = False,\n    dirs_only: bool = False,\n    symlinks_only: bool = False,\n) -&gt; Iterator[DirEntry[str]]\n</code></pre> <p>Return an iterator of os.DirEntry objects</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[DirEntry[str]]</code>           \u2013            <p>Iterator[DirEntry]: Iterator of os.DirEntry objects</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if any of the kwargs (<code>dirs</code>, <code>files</code> and <code>symlinks</code>) are not True</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>(FsPath): dirpath to look through</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(recursive)","title":"<code>recursive</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>recursively scan the directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(follow_symlinks)","title":"<code>follow_symlinks</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>follow symlinks when checking for dirs and files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(files)","title":"<code>files</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(dirs)","title":"<code>dirs</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(symlinks)","title":"<code>symlinks</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>include symlinks</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(dirs_only)","title":"<code>dirs_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include directories</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(files_only)","title":"<code>files_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include files</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_gen(symlinks_only)","title":"<code>symlinks_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>only include symlinks</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_list","title":"scandir_list","text":"<pre><code>scandir_list(\n    dirpath: FsPath = \".\",\n) -&gt; list[DirEntry[AnyStr]]\n</code></pre> <p>Return a list of os.DirEntry objects</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[DirEntry[AnyStr]]</code>           \u2013            <p>list[DirEntry]: List of os.DirEntry objects</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.scandir_list(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Dirpath to scan</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.sep_join","title":"sep_join","text":"<pre><code>sep_join(path_strings: Iterator[str]) -&gt; str\n</code></pre> <p>Join iterable of strings on the current platform os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.sep_lstrip","title":"sep_lstrip","text":"<pre><code>sep_lstrip(fspath: FsPath) -&gt; str\n</code></pre> <p>Left-strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.sep_rstrip","title":"sep_rstrip","text":"<pre><code>sep_rstrip(fspath: FsPath) -&gt; str\n</code></pre> <p>Right-strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.sep_split","title":"sep_split","text":"<pre><code>sep_split(fspath: FsPath) -&gt; tuple[str, ...]\n</code></pre> <p>Split a string on the current platform os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.sep_strip","title":"sep_strip","text":"<pre><code>sep_strip(fspath: FsPath) -&gt; str\n</code></pre> <p>Strip a string of the current platform's os.path.sep value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.setenv","title":"setenv","text":"<pre><code>setenv(key: str, val: str | None = None) -&gt; tuple[str, str]\n</code></pre> <p>Export/Set an environment variable</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, str]</code>           \u2013            <p>tuple[str, str]: environment variable key/value pair</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.setenv(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>environment variable name/key</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.setenv(val)","title":"<code>val</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>environment variable value</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shebang","title":"shebang","text":"<pre><code>shebang(fspath: FsPath) -&gt; str | None\n</code></pre> <p>Get the shebang string given a fspath; Returns None if no shebang</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: The shebang string if it exists, None otherwise</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from inspect import getabsfile\n&gt;&gt;&gt; script = 'ashellscript.sh'\n&gt;&gt;&gt; with open(script, 'w') as f:\n...     f.write('#!/bin/bash\\necho \"howdy\"\\n')\n25\n&gt;&gt;&gt; shebang(script)\n'#!/bin/bash'\n&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; remove(script)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shebang(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file that might have a shebang</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell","title":"shell","text":"<pre><code>shell(\n    *popenargs: PopenArgs,\n    args: PopenArgs | None = None,\n    env: dict[str, str] | None = None,\n    shell: bool = True,\n    extenv: bool = True,\n    cwd: FsPath | None = None,\n    check: bool = False,\n    verbose: bool = False,\n    input: STDIN = None,\n    timeout: float | int | None = None,\n    ok_code: int\n    | list[int]\n    | tuple[int, ...]\n    | set[int] = 0,\n    dryrun: bool = False,\n) -&gt; Done\n</code></pre> <p>Run a subprocess synchronously in current shell</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Done</code>           \u2013            <p>Finished PRun object which is a dictionary, so a dictionary</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(*popenargs)","title":"<code>*popenargs</code>","text":"(<code>PopenArgs</code>, default:                   <code>()</code> )           \u2013            <p>Args given as <code>*args</code>; Cannot use both *popenargs and args</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(args)","title":"<code>args</code>","text":"(<code>PopenArgs | None</code>, default:                   <code>None</code> )           \u2013            <p>Args as strings for the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(env)","title":"<code>env</code>","text":"(<code>dict[str, str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Environment variables as a dictionary (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(shell)","title":"<code>shell</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Run in shell or sub-shell; default is True for <code>shell</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(extenv)","title":"<code>extenv</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Extend the environment with the current environment (Default value = True)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(cwd)","title":"<code>cwd</code>","text":"(<code>FsPath | None</code>, default:                   <code>None</code> )           \u2013            <p>Current working directory (Default value = None)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Check the outputs (generally useless)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(input)","title":"<code>input</code>","text":"(<code>STDIN</code>, default:                   <code>None</code> )           \u2013            <p>Stdin to give to the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(verbose)","title":"<code>verbose</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to write the subprocess stdout and stderr to sys.stdout and sys.stderr</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(timeout)","title":"<code>timeout</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Timeout in seconds for the process if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(ok_code)","title":"<code>ok_code</code>","text":"(<code>int | list[int] | tuple[int, ...] | set[int]</code>, default:                   <code>0</code> )           \u2013            <p>Return code(s) to check if ok</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shell(dryrun)","title":"<code>dryrun</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Don't run the subprocess</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.shplit","title":"shplit","text":"<pre><code>shplit(\n    string: str,\n    *,\n    comments: bool = False,\n    posix: bool = True,\n) -&gt; list[str]\n</code></pre> <p>Typed alias for shlex.split</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.source","title":"source","text":"<pre><code>source(filepath: FsPath, *, _globals: bool = True) -&gt; None\n</code></pre> <p>Execute/run a python file given a fspath and put globals in globasl</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.source(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to python file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.source(_globals)","title":"<code>_globals</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Exec using globals</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.stat","title":"stat","text":"<pre><code>stat(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Return the os.stat_result object for a given fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>stat_result</code>           \u2013            <p>os.stat_result: stat_result object</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.stat(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Path to file or directory</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.stat_async","title":"stat_async  <code>async</code>","text":"<pre><code>stat_async(fspath: FsPath) -&gt; stat_result\n</code></pre> <p>Async version of <code>os.stat</code></p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.touch","title":"touch","text":"<pre><code>touch(fspath: FsPath, *, mkdirp: bool = True) -&gt; None\n</code></pre> <p>Create an empty file given a fspath</p> <p>Parameters:</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.touch(fspath)","title":"<code>fspath</code>","text":"(<code>FsPath</code>)           \u2013            <p>File-system path for where to make an empty file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.touch(mkdirp)","title":"<code>mkdirp</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Make parent directories if they don't exist</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.tree","title":"tree","text":"<pre><code>tree(\n    dirpath: FsPath,\n    filterfn: Callable[[str], bool] | None = None,\n) -&gt; str\n</code></pre> <p>Create a directory tree string given a directory path</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str</code> )          \u2013            <p>Directory-tree string</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'tree.doctest'\n&gt;&gt;&gt; from os import makedirs; makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f)\n...     fspath = path.join(tmpdir, fspath)\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     makedirs(dirpath, exist_ok=True)\n...     Path(fspath).touch()\n&gt;&gt;&gt; print(tree(tmpdir))\ntree.doctest/\n\u2514\u2500\u2500 dir/\n    \u251c\u2500\u2500 dir2/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u251c\u2500\u2500 file2.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 dir2a/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u251c\u2500\u2500 file2.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 file1.txt\n    \u251c\u2500\u2500 file2.txt\n    \u2514\u2500\u2500 file3.txt\n&gt;&gt;&gt; print(tree(tmpdir, lambda s: _DirTree._default_filter(s) and not \"file2\" in s))\ntree.doctest/\n\u2514\u2500\u2500 dir/\n    \u251c\u2500\u2500 dir2/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 dir2a/\n    \u2502   \u251c\u2500\u2500 file1.txt\n    \u2502   \u2514\u2500\u2500 file3.txt\n    \u251c\u2500\u2500 file1.txt\n    \u2514\u2500\u2500 file3.txt\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.tree(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>)           \u2013            <p>Directory string to make tree for</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.tree(filterfn)","title":"<code>filterfn</code>","text":"(<code>Callable[[str], bool] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function to filter sub-directories and sub-files with</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen","title":"walk_gen","text":"<pre><code>walk_gen(\n    dirpath: FsPath = \".\",\n    *,\n    abspath: bool = True,\n    topdown: bool = True,\n    onerror: Callable[[OSError], Any] | None = None,\n    followlinks: bool = False,\n    check: bool = True,\n) -&gt; Iterator[str]\n</code></pre> <p>Yield all paths beneath a given dirpath (defaults to os.getcwd())</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[str]</code>           \u2013            <p>Generator object that yields directory paths (absolute or relative)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tmpdir = 'walk_gen.doctest'\n&gt;&gt;&gt; from os import makedirs; _makedirs(tmpdir, exist_ok=True)\n&gt;&gt;&gt; filepath_parts = [\n...     (\"dir\", \"file1.txt\"),\n...     (\"dir\", \"file2.txt\"),\n...     (\"dir\", \"file3.txt\"),\n...     (\"dir\", \"dir2\", \"file1.txt\"),\n...     (\"dir\", \"dir2\", \"file2.txt\"),\n...     (\"dir\", \"dir2\", \"file3.txt\"),\n...     (\"dir\", \"dir2a\", \"file1.txt\"),\n...     (\"dir\", \"dir2a\", \"file2.txt\"),\n...     (\"dir\", \"dir2a\", \"file3.txt\"),\n... ]\n&gt;&gt;&gt; from shellfish.fs import touch\n&gt;&gt;&gt; expected_dirs = []\n&gt;&gt;&gt; expected_files = []\n&gt;&gt;&gt; for f in filepath_parts:\n...     fspath = path.join(*f).replace('\\\\', '/')\n...     fspath = path.join(tmpdir, fspath).replace('\\\\', '/')\n...     dirpath = path.dirname(fspath)\n...     expected_files.append(fspath)\n...     expected_dirs.append(dirpath)\n...     _makedirs(dirpath, exist_ok=True)\n...     touch(fspath)\n&gt;&gt;&gt; expected_dirs = [el.replace('\\\\', '/') for el in sorted(set(expected_dirs))]\n&gt;&gt;&gt; from pprint import pprint\n&gt;&gt;&gt; pprint(expected_files)\n['walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt']\n&gt;&gt;&gt; pprint(expected_dirs)\n['walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2a']\n&gt;&gt;&gt; walk_gen_list = list(sorted(walk_gen(tmpdir)))\n&gt;&gt;&gt; walk_gen_list = [el.replace('\\\\', '/') for el in walk_gen_list]\n&gt;&gt;&gt; pprint(walk_gen_list)\n['walk_gen.doctest',\n 'walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt',\n 'walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; expected = sorted(set(expected_files + expected_dirs + [tmpdir]))\n&gt;&gt;&gt; pprint(expected)\n['walk_gen.doctest',\n 'walk_gen.doctest/dir',\n 'walk_gen.doctest/dir/dir2',\n 'walk_gen.doctest/dir/dir2/file1.txt',\n 'walk_gen.doctest/dir/dir2/file2.txt',\n 'walk_gen.doctest/dir/dir2/file3.txt',\n 'walk_gen.doctest/dir/dir2a',\n 'walk_gen.doctest/dir/dir2a/file1.txt',\n 'walk_gen.doctest/dir/dir2a/file2.txt',\n 'walk_gen.doctest/dir/dir2a/file3.txt',\n 'walk_gen.doctest/dir/file1.txt',\n 'walk_gen.doctest/dir/file2.txt',\n 'walk_gen.doctest/dir/file3.txt']\n&gt;&gt;&gt; walk_gen_list == expected\nTrue\n&gt;&gt;&gt; from shutil import rmtree\n&gt;&gt;&gt; rmtree(tmpdir)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen(dirpath)","title":"<code>dirpath</code>","text":"(<code>FsPath</code>, default:                   <code>'.'</code> )           \u2013            <p>Directory path to walk down/through.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen(abspath)","title":"<code>abspath</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Yield the absolute path</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen(onerror)","title":"<code>onerror</code>","text":"(<code>Callable[[OSError], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Function called on OSError</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen(topdown)","title":"<code>topdown</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Not applicable</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen(followlinks)","title":"<code>followlinks</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Follow links</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.walk_gen(check)","title":"<code>check</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Check if dirpath exists</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.where","title":"where","text":"<pre><code>where(cmd: str, path: str | None = None) -&gt; str | None\n</code></pre> <p>Return the result of <code>shutil.which</code>; alias of shellfish.sh.which</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: path to command/exe</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.where(cmd)","title":"<code>cmd</code>","text":"(<code>str</code>)           \u2013            <p>Command/exe to find path of</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.where(path)","title":"<code>path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>System path to use</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.which","title":"which","text":"<pre><code>which(cmd: str, path: str | None = None) -&gt; str | None\n</code></pre> <p>Return the result of <code>shutil.which</code></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: path to command/exe</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.which(cmd)","title":"<code>cmd</code>","text":"(<code>str</code>)           \u2013            <p>Command/exe to find path of</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.which(path)","title":"<code>path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>System path to use</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.which_lru","title":"which_lru  <code>cached</code>","text":"<pre><code>which_lru(cmd: str, path: str | None = None) -&gt; str | None\n</code></pre> <p>Return the result of <code>shutil.which</code> and cache the results</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Optional[str]: path to command/exe</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.which_lru(cmd)","title":"<code>cmd</code>","text":"(<code>str</code>)           \u2013            <p>Command/exe to find path of</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.which_lru(path)","title":"<code>path</code>","text":"(<code>str</code>, default:                   <code>None</code> )           \u2013            <p>System path to use</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes","title":"write_bytes","text":"<pre><code>write_bytes(\n    filepath: FsPath,\n    bites: bytes,\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/Save bytes to a fspath</p> <p>The parameter 'bites' is used instead of 'bytes' to not redefine the built-in python bytes object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"wbytes.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; write_bytes(fspath, bites_to_save)\n20\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the file after writing; default is None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_async","title":"write_bytes_async  <code>async</code>","text":"<pre><code>write_bytes_async(\n    filepath: FsPath,\n    bites: bytes,\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>(ASYNC) Write/Save bytes to a fspath</p> <p>The parameter 'bites' is used instead of 'bytes' so as to not redefine the built-in python bytes object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs._async import read_bytes_async, write_bytes_async\n&gt;&gt;&gt; from asyncio import run as aiorun\n&gt;&gt;&gt; fspath = \"wbytes_async.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = b\"These are some bytes\"\n&gt;&gt;&gt; aiorun(write_bytes_async(fspath, bites_to_save))\n20\n&gt;&gt;&gt; bites_to_save  # they are bytes!\nb'These are some bytes'\n&gt;&gt;&gt; aiorun(read_bytes_async(fspath))\nb'These are some bytes'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; otherwise overwrite</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_async(bites)","title":"<code>bites</code>","text":"(<code>bytes</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_async(chmod)","title":"<code>chmod</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath to this mode after writing</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen","title":"write_bytes_gen","text":"<pre><code>write_bytes_gen(\n    filepath: FsPath,\n    bytes_gen: Iterable[bytes],\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/Save bytes to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_bytes, write_bytes\n&gt;&gt;&gt; fspath = \"wbytes_gen.doctest.txt\"\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save  # they are bytes!\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; write_bytes_gen(fspath, (b for b in bites_to_save))\n35\n&gt;&gt;&gt; read_bytes(fspath)\nb'These are some bytes... more bytes!'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen(bytes_gen)","title":"<code>bytes_gen</code>","text":"(<code>Iterable[bytes]</code>)           \u2013            <p>Bytes to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the file after writing; default is None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen_async","title":"write_bytes_gen_async  <code>async</code>","text":"<pre><code>write_bytes_gen_async(\n    filepath: FsPath,\n    bytes_gen: Iterable[bytes] | AsyncIterable[bytes],\n    *,\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Write/save bytes to a filepath from an (async)iterable/iterator of bytes</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>number of bytes written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from os import remove\n&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import write_bytes_gen_async, read_bytes_gen_async\n&gt;&gt;&gt; fspath = 'wbytes_gen_async.doctest.txt'\n&gt;&gt;&gt; bites_to_save = (b\"These are some bytes... \", b\"more bytes!\")\n&gt;&gt;&gt; bites_to_save\n(b'These are some bytes... ', b'more bytes!')\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; async def read():\n...     async for b in read_bytes_gen_async(fspath, blocksize=4):\n...         print(b)\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; async def async_gen():\n...     for b in bites_to_save:\n...        yield b\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, bites_to_save))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n&gt;&gt;&gt; class AsyncIterable:\n...     def __aiter__(self):\n...         return async_gen()\n&gt;&gt;&gt; run(write_bytes_gen_async(fspath, AsyncIterable()))\n35\n&gt;&gt;&gt; run(read())\nb'Thes'\nb'e ar'\nb'e so'\nb'me b'\nb'ytes'\nb'... '\nb'more'\nb' byt'\nb'es!'\n&gt;&gt;&gt; remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen_async(bytes_gen)","title":"<code>bytes_gen</code>","text":"(<code>Iterable[bytes] | AsyncIterable[bytes]</code>)           \u2013            <p>AsyncIterable/Iterator of bytes to write</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; otherwise overwrite</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_bytes_gen_async(chmod)","title":"<code>chmod</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json","title":"write_json","text":"<pre><code>write_json(\n    filepath: FsPath,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    chmod: int | None = None,\n    append: bool = False,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Save/Write json-serial-ize-able data to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_json, write_json\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n19\n&gt;&gt;&gt; read_json(fspath)\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"rjson_dict.doctest.json\"\n&gt;&gt;&gt; write_json(fspath, data)\n25\n&gt;&gt;&gt; read_json(fspath)\n[['a', 1], ['b', 2], ['c', 3]]\n&gt;&gt;&gt; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(data)","title":"<code>data</code>","text":"(<code>Any</code>)           \u2013            <p>json-serial-ize-able data</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append a newline to the end of the file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional chmod to set on file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the file if True, overwrite otherwise; default</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to jsonbourne.JSON.dumpb</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async","title":"write_json_async  <code>async</code>","text":"<pre><code>write_json_async(\n    filepath: FsPath,\n    data: Any,\n    *,\n    fmt: bool = False,\n    pretty: bool = False,\n    sort_keys: bool = False,\n    append_newline: bool = False,\n    default: Callable[[Any], Any] | None = None,\n    append: bool = False,\n    chmod: int | None = None,\n    **kwargs: Any,\n) -&gt; int\n</code></pre> <p>Save/Write json-serial-ize-able data to a fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>Number of bytes written</p> </li> </ul> <p>Examples:</p> <p>Imports:</p> <pre><code>&gt;&gt;&gt; from asyncio import run\n&gt;&gt;&gt; from shellfish.fs._async import read_json_async, write_json_async\n</code></pre> <p>Dictionaries:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; fspath = \"wjson_async_dict.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n19\n&gt;&gt;&gt; run(read_json_async(fspath))\n{'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre> <p>Lists:</p> <pre><code>&gt;&gt;&gt; data = {'a': 1, 'b': 2, 'c': 3}\n&gt;&gt;&gt; data = list(data.items())\n&gt;&gt;&gt; data  # has tuples, but will be saved as strings\n[('a', 1), ('b', 2), ('c', 3)]\n&gt;&gt;&gt; fspath = \"wjson_async_list.doctest.json\"\n&gt;&gt;&gt; run(write_json_async(fspath, data))\n25\n&gt;&gt;&gt; run(read_json_async(fspath))\n[['a', 1], ['b', 2], ['c', 3]]\n</code></pre> <pre><code>&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(data)","title":"<code>data</code>","text":"(<code>Any</code>)           \u2013            <p>json-serial-ize-able data</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(fmt)","title":"<code>fmt</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(pretty)","title":"<code>pretty</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indented (2 spaces) or minify data (default=False)</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(sort_keys)","title":"<code>sort_keys</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(append_newline)","title":"<code>append_newline</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Sort the data keys if the data is a dictionary.</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(default)","title":"<code>default</code>","text":"(<code>Callable[[Any], Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>default function hook</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_json_async(**kwargs)","title":"<code>**kwargs</code>","text":"(<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments to pass to jsonbourne.JSON.dump</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str","title":"write_str","text":"<pre><code>write_str(\n    filepath: FsPath,\n    string: str,\n    *,\n    encoding: str = \"utf-8\",\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>Save/Write a string to fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>None</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from shellfish.fs import read_str, write_str\n&gt;&gt;&gt; fspath = \"sstring.doctest.txt\"\n&gt;&gt;&gt; write_str(fspath, r'Check out this string')\n21\n&gt;&gt;&gt; read_str(fspath)\n'Check out this string'\n&gt;&gt;&gt; import os; os.remove(fspath)\n</code></pre>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>String encoding to write file with</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag to append to file; default = False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>Optional chmod to set on file</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str_async","title":"write_str_async  <code>async</code>","text":"<pre><code>write_str_async(\n    filepath: FsPath,\n    string: str,\n    *,\n    encoding: str = \"utf-8\",\n    append: bool = False,\n    chmod: int | None = None,\n) -&gt; int\n</code></pre> <p>(ASYNC) Save/Write a string to fspath</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>number of bytes written</p> </li> </ul>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str_async(filepath)","title":"<code>filepath</code>","text":"(<code>FsPath</code>)           \u2013            <p>fspath to write to</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str_async(string)","title":"<code>string</code>","text":"(<code>str</code>)           \u2013            <p>string to be written</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str_async(encoding)","title":"<code>encoding</code>","text":"(<code>str</code>, default:                   <code>'utf-8'</code> )           \u2013            <p>File encoding (Default='utf-8')</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str_async(append)","title":"<code>append</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Append to the fspath if True; default is False</p>"},{"location":"libs/shellfish/shellfish.api/#shellfish.sh.write_str_async(chmod)","title":"<code>chmod</code>","text":"(<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>chmod the fspath if not None</p>"},{"location":"libs/xtyping/","title":"xtyping","text":"In\u00a0[2]: Copied! <pre>import xtyping as xt\n\nfrom_typing = [\n    \"  ~  \".join((f\"xt.{el}\", f\"typing.{el}\", str(getattr(xt, el))))\n    for el in xt.__all_typing__\n]\nfrom_typing_extensions = [\n    \"  ~  \".join((f\"xt.{el}\", f\"typing_extensions.{el}\", str(getattr(xt, el))))\n    for el in xt.__all_typing__\n]\nfrom_xtyping_shed = [\n    \"  ~  \".join((f\"xt.{el}\", f\"xtyping.shed.{el}\", str(getattr(xt, el))))\n    for el in xt.__all_shed__\n]\nprint(\n    \"\\n\".join([\n        \"-------------\",\n        \"from `typing`\",\n        \"-------------\",\n        *from_typing,\n        \"\\n\",\n        \"------------------------\",\n        \"from `typing_extensions`\",\n        \"------------------------\",\n        *from_typing_extensions,\n        \"\\n\",\n        \"-------------------\",\n        \"from `xtyping.shed`\",\n        \"-------------------\",\n        *from_xtyping_shed,\n        \"\\n\",\n    ])\n)\n</pre> import xtyping as xt  from_typing = [     \"  ~  \".join((f\"xt.{el}\", f\"typing.{el}\", str(getattr(xt, el))))     for el in xt.__all_typing__ ] from_typing_extensions = [     \"  ~  \".join((f\"xt.{el}\", f\"typing_extensions.{el}\", str(getattr(xt, el))))     for el in xt.__all_typing__ ] from_xtyping_shed = [     \"  ~  \".join((f\"xt.{el}\", f\"xtyping.shed.{el}\", str(getattr(xt, el))))     for el in xt.__all_shed__ ] print(     \"\\n\".join([         \"-------------\",         \"from `typing`\",         \"-------------\",         *from_typing,         \"\\n\",         \"------------------------\",         \"from `typing_extensions`\",         \"------------------------\",         *from_typing_extensions,         \"\\n\",         \"-------------------\",         \"from `xtyping.shed`\",         \"-------------------\",         *from_xtyping_shed,         \"\\n\",     ]) ) Out[2]: <pre>\"-------------\\nfrom `typing`\\n-------------\\nxt.AbstractSet  ~  typing.AbstractSet  ~  typing.AbstractSet\\nxt.Any  ~  typing.Any  ~  typing.Any\\nxt.AnyStr  ~  typing.AnyStr  ~  ~AnyStr\\nxt.AsyncContextManager  ~  typing.AsyncContextManager  ~  typing.AbstractAsyncContextManager\\nxt.AsyncGenerator  ~  typing.AsyncGenerator  ~  typing.AsyncGenerator\\nxt.AsyncIterable  ~  typing.AsyncIterable  ~  typing.AsyncIterable\\nxt.AsyncIterator  ~  typing.AsyncIterator  ~  typing.AsyncIterator\\nxt.Awaitable  ~  typing.Awaitable  ~  typing.Awaitable\\nxt.ByteString  ~  typing.ByteString  ~  typing.ByteString\\nxt.Callable  ~  typing.Callable  ~  typing.Callable\\nxt.ChainMap  ~  typing.ChainMap  ~  typing.ChainMap\\nxt.ClassVar  ~  typing.ClassVar  ~  typing.ClassVar\\nxt.Collection  ~  typing.Collection  ~  typing.Collection\\nxt.Container  ~  typing.Container  ~  typing.Container\\nxt.ContextManager  ~  typing.ContextManager  ~  typing.AbstractContextManager\\nxt.Coroutine  ~  typing.Coroutine  ~  typing.Coroutine\\nxt.Counter  ~  typing.Counter  ~  typing.Counter\\nxt.DefaultDict  ~  typing.DefaultDict  ~  typing.DefaultDict\\nxt.Deque  ~  typing.Deque  ~  typing.Deque\\nxt.Dict  ~  typing.Dict  ~  typing.Dict\\nxt.FrozenSet  ~  typing.FrozenSet  ~  typing.FrozenSet\\nxt.Generator  ~  typing.Generator  ~  typing.Generator\\nxt.Generic  ~  typing.Generic  ~  &lt;class 'typing.Generic'&gt;\\nxt.Hashable  ~  typing.Hashable  ~  typing.Hashable\\nxt.IO  ~  typing.IO  ~  &lt;class 'typing.IO'&gt;\\nxt.ItemsView  ~  typing.ItemsView  ~  typing.ItemsView\\nxt.Iterable  ~  typing.Iterable  ~  typing.Iterable\\nxt.Iterator  ~  typing.Iterator  ~  typing.Iterator\\nxt.KeysView  ~  typing.KeysView  ~  typing.KeysView\\nxt.List  ~  typing.List  ~  typing.List\\nxt.Mapping  ~  typing.Mapping  ~  typing.Mapping\\nxt.MappingView  ~  typing.MappingView  ~  typing.MappingView\\nxt.MutableMapping  ~  typing.MutableMapping  ~  typing.MutableMapping\\nxt.MutableSequence  ~  typing.MutableSequence  ~  typing.MutableSequence\\nxt.MutableSet  ~  typing.MutableSet  ~  typing.MutableSet\\nxt.NamedTuple  ~  typing.NamedTuple  ~  &lt;class 'typing.NamedTuple'&gt;\\nxt.NewType  ~  typing.NewType  ~  &lt;function NewType at 0x7ff0bbcc2b80&gt;\\nxt.Optional  ~  typing.Optional  ~  typing.Optional\\nxt.Reversible  ~  typing.Reversible  ~  typing.Reversible\\nxt.Sequence  ~  typing.Sequence  ~  typing.Sequence\\nxt.Set  ~  typing.Set  ~  typing.Set\\nxt.Sized  ~  typing.Sized  ~  typing.Sized\\nxt.SupportsAbs  ~  typing.SupportsAbs  ~  &lt;class 'typing.SupportsAbs'&gt;\\nxt.SupportsBytes  ~  typing.SupportsBytes  ~  &lt;class 'typing.SupportsBytes'&gt;\\nxt.SupportsComplex  ~  typing.SupportsComplex  ~  &lt;class 'typing.SupportsComplex'&gt;\\nxt.SupportsFloat  ~  typing.SupportsFloat  ~  &lt;class 'typing.SupportsFloat'&gt;\\nxt.SupportsInt  ~  typing.SupportsInt  ~  &lt;class 'typing.SupportsInt'&gt;\\nxt.SupportsRound  ~  typing.SupportsRound  ~  &lt;class 'typing.SupportsRound'&gt;\\nxt.TYPE_CHECKING  ~  typing.TYPE_CHECKING  ~  False\\nxt.Text  ~  typing.Text  ~  &lt;class 'str'&gt;\\nxt.Tuple  ~  typing.Tuple  ~  typing.Tuple\\nxt.Type  ~  typing.Type  ~  typing.Type\\nxt.TypeVar  ~  typing.TypeVar  ~  &lt;class 'typing.TypeVar'&gt;\\nxt.Union  ~  typing.Union  ~  typing.Union\\nxt.ValuesView  ~  typing.ValuesView  ~  typing.ValuesView\\nxt.cast  ~  typing.cast  ~  &lt;function cast at 0x7ff0bbcb79d0&gt;\\nxt.get_type_hints  ~  typing.get_type_hints  ~  &lt;function get_type_hints at 0x7ff0bbcb7af0&gt;\\nxt.no_type_check  ~  typing.no_type_check  ~  &lt;function no_type_check at 0x7ff0bbcb7ca0&gt;\\nxt.no_type_check_decorator  ~  typing.no_type_check_decorator  ~  &lt;function no_type_check_decorator at 0x7ff0bbcb7d30&gt;\\nxt.overload  ~  typing.overload  ~  &lt;function overload at 0x7ff0bbcb7e50&gt;\\nxt.__all_typing__  ~  typing.__all_typing__  ~  ['AbstractSet', 'Any', 'AnyStr', 'AsyncContextManager', 'AsyncGenerator', 'AsyncIterable', 'AsyncIterator', 'Awaitable', 'ByteString', 'Callable', 'ChainMap', 'ClassVar', 'Collection', 'Container', 'ContextManager', 'Coroutine', 'Counter', 'DefaultDict', 'Deque', 'Dict', 'FrozenSet', 'Generator', 'Generic', 'Hashable', 'IO', 'ItemsView', 'Iterable', 'Iterator', 'KeysView', 'List', 'Mapping', 'MappingView', 'MutableMapping', 'MutableSequence', 'MutableSet', 'NamedTuple', 'NewType', 'Optional', 'Reversible', 'Sequence', 'Set', 'Sized', 'SupportsAbs', 'SupportsBytes', 'SupportsComplex', 'SupportsFloat', 'SupportsInt', 'SupportsRound', 'TYPE_CHECKING', 'Text', 'Tuple', 'Type', 'TypeVar', 'Union', 'ValuesView', 'cast', 'get_type_hints', 'no_type_check', 'no_type_check_decorator', 'overload', '__all_typing__']\\n\\n\\n------------------------\\nfrom `typing_extensions`\\n------------------------\\nxt.AbstractSet  ~  typing_extensions.AbstractSet  ~  typing.AbstractSet\\nxt.Any  ~  typing_extensions.Any  ~  typing.Any\\nxt.AnyStr  ~  typing_extensions.AnyStr  ~  ~AnyStr\\nxt.AsyncContextManager  ~  typing_extensions.AsyncContextManager  ~  typing.AbstractAsyncContextManager\\nxt.AsyncGenerator  ~  typing_extensions.AsyncGenerator  ~  typing.AsyncGenerator\\nxt.AsyncIterable  ~  typing_extensions.AsyncIterable  ~  typing.AsyncIterable\\nxt.AsyncIterator  ~  typing_extensions.AsyncIterator  ~  typing.AsyncIterator\\nxt.Awaitable  ~  typing_extensions.Awaitable  ~  typing.Awaitable\\nxt.ByteString  ~  typing_extensions.ByteString  ~  typing.ByteString\\nxt.Callable  ~  typing_extensions.Callable  ~  typing.Callable\\nxt.ChainMap  ~  typing_extensions.ChainMap  ~  typing.ChainMap\\nxt.ClassVar  ~  typing_extensions.ClassVar  ~  typing.ClassVar\\nxt.Collection  ~  typing_extensions.Collection  ~  typing.Collection\\nxt.Container  ~  typing_extensions.Container  ~  typing.Container\\nxt.ContextManager  ~  typing_extensions.ContextManager  ~  typing.AbstractContextManager\\nxt.Coroutine  ~  typing_extensions.Coroutine  ~  typing.Coroutine\\nxt.Counter  ~  typing_extensions.Counter  ~  typing.Counter\\nxt.DefaultDict  ~  typing_extensions.DefaultDict  ~  typing.DefaultDict\\nxt.Deque  ~  typing_extensions.Deque  ~  typing.Deque\\nxt.Dict  ~  typing_extensions.Dict  ~  typing.Dict\\nxt.FrozenSet  ~  typing_extensions.FrozenSet  ~  typing.FrozenSet\\nxt.Generator  ~  typing_extensions.Generator  ~  typing.Generator\\nxt.Generic  ~  typing_extensions.Generic  ~  &lt;class 'typing.Generic'&gt;\\nxt.Hashable  ~  typing_extensions.Hashable  ~  typing.Hashable\\nxt.IO  ~  typing_extensions.IO  ~  &lt;class 'typing.IO'&gt;\\nxt.ItemsView  ~  typing_extensions.ItemsView  ~  typing.ItemsView\\nxt.Iterable  ~  typing_extensions.Iterable  ~  typing.Iterable\\nxt.Iterator  ~  typing_extensions.Iterator  ~  typing.Iterator\\nxt.KeysView  ~  typing_extensions.KeysView  ~  typing.KeysView\\nxt.List  ~  typing_extensions.List  ~  typing.List\\nxt.Mapping  ~  typing_extensions.Mapping  ~  typing.Mapping\\nxt.MappingView  ~  typing_extensions.MappingView  ~  typing.MappingView\\nxt.MutableMapping  ~  typing_extensions.MutableMapping  ~  typing.MutableMapping\\nxt.MutableSequence  ~  typing_extensions.MutableSequence  ~  typing.MutableSequence\\nxt.MutableSet  ~  typing_extensions.MutableSet  ~  typing.MutableSet\\nxt.NamedTuple  ~  typing_extensions.NamedTuple  ~  &lt;class 'typing.NamedTuple'&gt;\\nxt.NewType  ~  typing_extensions.NewType  ~  &lt;function NewType at 0x7ff0bbcc2b80&gt;\\nxt.Optional  ~  typing_extensions.Optional  ~  typing.Optional\\nxt.Reversible  ~  typing_extensions.Reversible  ~  typing.Reversible\\nxt.Sequence  ~  typing_extensions.Sequence  ~  typing.Sequence\\nxt.Set  ~  typing_extensions.Set  ~  typing.Set\\nxt.Sized  ~  typing_extensions.Sized  ~  typing.Sized\\nxt.SupportsAbs  ~  typing_extensions.SupportsAbs  ~  &lt;class 'typing.SupportsAbs'&gt;\\nxt.SupportsBytes  ~  typing_extensions.SupportsBytes  ~  &lt;class 'typing.SupportsBytes'&gt;\\nxt.SupportsComplex  ~  typing_extensions.SupportsComplex  ~  &lt;class 'typing.SupportsComplex'&gt;\\nxt.SupportsFloat  ~  typing_extensions.SupportsFloat  ~  &lt;class 'typing.SupportsFloat'&gt;\\nxt.SupportsInt  ~  typing_extensions.SupportsInt  ~  &lt;class 'typing.SupportsInt'&gt;\\nxt.SupportsRound  ~  typing_extensions.SupportsRound  ~  &lt;class 'typing.SupportsRound'&gt;\\nxt.TYPE_CHECKING  ~  typing_extensions.TYPE_CHECKING  ~  False\\nxt.Text  ~  typing_extensions.Text  ~  &lt;class 'str'&gt;\\nxt.Tuple  ~  typing_extensions.Tuple  ~  typing.Tuple\\nxt.Type  ~  typing_extensions.Type  ~  typing.Type\\nxt.TypeVar  ~  typing_extensions.TypeVar  ~  &lt;class 'typing.TypeVar'&gt;\\nxt.Union  ~  typing_extensions.Union  ~  typing.Union\\nxt.ValuesView  ~  typing_extensions.ValuesView  ~  typing.ValuesView\\nxt.cast  ~  typing_extensions.cast  ~  &lt;function cast at 0x7ff0bbcb79d0&gt;\\nxt.get_type_hints  ~  typing_extensions.get_type_hints  ~  &lt;function get_type_hints at 0x7ff0bbcb7af0&gt;\\nxt.no_type_check  ~  typing_extensions.no_type_check  ~  &lt;function no_type_check at 0x7ff0bbcb7ca0&gt;\\nxt.no_type_check_decorator  ~  typing_extensions.no_type_check_decorator  ~  &lt;function no_type_check_decorator at 0x7ff0bbcb7d30&gt;\\nxt.overload  ~  typing_extensions.overload  ~  &lt;function overload at 0x7ff0bbcb7e50&gt;\\nxt.__all_typing__  ~  typing_extensions.__all_typing__  ~  ['AbstractSet', 'Any', 'AnyStr', 'AsyncContextManager', 'AsyncGenerator', 'AsyncIterable', 'AsyncIterator', 'Awaitable', 'ByteString', 'Callable', 'ChainMap', 'ClassVar', 'Collection', 'Container', 'ContextManager', 'Coroutine', 'Counter', 'DefaultDict', 'Deque', 'Dict', 'FrozenSet', 'Generator', 'Generic', 'Hashable', 'IO', 'ItemsView', 'Iterable', 'Iterator', 'KeysView', 'List', 'Mapping', 'MappingView', 'MutableMapping', 'MutableSequence', 'MutableSet', 'NamedTuple', 'NewType', 'Optional', 'Reversible', 'Sequence', 'Set', 'Sized', 'SupportsAbs', 'SupportsBytes', 'SupportsComplex', 'SupportsFloat', 'SupportsInt', 'SupportsRound', 'TYPE_CHECKING', 'Text', 'Tuple', 'Type', 'TypeVar', 'Union', 'ValuesView', 'cast', 'get_type_hints', 'no_type_check', 'no_type_check_decorator', 'overload', '__all_typing__']\\n\\n\\n-------------------\\nfrom `xtyping.shed`\\n-------------------\\nxt.AF  ~  xtyping.shed.AF  ~  ~AF\\nxt.AnyCallable  ~  xtyping.shed.AnyCallable  ~  typing.Callable[..., typing.Any]\\nxt.AnyFunction  ~  xtyping.shed.AnyFunction  ~  typing.Union[typing.Callable[..., ~R], typing.Callable[..., typing.Awaitable[~R]]]\\nxt.AnyIterable  ~  xtyping.shed.AnyIterable  ~  typing.Union[typing.Iterable[~T], typing.AsyncIterable[~T]]\\nxt.AnyIterator  ~  xtyping.shed.AnyIterator  ~  typing.Union[typing.Iterator[~T], typing.AsyncIterator[~T]]\\nxt.ArrShape  ~  xtyping.shed.ArrShape  ~  typing.Tuple[int, ...]\\nxt.ArrayShape  ~  xtyping.shed.ArrayShape  ~  typing.Tuple[int, ...]\\nxt.Bytes  ~  xtyping.shed.Bytes  ~  typing.Union[bytes, bytearray]\\nxt.CmdArgsType  ~  xtyping.shed.CmdArgsType  ~  typing.Union[bytes, str, typing.Sequence[str], typing.Sequence[typing.Union[str, pathlib.Path]]]\\nxt.Decimal  ~  xtyping.shed.Decimal  ~  &lt;class 'decimal.Decimal'&gt;\\nxt.DT  ~  xtyping.shed.DT  ~  ~DT\\nxt.DictAny  ~  xtyping.shed.DictAny  ~  typing.Dict[typing.Any, typing.Any]\\nxt.DictAnyAny  ~  xtyping.shed.DictAnyAny  ~  typing.Dict[typing.Any, typing.Any]\\nxt.DictFloat  ~  xtyping.shed.DictFloat  ~  typing.Dict[float, float]\\nxt.DictFloatFloat  ~  xtyping.shed.DictFloatFloat  ~  typing.Dict[float, float]\\nxt.DictInt  ~  xtyping.shed.DictInt  ~  typing.Dict[int, int]\\nxt.DictIntInt  ~  xtyping.shed.DictIntInt  ~  typing.Dict[int, int]\\nxt.DictNumber  ~  xtyping.shed.DictNumber  ~  typing.Dict[typing.Union[int, float], typing.Union[int, float]]\\nxt.DictNumberNumber  ~  xtyping.shed.DictNumberNumber  ~  typing.Dict[typing.Union[int, float], typing.Union[int, float]]\\nxt.DictStr  ~  xtyping.shed.DictStr  ~  typing.Dict[str, str]\\nxt.DictStrAny  ~  xtyping.shed.DictStrAny  ~  typing.Dict[str, typing.Any]\\nxt.DictStrInt  ~  xtyping.shed.DictStrInt  ~  typing.Dict[str, int]\\nxt.DictStrStr  ~  xtyping.shed.DictStrStr  ~  typing.Dict[str, str]\\nxt.El  ~  xtyping.shed.El  ~  ~El\\nxt.Element  ~  xtyping.shed.Element  ~  ~Element\\nxt.EnvMap  ~  xtyping.shed.EnvMap  ~  typing.Union[typing.Mapping[bytes, typing.Union[bytes, str]], typing.Mapping[str, typing.Union[bytes, str]]]\\nxt.EnvType  ~  xtyping.shed.EnvType  ~  typing.Union[typing.Mapping[bytes, typing.Union[bytes, str]], typing.Mapping[str, typing.Union[bytes, str]]]\\nxt.F  ~  xtyping.shed.F  ~  ~F\\nxt.FN  ~  xtyping.shed.FN  ~  ~FN\\nxt.Flint  ~  xtyping.shed.Flint  ~  typing.Union[int, float]\\nxt.FsPath  ~  xtyping.shed.FsPath  ~  typing.Union[str, pathlib.Path]\\nxt.FsPathLike  ~  xtyping.shed.FsPathLike  ~  typing.Union[str, os.PathLike]\\nxt.FuncType  ~  xtyping.shed.FuncType  ~  typing.Callable[..., typing.Any]\\nxt.HrTime  ~  xtyping.shed.HrTime  ~  typing.Tuple[int, int]\\nxt.IO  ~  xtyping.shed.IO  ~  &lt;class 'typing.IO'&gt;\\nxt.IntStr  ~  xtyping.shed.IntStr  ~  typing.Union[int, str]\\nxt.IterableAny  ~  xtyping.shed.IterableAny  ~  typing.Iterable[typing.Any]\\nxt.IterableFloat  ~  xtyping.shed.IterableFloat  ~  typing.Iterable[float]\\nxt.IterableInt  ~  xtyping.shed.IterableInt  ~  typing.Iterable[int]\\nxt.IterableNumber  ~  xtyping.shed.IterableNumber  ~  typing.Iterable[typing.Union[int, float]]\\nxt.IterableStr  ~  xtyping.shed.IterableStr  ~  typing.Iterable[str]\\nxt.IterableT  ~  xtyping.shed.IterableT  ~  typing.Iterable[~T]\\nxt.JsonArrT  ~  xtyping.shed.JsonArrT  ~  typing.List[typing.Any]\\nxt.JsonDictT  ~  xtyping.shed.JsonDictT  ~  typing.Dict[str, typing.Any]\\nxt.JsonListT  ~  xtyping.shed.JsonListT  ~  typing.List[typing.Any]\\nxt.JsonObjT  ~  xtyping.shed.JsonObjT  ~  typing.Dict[str, typing.Any]\\nxt.KT  ~  xtyping.shed.KT  ~  ~KT\\nxt.KeyT  ~  xtyping.shed.KeyT  ~  ~KeyT\\nxt.KeyType  ~  xtyping.shed.KeyType  ~  ~KeyType\\nxt.ListAny  ~  xtyping.shed.ListAny  ~  typing.List[typing.Any]\\nxt.ListFloat  ~  xtyping.shed.ListFloat  ~  typing.List[float]\\nxt.ListInt  ~  xtyping.shed.ListInt  ~  typing.List[int]\\nxt.ListListStr  ~  xtyping.shed.ListListStr  ~  typing.List[typing.List[str]]\\nxt.ListNumber  ~  xtyping.shed.ListNumber  ~  typing.List[typing.Union[int, float]]\\nxt.ListStr  ~  xtyping.shed.ListStr  ~  typing.List[str]\\nxt.ListT  ~  xtyping.shed.ListT  ~  typing.List[~T]\\nxt.N  ~  xtyping.shed.N  ~  ~N\\nxt.NoneBytes  ~  xtyping.shed.NoneBytes  ~  typing.Union[bytes, NoneType]\\nxt.NoneStr  ~  xtyping.shed.NoneStr  ~  typing.Union[str, NoneType]\\nxt.NoneStrBytes  ~  xtyping.shed.NoneStrBytes  ~  typing.Union[str, bytes, NoneType]\\nxt.NoneType  ~  xtyping.shed.NoneType  ~  &lt;class 'NoneType'&gt;\\nxt.Null  ~  xtyping.shed.Null  ~  &lt;class 'NoneType'&gt;\\nxt.Number  ~  xtyping.shed.Number  ~  typing.Union[int, float]\\nxt.OptFloat  ~  xtyping.shed.OptFloat  ~  typing.Union[float, NoneType]\\nxt.OptInt  ~  xtyping.shed.OptInt  ~  typing.Union[int, NoneType]\\nxt.OptStr  ~  xtyping.shed.OptStr  ~  typing.Union[str, NoneType]\\nxt.OptionalFloat  ~  xtyping.shed.OptionalFloat  ~  typing.Union[float, NoneType]\\nxt.OptionalInt  ~  xtyping.shed.OptionalInt  ~  typing.Union[int, NoneType]\\nxt.OptionalStr  ~  xtyping.shed.OptionalStr  ~  typing.Union[str, NoneType]\\nxt.Path  ~  xtyping.shed.Path  ~  &lt;class 'pathlib.Path'&gt;\\nxt.PathLike  ~  xtyping.shed.PathLike  ~  &lt;class 'os.PathLike'&gt;\\nxt.R  ~  xtyping.shed.R  ~  ~R\\nxt.RT  ~  xtyping.shed.RT  ~  ~RT\\nxt.ReturnT  ~  xtyping.shed.ReturnT  ~  ~ReturnT\\nxt.ReturnType  ~  xtyping.shed.ReturnType  ~  ~ReturnType\\nxt.STDIN  ~  xtyping.shed.STDIN  ~  typing.Union[bytes, str, NoneType]\\nxt.STDIO  ~  xtyping.shed.STDIO  ~  typing.Union[NoneType, int, bytes, typing.IO[typing.Any]]\\nxt.SetAny  ~  xtyping.shed.SetAny  ~  typing.Set[typing.Any]\\nxt.SetFloat  ~  xtyping.shed.SetFloat  ~  typing.Set[float]\\nxt.SetInt  ~  xtyping.shed.SetInt  ~  typing.Set[int]\\nxt.SetNumber  ~  xtyping.shed.SetNumber  ~  typing.Set[typing.Union[int, float]]\\nxt.SetStr  ~  xtyping.shed.SetStr  ~  typing.Set[str]\\nxt.SetT  ~  xtyping.shed.SetT  ~  typing.Set[~T]\\nxt.ShapeType  ~  xtyping.shed.ShapeType  ~  typing.Tuple[int, ...]\\nxt.StrBytes  ~  xtyping.shed.StrBytes  ~  typing.Union[str, bytes]\\nxt.StrEnum  ~  xtyping.shed.StrEnum  ~  &lt;enum 'StrEnum'&gt;\\nxt.StrIntFloat  ~  xtyping.shed.StrIntFloat  ~  typing.Union[str, int, float]\\nxt.StringEnum  ~  xtyping.shed.StringEnum  ~  &lt;enum 'StringEnum'&gt;\\nxt.T  ~  xtyping.shed.T  ~  ~T\\nxt.T_co  ~  xtyping.shed.T_co  ~  +T_co\\nxt.T_contra  ~  xtyping.shed.T_contra  ~  -T_contra\\nxt.TupleStrStr  ~  xtyping.shed.TupleStrStr  ~  typing.Tuple[str, str]\\nxt.TupleStrs  ~  xtyping.shed.TupleStrs  ~  typing.Tuple[str, ...]\\nxt.Txt  ~  xtyping.shed.Txt  ~  typing.Union[bytes, str]\\nxt.VT  ~  xtyping.shed.VT  ~  ~VT\\nxt.VT_co  ~  xtyping.shed.VT_co  ~  +VT_co\\nxt.V_co  ~  xtyping.shed.V_co  ~  +V_co\\nxt.ValT  ~  xtyping.shed.ValT  ~  ~ValT\\nxt.ValType  ~  xtyping.shed.ValType  ~  ~ValType\\nxt._DT  ~  xtyping.shed._DT  ~  ~_DT\\nxt._R  ~  xtyping.shed._R  ~  ~_R\\nxt._RT  ~  xtyping.shed._RT  ~  ~_RT\\nxt._T  ~  xtyping.shed._T  ~  ~_T\\nxt.null  ~  xtyping.shed.null  ~  &lt;class 'NoneType'&gt;\\nxt.__all_shed__  ~  xtyping.shed.__all_shed__  ~  ['AF', 'AnyCallable', 'AnyFunction', 'AnyIterable', 'AnyIterator', 'ArrShape', 'ArrayShape', 'Bytes', 'CmdArgsType', 'Decimal', 'DT', 'DictAny', 'DictAnyAny', 'DictFloat', 'DictFloatFloat', 'DictInt', 'DictIntInt', 'DictNumber', 'DictNumberNumber', 'DictStr', 'DictStrAny', 'DictStrInt', 'DictStrStr', 'El', 'Element', 'EnvMap', 'EnvType', 'F', 'FN', 'Flint', 'FsPath', 'FsPathLike', 'FuncType', 'HrTime', 'IO', 'IntStr', 'IterableAny', 'IterableFloat', 'IterableInt', 'IterableNumber', 'IterableStr', 'IterableT', 'JsonArrT', 'JsonDictT', 'JsonListT', 'JsonObjT', 'KT', 'KeyT', 'KeyType', 'ListAny', 'ListFloat', 'ListInt', 'ListListStr', 'ListNumber', 'ListStr', 'ListT', 'N', 'NoneBytes', 'NoneStr', 'NoneStrBytes', 'NoneType', 'Null', 'Number', 'OptFloat', 'OptInt', 'OptStr', 'OptionalFloat', 'OptionalInt', 'OptionalStr', 'Path', 'PathLike', 'R', 'RT', 'ReturnT', 'ReturnType', 'STDIN', 'STDIO', 'SetAny', 'SetFloat', 'SetInt', 'SetNumber', 'SetStr', 'SetT', 'ShapeType', 'StrBytes', 'StrEnum', 'StrIntFloat', 'StringEnum', 'T', 'T_co', 'T_contra', 'TupleStrStr', 'TupleStrs', 'Txt', 'VT', 'VT_co', 'V_co', 'ValT', 'ValType', '_DT', '_R', '_RT', '_T', 'null', '__all_shed__']\\n\\n\"</pre>"},{"location":"libs/xtyping/#xtyping","title":"xtyping\u00b6","text":"<p>Install: <code>pip install xtyping</code></p>"},{"location":"libs/xtyping/#what-is-xtyping","title":"What is xtyping?\u00b6","text":"<p>xtyping (short for extended typing) lets you import all your friends from <code>typing</code> as well as <code>typing_extensions</code></p> <ul> <li><code>typing</code> | <code>typing_extensions</code>; xtyping 'exports' everything in <code>typing.__all__</code> and <code>typing_extensions.__all__</code></li> <li>Common type aliases</li> </ul>"},{"location":"libs/xtyping/#why-not-use-typing_extensions","title":"Why not use <code>typing_extensions</code>?\u00b6","text":"<p>Don't have to import both <code>typing</code> and <code>typing_extensions</code>; BOOM</p> <p>Instead of writing:</p> <pre><code>from typing import Optional\nfrom typing_extensions import TypedDict\n</code></pre> <p>you can write:</p> <pre><code>from xtyping import Optional, TypedDict\n# or\nimport xtyping as xt\nTypedDict = xt.TypedDict\nOptional = xt.Optional\n</code></pre>"},{"location":"notebooks/cache_money/","title":"Much Better","text":"In\u00a0[1]: Copied! <pre>def fib(n):\n    return n if n &lt; 2 else fib(n - 1) + fib(n - 2)\n</pre> def fib(n):     return n if n &lt; 2 else fib(n - 1) + fib(n - 2) In\u00a0[2]: Copied! <pre>from time import time\n\nfor i in range(40 + 1):\n    ti = time()\n    f = fib(i)\n    tf = time()\n    total_time = tf - ti\n    print(f\"n:{i:02d}   fib(n): {f}   funk-run-time: {total_time:.4f} sec\")\n</pre> from time import time  for i in range(40 + 1):     ti = time()     f = fib(i)     tf = time()     total_time = tf - ti     print(f\"n:{i:02d}   fib(n): {f}   funk-run-time: {total_time:.4f} sec\") <pre>n:00   fib(n): 0   funk-run-time: 0.0000 sec\nn:01   fib(n): 1   funk-run-time: 0.0000 sec\nn:02   fib(n): 1   funk-run-time: 0.0000 sec\nn:03   fib(n): 2   funk-run-time: 0.0000 sec\nn:04   fib(n): 3   funk-run-time: 0.0000 sec\nn:05   fib(n): 5   funk-run-time: 0.0000 sec\nn:06   fib(n): 8   funk-run-time: 0.0000 sec\nn:07   fib(n): 13   funk-run-time: 0.0000 sec\nn:08   fib(n): 21   funk-run-time: 0.0000 sec\nn:09   fib(n): 34   funk-run-time: 0.0000 sec\nn:10   fib(n): 55   funk-run-time: 0.0000 sec\nn:11   fib(n): 89   funk-run-time: 0.0000 sec\nn:12   fib(n): 144   funk-run-time: 0.0000 sec\nn:13   fib(n): 233   funk-run-time: 0.0010 sec\nn:14   fib(n): 377   funk-run-time: 0.0000 sec\nn:15   fib(n): 610   funk-run-time: 0.0000 sec\nn:16   fib(n): 987   funk-run-time: 0.0010 sec\nn:17   fib(n): 1597   funk-run-time: 0.0000 sec\nn:18   fib(n): 2584   funk-run-time: 0.0010 sec\nn:19   fib(n): 4181   funk-run-time: 0.0030 sec\nn:20   fib(n): 6765   funk-run-time: 0.0020 sec\nn:21   fib(n): 10946   funk-run-time: 0.0060 sec\nn:22   fib(n): 17711   funk-run-time: 0.0050 sec\nn:23   fib(n): 28657   funk-run-time: 0.0080 sec\nn:24   fib(n): 46368   funk-run-time: 0.0160 sec\nn:25   fib(n): 75025   funk-run-time: 0.0240 sec\nn:26   fib(n): 121393   funk-run-time: 0.0370 sec\nn:27   fib(n): 196418   funk-run-time: 0.0520 sec\nn:28   fib(n): 317811   funk-run-time: 0.0870 sec\nn:29   fib(n): 514229   funk-run-time: 0.1420 sec\nn:30   fib(n): 832040   funk-run-time: 0.2490 sec\nn:31   fib(n): 1346269   funk-run-time: 0.3990 sec\nn:32   fib(n): 2178309   funk-run-time: 0.6040 sec\nn:33   fib(n): 3524578   funk-run-time: 1.0010 sec\nn:34   fib(n): 5702887   funk-run-time: 1.6340 sec\nn:35   fib(n): 9227465   funk-run-time: 2.6530 sec\nn:36   fib(n): 14930352   funk-run-time: 4.1060 sec\nn:37   fib(n): 24157817   funk-run-time: 6.9640 sec\nn:38   fib(n): 39088169   funk-run-time: 12.1551 sec\nn:39   fib(n): 63245986   funk-run-time: 18.8260 sec\nn:40   fib(n): 102334155   funk-run-time: 28.9990 sec\n</pre> In\u00a0[3]: Copied! <pre>from functools import cache, lru_cache\n\n\n@cache\ndef fib(n):\n    return n if n &lt; 2 else fib(n - 1) + fib(n - 2)\n</pre> from functools import cache, lru_cache   @cache def fib(n):     return n if n &lt; 2 else fib(n - 1) + fib(n - 2) In\u00a0[4]: Copied! <pre>for i in range(40 + 1):\n    ti = time()\n    f = fib(i)\n    tf = time()\n    total_time = tf - ti\n    print(f\"n:{i:02d}   fib(n): {f}   funk-run-time: {total_time:.4f} sec\")\n</pre> for i in range(40 + 1):     ti = time()     f = fib(i)     tf = time()     total_time = tf - ti     print(f\"n:{i:02d}   fib(n): {f}   funk-run-time: {total_time:.4f} sec\") <pre>n:00   fib(n): 0   funk-run-time: 0.0000 sec\nn:01   fib(n): 1   funk-run-time: 0.0000 sec\nn:02   fib(n): 1   funk-run-time: 0.0000 sec\nn:03   fib(n): 2   funk-run-time: 0.0000 sec\nn:04   fib(n): 3   funk-run-time: 0.0000 sec\nn:05   fib(n): 5   funk-run-time: 0.0000 sec\nn:06   fib(n): 8   funk-run-time: 0.0000 sec\nn:07   fib(n): 13   funk-run-time: 0.0000 sec\nn:08   fib(n): 21   funk-run-time: 0.0000 sec\nn:09   fib(n): 34   funk-run-time: 0.0000 sec\nn:10   fib(n): 55   funk-run-time: 0.0000 sec\nn:11   fib(n): 89   funk-run-time: 0.0000 sec\nn:12   fib(n): 144   funk-run-time: 0.0000 sec\nn:13   fib(n): 233   funk-run-time: 0.0000 sec\nn:14   fib(n): 377   funk-run-time: 0.0000 sec\nn:15   fib(n): 610   funk-run-time: 0.0000 sec\nn:16   fib(n): 987   funk-run-time: 0.0000 sec\nn:17   fib(n): 1597   funk-run-time: 0.0000 sec\nn:18   fib(n): 2584   funk-run-time: 0.0000 sec\nn:19   fib(n): 4181   funk-run-time: 0.0000 sec\nn:20   fib(n): 6765   funk-run-time: 0.0000 sec\nn:21   fib(n): 10946   funk-run-time: 0.0000 sec\nn:22   fib(n): 17711   funk-run-time: 0.0000 sec\nn:23   fib(n): 28657   funk-run-time: 0.0000 sec\nn:24   fib(n): 46368   funk-run-time: 0.0000 sec\nn:25   fib(n): 75025   funk-run-time: 0.0000 sec\nn:26   fib(n): 121393   funk-run-time: 0.0000 sec\nn:27   fib(n): 196418   funk-run-time: 0.0000 sec\nn:28   fib(n): 317811   funk-run-time: 0.0000 sec\nn:29   fib(n): 514229   funk-run-time: 0.0000 sec\nn:30   fib(n): 832040   funk-run-time: 0.0000 sec\nn:31   fib(n): 1346269   funk-run-time: 0.0000 sec\nn:32   fib(n): 2178309   funk-run-time: 0.0000 sec\nn:33   fib(n): 3524578   funk-run-time: 0.0000 sec\nn:34   fib(n): 5702887   funk-run-time: 0.0000 sec\nn:35   fib(n): 9227465   funk-run-time: 0.0000 sec\nn:36   fib(n): 14930352   funk-run-time: 0.0000 sec\nn:37   fib(n): 24157817   funk-run-time: 0.0000 sec\nn:38   fib(n): 39088169   funk-run-time: 0.0000 sec\nn:39   fib(n): 63245986   funk-run-time: 0.0000 sec\nn:40   fib(n): 102334155   funk-run-time: 0.0000 sec\n</pre>"},{"location":"notebooks/cache_money/#pythons-built-in-lru_cache","title":"Python's built in lru_cache\u00b6","text":"<p>There's a module in Python's standard lib called functools and in that module is one of the best python secrets there is...</p> <p>Below is a function for computing the fibonacci sequence (you might be thinking 'thats a super naive way of computing the fibonacci sequence,' but bear with me).</p>"},{"location":"notebooks/cache_money/#that-was-slow","title":"THAT WAS SLOW!!\u00b6","text":"<p>Python is 'ok' with recursion, but it generally tends to slow down quite a bit. How can we speed this up quickly? Can we do it without messing with our OG-function? (NOTE: the run-times roughly resemble the fibonacci sequence)</p> <p>We can! The function below is the exact same function as the orig-fib-funk, BUT it has been decorated with the lru_cache decorator; this decorator was added in python 3 and caches a function's *args and **kwargs =&gt; return values as key =&gt; value pairs. lru_cache is perfect for recursive functions! The maxsize arg allows one to set the max cache size, but for most cases maxsize=None is perfectly fine.</p>"},{"location":"notebooks/cache_money/#much-better","title":"Much Better\u00b6","text":""},{"location":"notebooks/filter_none/","title":"Python filtering falsey ~","text":"In\u00a0[1]: Copied! <pre>import random\n\nres = [random.randrange(1, 300, 1) for i in range(100)]\nfor _i in range(100):\n    res.append(None)\nlists = [res]\nfor _i in range(40):\n    random.shuffle(res)\n    lists.append(res)\n</pre> import random  res = [random.randrange(1, 300, 1) for i in range(100)] for _i in range(100):     res.append(None) lists = [res] for _i in range(40):     random.shuffle(res)     lists.append(res) In\u00a0[2]: Copied! <pre>def filter_none_gen_comprehension(it):\n    return (i for i in it if i)\n</pre> def filter_none_gen_comprehension(it):     return (i for i in it if i) In\u00a0[3]: Copied! <pre>def filter_none(it):\n    return filter(None, it)\n</pre> def filter_none(it):     return filter(None, it) In\u00a0[4]: Copied! <pre>for l in lists[:3]:\n    print(\"\\n__________\")\n    print(l)\n    gen = list(filter_none_gen_comprehension(l))\n    fil = list(filter_none(l))\n    print(\"__VIA_GEN_FUNK__\")\n    print(gen)\n    print(\"__VIA_FILTER_NONE__\")\n    print(fil)\n    assert gen == fil\n</pre> for l in lists[:3]:     print(\"\\n__________\")     print(l)     gen = list(filter_none_gen_comprehension(l))     fil = list(filter_none(l))     print(\"__VIA_GEN_FUNK__\")     print(gen)     print(\"__VIA_FILTER_NONE__\")     print(fil)     assert gen == fil <pre>\n__________\n[283, 121, 39, 147, 160, 148, 241, None, 57, None, 252, None, None, None, 190, None, None, None, 222, None, None, None, 104, None, None, 85, None, 229, None, 219, None, None, None, 13, 124, None, None, 68, None, 143, 250, None, 153, 255, None, None, None, 26, None, None, 169, None, None, 199, 151, 259, 110, None, 72, 46, 262, None, 94, 20, None, 91, 225, None, None, 149, 211, 216, None, 129, None, 252, None, 109, None, 220, None, None, 113, None, 160, 145, None, 90, 294, 105, None, 236, None, 127, 196, 243, None, 188, 297, None, None, 171, 86, None, None, 224, 98, None, 258, 39, None, 43, None, 69, 271, 221, 12, None, None, None, None, 141, None, None, 200, None, None, 125, None, None, None, None, None, 293, 265, 48, 115, None, 220, None, 168, None, None, None, None, None, 87, None, None, 3, 227, None, 75, None, None, None, None, None, None, 199, None, None, 116, 245, 87, None, 231, 118, 204, None, None, 197, None, 117, None, None, None, 124, 257, 33, 151, None, 54, None, 92, None, 216, 208, 234, None, None, None, None, None, None, 192, None, 221, 51, 197]\n__VIA_GEN_FUNK__\n[283, 121, 39, 147, 160, 148, 241, 57, 252, 190, 222, 104, 85, 229, 219, 13, 124, 68, 143, 250, 153, 255, 26, 169, 199, 151, 259, 110, 72, 46, 262, 94, 20, 91, 225, 149, 211, 216, 129, 252, 109, 220, 113, 160, 145, 90, 294, 105, 236, 127, 196, 243, 188, 297, 171, 86, 224, 98, 258, 39, 43, 69, 271, 221, 12, 141, 200, 125, 293, 265, 48, 115, 220, 168, 87, 3, 227, 75, 199, 116, 245, 87, 231, 118, 204, 197, 117, 124, 257, 33, 151, 54, 92, 216, 208, 234, 192, 221, 51, 197]\n__VIA_FILTER_NONE__\n[283, 121, 39, 147, 160, 148, 241, 57, 252, 190, 222, 104, 85, 229, 219, 13, 124, 68, 143, 250, 153, 255, 26, 169, 199, 151, 259, 110, 72, 46, 262, 94, 20, 91, 225, 149, 211, 216, 129, 252, 109, 220, 113, 160, 145, 90, 294, 105, 236, 127, 196, 243, 188, 297, 171, 86, 224, 98, 258, 39, 43, 69, 271, 221, 12, 141, 200, 125, 293, 265, 48, 115, 220, 168, 87, 3, 227, 75, 199, 116, 245, 87, 231, 118, 204, 197, 117, 124, 257, 33, 151, 54, 92, 216, 208, 234, 192, 221, 51, 197]\n\n__________\n[283, 121, 39, 147, 160, 148, 241, None, 57, None, 252, None, None, None, 190, None, None, None, 222, None, None, None, 104, None, None, 85, None, 229, None, 219, None, None, None, 13, 124, None, None, 68, None, 143, 250, None, 153, 255, None, None, None, 26, None, None, 169, None, None, 199, 151, 259, 110, None, 72, 46, 262, None, 94, 20, None, 91, 225, None, None, 149, 211, 216, None, 129, None, 252, None, 109, None, 220, None, None, 113, None, 160, 145, None, 90, 294, 105, None, 236, None, 127, 196, 243, None, 188, 297, None, None, 171, 86, None, None, 224, 98, None, 258, 39, None, 43, None, 69, 271, 221, 12, None, None, None, None, 141, None, None, 200, None, None, 125, None, None, None, None, None, 293, 265, 48, 115, None, 220, None, 168, None, None, None, None, None, 87, None, None, 3, 227, None, 75, None, None, None, None, None, None, 199, None, None, 116, 245, 87, None, 231, 118, 204, None, None, 197, None, 117, None, None, None, 124, 257, 33, 151, None, 54, None, 92, None, 216, 208, 234, None, None, None, None, None, None, 192, None, 221, 51, 197]\n__VIA_GEN_FUNK__\n[283, 121, 39, 147, 160, 148, 241, 57, 252, 190, 222, 104, 85, 229, 219, 13, 124, 68, 143, 250, 153, 255, 26, 169, 199, 151, 259, 110, 72, 46, 262, 94, 20, 91, 225, 149, 211, 216, 129, 252, 109, 220, 113, 160, 145, 90, 294, 105, 236, 127, 196, 243, 188, 297, 171, 86, 224, 98, 258, 39, 43, 69, 271, 221, 12, 141, 200, 125, 293, 265, 48, 115, 220, 168, 87, 3, 227, 75, 199, 116, 245, 87, 231, 118, 204, 197, 117, 124, 257, 33, 151, 54, 92, 216, 208, 234, 192, 221, 51, 197]\n__VIA_FILTER_NONE__\n[283, 121, 39, 147, 160, 148, 241, 57, 252, 190, 222, 104, 85, 229, 219, 13, 124, 68, 143, 250, 153, 255, 26, 169, 199, 151, 259, 110, 72, 46, 262, 94, 20, 91, 225, 149, 211, 216, 129, 252, 109, 220, 113, 160, 145, 90, 294, 105, 236, 127, 196, 243, 188, 297, 171, 86, 224, 98, 258, 39, 43, 69, 271, 221, 12, 141, 200, 125, 293, 265, 48, 115, 220, 168, 87, 3, 227, 75, 199, 116, 245, 87, 231, 118, 204, 197, 117, 124, 257, 33, 151, 54, 92, 216, 208, 234, 192, 221, 51, 197]\n\n__________\n[283, 121, 39, 147, 160, 148, 241, None, 57, None, 252, None, None, None, 190, None, None, None, 222, None, None, None, 104, None, None, 85, None, 229, None, 219, None, None, None, 13, 124, None, None, 68, None, 143, 250, None, 153, 255, None, None, None, 26, None, None, 169, None, None, 199, 151, 259, 110, None, 72, 46, 262, None, 94, 20, None, 91, 225, None, None, 149, 211, 216, None, 129, None, 252, None, 109, None, 220, None, None, 113, None, 160, 145, None, 90, 294, 105, None, 236, None, 127, 196, 243, None, 188, 297, None, None, 171, 86, None, None, 224, 98, None, 258, 39, None, 43, None, 69, 271, 221, 12, None, None, None, None, 141, None, None, 200, None, None, 125, None, None, None, None, None, 293, 265, 48, 115, None, 220, None, 168, None, None, None, None, None, 87, None, None, 3, 227, None, 75, None, None, None, None, None, None, 199, None, None, 116, 245, 87, None, 231, 118, 204, None, None, 197, None, 117, None, None, None, 124, 257, 33, 151, None, 54, None, 92, None, 216, 208, 234, None, None, None, None, None, None, 192, None, 221, 51, 197]\n__VIA_GEN_FUNK__\n[283, 121, 39, 147, 160, 148, 241, 57, 252, 190, 222, 104, 85, 229, 219, 13, 124, 68, 143, 250, 153, 255, 26, 169, 199, 151, 259, 110, 72, 46, 262, 94, 20, 91, 225, 149, 211, 216, 129, 252, 109, 220, 113, 160, 145, 90, 294, 105, 236, 127, 196, 243, 188, 297, 171, 86, 224, 98, 258, 39, 43, 69, 271, 221, 12, 141, 200, 125, 293, 265, 48, 115, 220, 168, 87, 3, 227, 75, 199, 116, 245, 87, 231, 118, 204, 197, 117, 124, 257, 33, 151, 54, 92, 216, 208, 234, 192, 221, 51, 197]\n__VIA_FILTER_NONE__\n[283, 121, 39, 147, 160, 148, 241, 57, 252, 190, 222, 104, 85, 229, 219, 13, 124, 68, 143, 250, 153, 255, 26, 169, 199, 151, 259, 110, 72, 46, 262, 94, 20, 91, 225, 149, 211, 216, 129, 252, 109, 220, 113, 160, 145, 90, 294, 105, 236, 127, 196, 243, 188, 297, 171, 86, 224, 98, 258, 39, 43, 69, 271, 221, 12, 141, 200, 125, 293, 265, 48, 115, 220, 168, 87, 3, 227, 75, 199, 116, 245, 87, 231, 118, 204, 197, 117, 124, 257, 33, 151, 54, 92, 216, 208, 234, 192, 221, 51, 197]\n</pre> In\u00a0[5]: Copied! <pre>%%timeit\n# NBVAL_IGNORE_OUTPUT\nfor l in lists:\n    a = list(filter_none_gen_comprehension(l))\n</pre> %%timeit # NBVAL_IGNORE_OUTPUT for l in lists:     a = list(filter_none_gen_comprehension(l)) <pre>446 \u00b5s \u00b1 26 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n</pre> In\u00a0[6]: Copied! <pre>%%timeit\n# NBVAL_IGNORE_OUTPUT\nfor l in lists:\n    a = list(filter_none(l))\n</pre> %%timeit # NBVAL_IGNORE_OUTPUT for l in lists:     a = list(filter_none(l)) <pre>122 \u00b5s \u00b1 2.54 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</pre>"},{"location":"notebooks/filter_none/#python-filtering-falsey-filternone-iterable","title":"Python filtering falsey ~ <code>filter(None, iterable)</code>\u00b6","text":"<p>Start by making a bunch of random lists</p>"},{"location":"notebooks/filter_none/#make-the-two-functions-one-using-filternone-iterable-the-other-using-a-generator-comprehension","title":"Make the two functions one using <code>filter(None, iterable)</code> the other using a generator comprehension\u00b6","text":""},{"location":"notebooks/filter_none/#below-you-can-see-the-functions-produce-the-same-thing","title":"Below you can see the functions produce the same thing:\u00b6","text":""},{"location":"notebooks/filter_none/#timing-the-two-functions-reveals-that-the-function-using-filter-takes-about-14th-15th-of-the-time-the-generator-comprehension-does","title":"Timing the two functions reveals that the function using filter takes about 1/4th - 1/5th of the time the generator comprehension does!\u00b6","text":""},{"location":"notebooks/json_parsing/","title":"JSON &amp; python","text":"In\u00a0[1]: Copied! <pre>data = {\n    \"id\": 1,\n    \"code\": None,\n    \"subd\": {\"a\": 23, \"b\": {\"herm\": 2}},\n    \"type\": \"foo\",\n    \"bars\": [\n        {\"id\": 6934900},\n        {\"id\": 6934977},\n        {\"id\": 6934992},\n        {\"id\": 6934993},\n        {\"id\": 6935014},\n    ],\n    \"n\": 10,\n    \"date_str\": \"2013-07-08 00:00:00\",\n    \"float_here\": 0.454545,\n    \"complex\": [{\"id\": 83865, \"goal\": \"herm\", \"state\": \"active\"}],\n    \"profile_id\": None,\n    \"state\": \"active\",\n}\n</pre> data = {     \"id\": 1,     \"code\": None,     \"subd\": {\"a\": 23, \"b\": {\"herm\": 2}},     \"type\": \"foo\",     \"bars\": [         {\"id\": 6934900},         {\"id\": 6934977},         {\"id\": 6934992},         {\"id\": 6934993},         {\"id\": 6935014},     ],     \"n\": 10,     \"date_str\": \"2013-07-08 00:00:00\",     \"float_here\": 0.454545,     \"complex\": [{\"id\": 83865, \"goal\": \"herm\", \"state\": \"active\"}],     \"profile_id\": None,     \"state\": \"active\", } In\u00a0[2]: Copied! <pre>data_python_str = str(data)\ndata_python_str  # here is our string\n</pre> data_python_str = str(data) data_python_str  # here is our string Out[2]: <pre>\"{'id': 1, 'code': None, 'subd': {'a': 23, 'b': {'herm': 2}}, 'type': 'foo', 'bars': [{'id': 6934900}, {'id': 6934977}, {'id': 6934992}, {'id': 6934993}, {'id': 6935014}], 'n': 10, 'date_str': '2013-07-08 00:00:00', 'float_here': 0.454545, 'complex': [{'id': 83865, 'goal': 'herm', 'state': 'active'}], 'profile_id': None, 'state': 'active'}\"</pre> In\u00a0[3]: Copied! <pre>import json\n\ndata_json_string = json.dumps(data)\ndata_json_string\n</pre> import json  data_json_string = json.dumps(data) data_json_string Out[3]: <pre>'{\"id\": 1, \"code\": null, \"subd\": {\"a\": 23, \"b\": {\"herm\": 2}}, \"type\": \"foo\", \"bars\": [{\"id\": 6934900}, {\"id\": 6934977}, {\"id\": 6934992}, {\"id\": 6934993}, {\"id\": 6935014}], \"n\": 10, \"date_str\": \"2013-07-08 00:00:00\", \"float_here\": 0.454545, \"complex\": [{\"id\": 83865, \"goal\": \"herm\", \"state\": \"active\"}], \"profile_id\": null, \"state\": \"active\"}'</pre> In\u00a0[4]: Copied! <pre>try:\n    print(parsed_dict_str)\nexcept NameError:\n    print(\"'parsed_dict_str' is not defined ... yet ...\")\n</pre> try:     print(parsed_dict_str) except NameError:     print(\"'parsed_dict_str' is not defined ... yet ...\") <pre>'parsed_dict_str' is not defined ... yet ...\n</pre> In\u00a0[5]: Copied! <pre>parse_and_set_data_python_str = \"parsed_dict_str = \" + data_python_str\nprint(\"This is the python string we are going to execute to do the parsing:\")\nparse_and_set_data_python_str\n</pre> parse_and_set_data_python_str = \"parsed_dict_str = \" + data_python_str print(\"This is the python string we are going to execute to do the parsing:\") parse_and_set_data_python_str <pre>This is the python string we are going to execute to do the parsing:\n</pre> Out[5]: <pre>\"parsed_dict_str = {'id': 1, 'code': None, 'subd': {'a': 23, 'b': {'herm': 2}}, 'type': 'foo', 'bars': [{'id': 6934900}, {'id': 6934977}, {'id': 6934992}, {'id': 6934993}, {'id': 6935014}], 'n': 10, 'date_str': '2013-07-08 00:00:00', 'float_here': 0.454545, 'complex': [{'id': 83865, 'goal': 'herm', 'state': 'active'}], 'profile_id': None, 'state': 'active'}\"</pre> In\u00a0[6]: Copied! <pre>exec(parse_and_set_data_python_str)\nprint(\"NOW IT IS DEFINED\")\nparsed_dict_str\n</pre> exec(parse_and_set_data_python_str) print(\"NOW IT IS DEFINED\") parsed_dict_str <pre>NOW IT IS DEFINED\n</pre> Out[6]: <pre>{'id': 1,\n 'code': None,\n 'subd': {'a': 23, 'b': {'herm': 2}},\n 'type': 'foo',\n 'bars': [{'id': 6934900},\n  {'id': 6934977},\n  {'id': 6934992},\n  {'id': 6934993},\n  {'id': 6935014}],\n 'n': 10,\n 'date_str': '2013-07-08 00:00:00',\n 'float_here': 0.454545,\n 'complex': [{'id': 83865, 'goal': 'herm', 'state': 'active'}],\n 'profile_id': None,\n 'state': 'active'}</pre> In\u00a0[7]: Copied! <pre>parsed_dict_str == data\n</pre> parsed_dict_str == data Out[7]: <pre>True</pre> In\u00a0[8]: Copied! <pre>json_parsed_data = json.loads(data_json_string)\nprint(\"---\")\nprint(\"DATA PARSED VIA JSON:\", json_parsed_data)\nprint(\"---\")\nprint(f\"JSON PARSED DATA == DICT PARSED DATA: {json_parsed_data == parsed_dict_str}\")\n</pre> json_parsed_data = json.loads(data_json_string) print(\"---\") print(\"DATA PARSED VIA JSON:\", json_parsed_data) print(\"---\") print(f\"JSON PARSED DATA == DICT PARSED DATA: {json_parsed_data == parsed_dict_str}\") <pre>---\nDATA PARSED VIA JSON: {'id': 1, 'code': None, 'subd': {'a': 23, 'b': {'herm': 2}}, 'type': 'foo', 'bars': [{'id': 6934900}, {'id': 6934977}, {'id': 6934992}, {'id': 6934993}, {'id': 6935014}], 'n': 10, 'date_str': '2013-07-08 00:00:00', 'float_here': 0.454545, 'complex': [{'id': 83865, 'goal': 'herm', 'state': 'active'}], 'profile_id': None, 'state': 'active'}\n---\nJSON PARSED DATA == DICT PARSED DATA: True\n</pre> In\u00a0[9]: Copied! <pre>%%timeit\nexec(parse_and_set_data_python_str)\n</pre> %%timeit exec(parse_and_set_data_python_str) <pre>67.6 \u00b5s \u00b1 2.2 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n</pre> In\u00a0[10]: Copied! <pre>%%timeit\n# NBVAL_IGNORE_OUTPUT\njson_parsed_data = json.loads(data_json_string)\n</pre> %%timeit # NBVAL_IGNORE_OUTPUT json_parsed_data = json.loads(data_json_string) <pre>7.34 \u00b5s \u00b1 1.52 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n</pre> In\u00a0[11]: Copied! <pre>%%timeit\n# NBVAL_IGNORE_OUTPUT\nimport rapidjson\n\njson_parsed_data = rapidjson.loads(data_json_string)\n</pre> %%timeit # NBVAL_IGNORE_OUTPUT import rapidjson  json_parsed_data = rapidjson.loads(data_json_string) <pre>7.52 \u00b5s \u00b1 152 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n</pre> In\u00a0[12]: Copied! <pre>%%timeit\n# NBVAL_IGNORE_OUTPUT\nimport ujson\n\njson_parsed_data = ujson.loads(data_json_string)\n</pre> %%timeit # NBVAL_IGNORE_OUTPUT import ujson  json_parsed_data = ujson.loads(data_json_string) <pre>4.16 \u00b5s \u00b1 114 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n</pre> In\u00a0[13]: Copied! <pre>%%timeit\n# NBVAL_IGNORE_OUTPUT\nimport orjson\n\njson_parsed_data = orjson.loads(data_json_string)\n</pre> %%timeit # NBVAL_IGNORE_OUTPUT import orjson  json_parsed_data = orjson.loads(data_json_string) <pre>4.01 \u00b5s \u00b1 197 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n</pre>"},{"location":"notebooks/json_parsing/#json-python","title":"JSON &amp; python\u00b6","text":""},{"location":"notebooks/json_parsing/#here-is-a-dictionary","title":"Here is a dictionary...\u00b6","text":"<p>We can create this dictionary by writing it as python code (like below).</p> <p>We could also create the same dictionary by <code>json.loads</code>-ing a json string of the same dictionary.</p> <p>It turns out that parsing a json string is MUCH faster than creating the dictionary as a python literal</p>"},{"location":"notebooks/json_parsing/#creating-a-python-literal-dictionary-for-python-to-parse","title":"Creating a python literal dictionary for python to parse\u00b6","text":""},{"location":"notebooks/json_parsing/#creating-a-json-string-to-parse","title":"Creating a JSON string to parse\u00b6","text":""},{"location":"notebooks/json_parsing/#note-the-json-string-and-the-python-string-look-almost-identical","title":"NOTE: The json string and the python string look almost identical\u00b6","text":""},{"location":"notebooks/json_parsing/#parsing-the-dictionary-string-w-python","title":"Parsing the dictionary string w/ python\u00b6","text":""},{"location":"notebooks/json_parsing/#they-are-the-same","title":"They are the same!\u00b6","text":""},{"location":"notebooks/json_parsing/#parsing-the-json-string-dictionary","title":"Parsing the JSON string dictionary\u00b6","text":""},{"location":"notebooks/json_parsing/#its-time-to-time","title":"It's time to time\u00b6","text":""},{"location":"notebooks/json_parsing/#first-up-parsing-the-python-dictionary-as-a-string","title":"First up parsing the python dictionary as a string\u00b6","text":""},{"location":"notebooks/json_parsing/#second-parsing-the-json-string","title":"Second parsing the json string\u00b6","text":""},{"location":"notebooks/json_parsing/#the-json-parsing-is-way-faster-but-there-are-faster-json-libs-for-python","title":"The JSON parsing is WAY faster... but there are faster json libs for python\u00b6","text":""},{"location":"notebooks/json_parsing/#lets-try-python-rapidjson","title":"Lets try python-rapidjson\u00b6","text":""},{"location":"notebooks/json_parsing/#lets-try-ujson","title":"Lets try ujson\u00b6","text":""},{"location":"notebooks/json_parsing/#lets-try-orjson","title":"Lets try orjson\u00b6","text":""},{"location":"notebooks/string_fmt/","title":"String fmt","text":"In\u00a0[1]: Copied! <pre>def qt(string):\n    return '\"' + string + '\"'\n</pre> def qt(string):     return '\"' + string + '\"' <p>This is not the fastest way to format a string in python 3 nor is it the easiest to edit. A first revision would be to change the formatting of the string to use python's built in string-format method called <code>.format()</code> so that the code looks like:</p> In\u00a0[2]: Copied! <pre>def qt(string):\n    return f'\"{string}\"'\n</pre> def qt(string):     return f'\"{string}\"' <p>The above code will be faster to run and to edit, and doesn't require the backslashes to escape the double quotes. The ultimate way to transform this code would be to turn it into:</p> In\u00a0[3]: Copied! <pre>qt = '\"{}\"'.format\n</pre> qt = '\"{}\"'.format <p>See the pro tip below</p> In\u00a0[4]: Copied! <pre>def hyphens(string):\n    return f\"--{string}--\"\n\n\nhyphens(\"howdy\")  # returns: \"--howdy--\"\nhyphens(\"sheldon\")  # returns: \"--sheldon--\"\n</pre> def hyphens(string):     return f\"--{string}--\"   hyphens(\"howdy\")  # returns: \"--howdy--\" hyphens(\"sheldon\")  # returns: \"--sheldon--\" Out[4]: <pre>'--sheldon--'</pre> <p>The super slick way of formatting this without having to define a new string is to python's format function alone:</p> In\u00a0[5]: Copied! <pre>hyphens = \"--{}--\".format\n\nhyphens(\"howdy\")  # returns: \"--howdy--\"\nhyphens(\"sheldon\")  # returns: \"--sheldon--\"\n</pre> hyphens = \"--{}--\".format  hyphens(\"howdy\")  # returns: \"--howdy--\" hyphens(\"sheldon\")  # returns: \"--sheldon--\" Out[5]: <pre>'--sheldon--'</pre>"},{"location":"notebooks/string_fmt/#string-formatting","title":"String Formatting\u00b6","text":"<p>In the old robot code and the pydevkit there is a function for surrounding a string in quotes named <code>qt</code> and looks something like:</p>"},{"location":"notebooks/string_fmt/#pro-tip","title":"Pro Tip\u00b6","text":"<p>Say you have to format something (which you might have to do all the time), and you define a function to format a string so it has hyphens around the original string:</p>"}]}